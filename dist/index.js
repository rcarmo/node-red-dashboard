var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t4, e4) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e4() : typeof define == "function" && define.amd ? define(e4) : (t4 = typeof globalThis != "undefined" ? globalThis : t4 || self).dayjs = e4();
  })(exports, function() {
    var t4 = 1000, e4 = 60000, n3 = 3600000, r3 = "millisecond", i3 = "second", s3 = "minute", u3 = "hour", a3 = "day", o3 = "week", c3 = "month", f3 = "quarter", h3 = "year", d3 = "date", l3 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t5) {
      var e5 = ["th", "st", "nd", "rd"], n4 = t5 % 100;
      return "[" + t5 + (e5[(n4 - 20) % 10] || e5[n4] || e5[0]) + "]";
    } }, m5 = function(t5, e5, n4) {
      var r4 = String(t5);
      return !r4 || r4.length >= e5 ? t5 : "" + Array(e5 + 1 - r4.length).join(n4) + t5;
    }, v3 = { s: m5, z: function(t5) {
      var e5 = -t5.utcOffset(), n4 = Math.abs(e5), r4 = Math.floor(n4 / 60), i4 = n4 % 60;
      return (e5 <= 0 ? "+" : "-") + m5(r4, 2, "0") + ":" + m5(i4, 2, "0");
    }, m: function t(e5, n4) {
      if (e5.date() < n4.date())
        return -t(n4, e5);
      var r4 = 12 * (n4.year() - e5.year()) + (n4.month() - e5.month()), i4 = e5.clone().add(r4, c3), s4 = n4 - i4 < 0, u4 = e5.clone().add(r4 + (s4 ? -1 : 1), c3);
      return +(-(r4 + (n4 - i4) / (s4 ? i4 - u4 : u4 - i4)) || 0);
    }, a: function(t5) {
      return t5 < 0 ? Math.ceil(t5) || 0 : Math.floor(t5);
    }, p: function(t5) {
      return { M: c3, y: h3, w: o3, d: a3, D: d3, h: u3, m: s3, s: i3, ms: r3, Q: f3 }[t5] || String(t5 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t5) {
      return t5 === undefined;
    } }, g2 = "en", D3 = {};
    D3[g2] = M2;
    var p3 = "$isDayjsObject", S2 = function(t5) {
      return t5 instanceof _3 || !(!t5 || !t5[p3]);
    }, w3 = function t(e5, n4, r4) {
      var i4;
      if (!e5)
        return g2;
      if (typeof e5 == "string") {
        var s4 = e5.toLowerCase();
        D3[s4] && (i4 = s4), n4 && (D3[s4] = n4, i4 = s4);
        var u4 = e5.split("-");
        if (!i4 && u4.length > 1)
          return t(u4[0]);
      } else {
        var a4 = e5.name;
        D3[a4] = e5, i4 = a4;
      }
      return !r4 && i4 && (g2 = i4), i4 || !r4 && g2;
    }, O2 = function(t5, e5) {
      if (S2(t5))
        return t5.clone();
      var n4 = typeof e5 == "object" ? e5 : {};
      return n4.date = t5, n4.args = arguments, new _3(n4);
    }, b = v3;
    b.l = w3, b.i = S2, b.w = function(t5, e5) {
      return O2(t5, { locale: e5.$L, utc: e5.$u, x: e5.$x, $offset: e5.$offset });
    };
    var _3 = function() {
      function M3(t5) {
        this.$L = w3(t5.locale, null, true), this.parse(t5), this.$x = this.$x || t5.x || {}, this[p3] = true;
      }
      var m6 = M3.prototype;
      return m6.parse = function(t5) {
        this.$d = function(t6) {
          var { date: e5, utc: n4 } = t6;
          if (e5 === null)
            return new Date(NaN);
          if (b.u(e5))
            return new Date;
          if (e5 instanceof Date)
            return new Date(e5);
          if (typeof e5 == "string" && !/Z$/i.test(e5)) {
            var r4 = e5.match($2);
            if (r4) {
              var i4 = r4[2] - 1 || 0, s4 = (r4[7] || "0").substring(0, 3);
              return n4 ? new Date(Date.UTC(r4[1], i4, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s4)) : new Date(r4[1], i4, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s4);
            }
          }
          return new Date(e5);
        }(t5), this.init();
      }, m6.init = function() {
        var t5 = this.$d;
        this.$y = t5.getFullYear(), this.$M = t5.getMonth(), this.$D = t5.getDate(), this.$W = t5.getDay(), this.$H = t5.getHours(), this.$m = t5.getMinutes(), this.$s = t5.getSeconds(), this.$ms = t5.getMilliseconds();
      }, m6.$utils = function() {
        return b;
      }, m6.isValid = function() {
        return !(this.$d.toString() === l3);
      }, m6.isSame = function(t5, e5) {
        var n4 = O2(t5);
        return this.startOf(e5) <= n4 && n4 <= this.endOf(e5);
      }, m6.isAfter = function(t5, e5) {
        return O2(t5) < this.startOf(e5);
      }, m6.isBefore = function(t5, e5) {
        return this.endOf(e5) < O2(t5);
      }, m6.$g = function(t5, e5, n4) {
        return b.u(t5) ? this[e5] : this.set(n4, t5);
      }, m6.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m6.valueOf = function() {
        return this.$d.getTime();
      }, m6.startOf = function(t5, e5) {
        var n4 = this, r4 = !!b.u(e5) || e5, f4 = b.p(t5), l4 = function(t6, e6) {
          var i4 = b.w(n4.$u ? Date.UTC(n4.$y, e6, t6) : new Date(n4.$y, e6, t6), n4);
          return r4 ? i4 : i4.endOf(a3);
        }, $3 = function(t6, e6) {
          return b.w(n4.toDate()[t6].apply(n4.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e6)), n4);
        }, y4 = this.$W, M4 = this.$M, m7 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
        switch (f4) {
          case h3:
            return r4 ? l4(1, 0) : l4(31, 11);
          case c3:
            return r4 ? l4(1, M4) : l4(0, M4 + 1);
          case o3:
            var g3 = this.$locale().weekStart || 0, D4 = (y4 < g3 ? y4 + 7 : y4) - g3;
            return l4(r4 ? m7 - D4 : m7 + (6 - D4), M4);
          case a3:
          case d3:
            return $3(v4 + "Hours", 0);
          case u3:
            return $3(v4 + "Minutes", 1);
          case s3:
            return $3(v4 + "Seconds", 2);
          case i3:
            return $3(v4 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m6.endOf = function(t5) {
        return this.startOf(t5, false);
      }, m6.$set = function(t5, e5) {
        var n4, o4 = b.p(t5), f4 = "set" + (this.$u ? "UTC" : ""), l4 = (n4 = {}, n4[a3] = f4 + "Date", n4[d3] = f4 + "Date", n4[c3] = f4 + "Month", n4[h3] = f4 + "FullYear", n4[u3] = f4 + "Hours", n4[s3] = f4 + "Minutes", n4[i3] = f4 + "Seconds", n4[r3] = f4 + "Milliseconds", n4)[o4], $3 = o4 === a3 ? this.$D + (e5 - this.$W) : e5;
        if (o4 === c3 || o4 === h3) {
          var y4 = this.clone().set(d3, 1);
          y4.$d[l4]($3), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
        } else
          l4 && this.$d[l4]($3);
        return this.init(), this;
      }, m6.set = function(t5, e5) {
        return this.clone().$set(t5, e5);
      }, m6.get = function(t5) {
        return this[b.p(t5)]();
      }, m6.add = function(r4, f4) {
        var d4, l4 = this;
        r4 = Number(r4);
        var $3 = b.p(f4), y4 = function(t5) {
          var e5 = O2(l4);
          return b.w(e5.date(e5.date() + Math.round(t5 * r4)), l4);
        };
        if ($3 === c3)
          return this.set(c3, this.$M + r4);
        if ($3 === h3)
          return this.set(h3, this.$y + r4);
        if ($3 === a3)
          return y4(1);
        if ($3 === o3)
          return y4(7);
        var M4 = (d4 = {}, d4[s3] = e4, d4[u3] = n3, d4[i3] = t4, d4)[$3] || 1, m7 = this.$d.getTime() + r4 * M4;
        return b.w(m7, this);
      }, m6.subtract = function(t5, e5) {
        return this.add(-1 * t5, e5);
      }, m6.format = function(t5) {
        var e5 = this, n4 = this.$locale();
        if (!this.isValid())
          return n4.invalidDate || l3;
        var r4 = t5 || "YYYY-MM-DDTHH:mm:ssZ", i4 = b.z(this), s4 = this.$H, u4 = this.$m, a4 = this.$M, o4 = n4.weekdays, c4 = n4.months, f4 = n4.meridiem, h4 = function(t6, n5, i5, s5) {
          return t6 && (t6[n5] || t6(e5, r4)) || i5[n5].slice(0, s5);
        }, d4 = function(t6) {
          return b.s(s4 % 12 || 12, t6, "0");
        }, $3 = f4 || function(t6, e6, n5) {
          var r5 = t6 < 12 ? "AM" : "PM";
          return n5 ? r5.toLowerCase() : r5;
        };
        return r4.replace(y3, function(t6, r5) {
          return r5 || function(t7) {
            switch (t7) {
              case "YY":
                return String(e5.$y).slice(-2);
              case "YYYY":
                return b.s(e5.$y, 4, "0");
              case "M":
                return a4 + 1;
              case "MM":
                return b.s(a4 + 1, 2, "0");
              case "MMM":
                return h4(n4.monthsShort, a4, c4, 3);
              case "MMMM":
                return h4(c4, a4);
              case "D":
                return e5.$D;
              case "DD":
                return b.s(e5.$D, 2, "0");
              case "d":
                return String(e5.$W);
              case "dd":
                return h4(n4.weekdaysMin, e5.$W, o4, 2);
              case "ddd":
                return h4(n4.weekdaysShort, e5.$W, o4, 3);
              case "dddd":
                return o4[e5.$W];
              case "H":
                return String(s4);
              case "HH":
                return b.s(s4, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $3(s4, u4, true);
              case "A":
                return $3(s4, u4, false);
              case "m":
                return String(u4);
              case "mm":
                return b.s(u4, 2, "0");
              case "s":
                return String(e5.$s);
              case "ss":
                return b.s(e5.$s, 2, "0");
              case "SSS":
                return b.s(e5.$ms, 3, "0");
              case "Z":
                return i4;
            }
            return null;
          }(t6) || i4.replace(":", "");
        });
      }, m6.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m6.diff = function(r4, d4, l4) {
        var $3, y4 = this, M4 = b.p(d4), m7 = O2(r4), v4 = (m7.utcOffset() - this.utcOffset()) * e4, g3 = this - m7, D4 = function() {
          return b.m(y4, m7);
        };
        switch (M4) {
          case h3:
            $3 = D4() / 12;
            break;
          case c3:
            $3 = D4();
            break;
          case f3:
            $3 = D4() / 3;
            break;
          case o3:
            $3 = (g3 - v4) / 604800000;
            break;
          case a3:
            $3 = (g3 - v4) / 86400000;
            break;
          case u3:
            $3 = g3 / n3;
            break;
          case s3:
            $3 = g3 / e4;
            break;
          case i3:
            $3 = g3 / t4;
            break;
          default:
            $3 = g3;
        }
        return l4 ? $3 : b.a($3);
      }, m6.daysInMonth = function() {
        return this.endOf(c3).$D;
      }, m6.$locale = function() {
        return D3[this.$L];
      }, m6.locale = function(t5, e5) {
        if (!t5)
          return this.$L;
        var n4 = this.clone(), r4 = w3(t5, e5, true);
        return r4 && (n4.$L = r4), n4;
      }, m6.clone = function() {
        return b.w(this.$d, this);
      }, m6.toDate = function() {
        return new Date(this.valueOf());
      }, m6.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m6.toISOString = function() {
        return this.$d.toISOString();
      }, m6.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k3 = _3.prototype;
    return O2.prototype = k3, [["$ms", r3], ["$s", i3], ["$m", s3], ["$H", u3], ["$W", a3], ["$M", c3], ["$y", h3], ["$D", d3]].forEach(function(t5) {
      k3[t5[1]] = function(e5) {
        return this.$g(e5, t5[0], t5[1]);
      };
    }), O2.extend = function(t5, e5) {
      return t5.$i || (t5(e5, _3, O2), t5.$i = true), O2;
    }, O2.locale = w3, O2.isDayjs = S2, O2.unix = function(t5) {
      return O2(1000 * t5);
    }, O2.en = D3[g2], O2.Ls = D3, O2.p = {}, O2;
  });
});

// node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  (function(t4, i3) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i3() : typeof define == "function" && define.amd ? define(i3) : (t4 = typeof globalThis != "undefined" ? globalThis : t4 || self).dayjs_plugin_utc = i3();
  })(exports, function() {
    var t4 = "minute", i3 = /[+-]\d\d(?::?\d\d)?/g, e4 = /([+-]|\d\d)/g;
    return function(s3, f3, n3) {
      var u3 = f3.prototype;
      n3.utc = function(t5) {
        var i4 = { date: t5, utc: true, args: arguments };
        return new f3(i4);
      }, u3.utc = function(i4) {
        var e5 = n3(this.toDate(), { locale: this.$L, utc: true });
        return i4 ? e5.add(this.utcOffset(), t4) : e5;
      }, u3.local = function() {
        return n3(this.toDate(), { locale: this.$L, utc: false });
      };
      var r3 = u3.parse;
      u3.parse = function(t5) {
        t5.utc && (this.$u = true), this.$utils().u(t5.$offset) || (this.$offset = t5.$offset), r3.call(this, t5);
      };
      var o3 = u3.init;
      u3.init = function() {
        if (this.$u) {
          var t5 = this.$d;
          this.$y = t5.getUTCFullYear(), this.$M = t5.getUTCMonth(), this.$D = t5.getUTCDate(), this.$W = t5.getUTCDay(), this.$H = t5.getUTCHours(), this.$m = t5.getUTCMinutes(), this.$s = t5.getUTCSeconds(), this.$ms = t5.getUTCMilliseconds();
        } else
          o3.call(this);
      };
      var a3 = u3.utcOffset;
      u3.utcOffset = function(s4, f4) {
        var n4 = this.$utils().u;
        if (n4(s4))
          return this.$u ? 0 : n4(this.$offset) ? a3.call(this) : this.$offset;
        if (typeof s4 == "string" && (s4 = function(t5) {
          t5 === undefined && (t5 = "");
          var s5 = t5.match(i3);
          if (!s5)
            return null;
          var f5 = ("" + s5[0]).match(e4) || ["-", 0, 0], n5 = f5[0], u5 = 60 * +f5[1] + +f5[2];
          return u5 === 0 ? 0 : n5 === "+" ? u5 : -u5;
        }(s4), s4 === null))
          return this;
        var u4 = Math.abs(s4) <= 16 ? 60 * s4 : s4;
        if (u4 === 0)
          return this.utc(f4);
        var r4 = this.clone();
        if (f4)
          return r4.$offset = u4, r4.$u = false, r4;
        var o4 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
        return (r4 = this.local().add(u4 + o4, t4)).$offset = u4, r4.$x.$localOffset = o4, r4;
      };
      var h3 = u3.format;
      u3.format = function(t5) {
        var i4 = t5 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h3.call(this, i4);
      }, u3.valueOf = function() {
        var t5 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 60000 * t5;
      }, u3.isUTC = function() {
        return !!this.$u;
      }, u3.toISOString = function() {
        return this.toDate().toISOString();
      }, u3.toString = function() {
        return this.toDate().toUTCString();
      };
      var l3 = u3.toDate;
      u3.toDate = function(t5) {
        return t5 === "s" && this.$offset ? n3(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l3.call(this);
      };
      var c3 = u3.diff;
      u3.diff = function(t5, i4, e5) {
        if (t5 && this.$u === t5.$u)
          return c3.call(this, t5, i4, e5);
        var s4 = this.local(), f4 = n3(t5).local();
        return c3.call(s4, f4, i4, e5);
      };
    };
  });
});

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var r;
var o;
var e;
var f;
var c;
var s;
var a;
var h;
var p = {};
var v = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var w = Array.isArray;
function d(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function g(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function _(l2, u2, t2) {
  var i2, r2, o2, e2 = {};
  for (o2 in u2)
    o2 == "key" ? i2 = u2[o2] : o2 == "ref" ? r2 = u2[o2] : e2[o2] = u2[o2];
  if (arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), typeof l2 == "function" && l2.defaultProps != null)
    for (o2 in l2.defaultProps)
      e2[o2] === undefined && (e2[o2] = l2.defaultProps[o2]);
  return m(l2, e2, i2, r2, null);
}
function m(n2, t2, i2, r2, o2) {
  var e2 = { type: n2, props: t2, key: i2, ref: r2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: undefined, __v: o2 == null ? ++u : o2, __i: -1, __u: 0 };
  return o2 == null && l.vnode != null && l.vnode(e2), e2;
}
function k(n2) {
  return n2.children;
}
function x(n2, l2) {
  this.props = n2, this.context = l2;
}
function S(n2, l2) {
  if (l2 == null)
    return n2.__ ? S(n2.__, n2.__i + 1) : null;
  for (var u2;l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? S(n2) : null;
}
function C(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0;l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return C(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !$.__r++ || r != l.debounceRendering) && ((r = l.debounceRendering) || o)($);
}
function $() {
  for (var n2, u2, t2, r2, o2, f2, c2, s2 = 1;i.length; )
    i.length > s2 && i.sort(e), n2 = i.shift(), s2 = i.length, n2.__d && (t2 = undefined, r2 = undefined, o2 = (r2 = (u2 = n2).__v).__e, f2 = [], c2 = [], u2.__P && ((t2 = d({}, r2)).__v = r2.__v + 1, l.vnode && l.vnode(t2), O(u2.__P, t2, r2, u2.__n, u2.__P.namespaceURI, 32 & r2.__u ? [o2] : null, f2, o2 == null ? S(r2) : o2, !!(32 & r2.__u), c2), t2.__v = r2.__v, t2.__.__k[t2.__i] = t2, N(f2, t2, c2), r2.__e = r2.__ = null, t2.__e != o2 && C(t2)));
  $.__r = 0;
}
function I(n2, l2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, y2, w2, d2, g2, _2, m2 = t2 && t2.__k || v, b = l2.length;
  for (f2 = P(u2, l2, m2, f2, b), a2 = 0;a2 < b; a2++)
    (y2 = u2.__k[a2]) != null && (h2 = y2.__i == -1 ? p : m2[y2.__i] || p, y2.__i = a2, g2 = O(n2, y2, h2, i2, r2, o2, e2, f2, c2, s2), w2 = y2.__e, y2.ref && h2.ref != y2.ref && (h2.ref && B(h2.ref, null, y2), s2.push(y2.ref, y2.__c || w2, y2)), d2 == null && w2 != null && (d2 = w2), (_2 = !!(4 & y2.__u)) || h2.__k === y2.__k ? f2 = A(y2, f2, n2, _2) : typeof y2.type == "function" && g2 !== undefined ? f2 = g2 : w2 && (f2 = w2.nextSibling), y2.__u &= -7);
  return u2.__e = d2, f2;
}
function P(n2, l2, u2, t2, i2) {
  var r2, o2, e2, f2, c2, s2 = u2.length, a2 = s2, h2 = 0;
  for (n2.__k = new Array(i2), r2 = 0;r2 < i2; r2++)
    (o2 = l2[r2]) != null && typeof o2 != "boolean" && typeof o2 != "function" ? (typeof o2 == "string" || typeof o2 == "number" || typeof o2 == "bigint" || o2.constructor == String ? o2 = n2.__k[r2] = m(null, o2, null, null, null) : w(o2) ? o2 = n2.__k[r2] = m(k, { children: o2 }, null, null, null) : o2.constructor == null && o2.__b > 0 ? o2 = n2.__k[r2] = m(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : n2.__k[r2] = o2, f2 = r2 + h2, o2.__ = n2, o2.__b = n2.__b + 1, (c2 = o2.__i = L(o2, u2, f2, a2)) != -1 && (a2--, (e2 = u2[c2]) && (e2.__u |= 2)), e2 == null || e2.__v == null ? (c2 == -1 && (i2 > s2 ? h2-- : i2 < s2 && h2++), typeof o2.type != "function" && (o2.__u |= 4)) : c2 != f2 && (c2 == f2 - 1 ? h2-- : c2 == f2 + 1 ? h2++ : (c2 > f2 ? h2-- : h2++, o2.__u |= 4))) : n2.__k[r2] = null;
  if (a2)
    for (r2 = 0;r2 < s2; r2++)
      (e2 = u2[r2]) != null && (2 & e2.__u) == 0 && (e2.__e == t2 && (t2 = S(e2)), D(e2, e2));
  return t2;
}
function A(n2, l2, u2, t2) {
  var i2, r2;
  if (typeof n2.type == "function") {
    for (i2 = n2.__k, r2 = 0;i2 && r2 < i2.length; r2++)
      i2[r2] && (i2[r2].__ = n2, l2 = A(i2[r2], l2, u2, t2));
    return l2;
  }
  n2.__e != l2 && (t2 && (l2 && n2.type && !l2.parentNode && (l2 = S(n2)), u2.insertBefore(n2.__e, l2 || null)), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (l2 != null && l2.nodeType == 8);
  return l2;
}
function L(n2, l2, u2, t2) {
  var i2, r2, o2, e2 = n2.key, f2 = n2.type, c2 = l2[u2], s2 = c2 != null && (2 & c2.__u) == 0;
  if (c2 === null && e2 == null || s2 && e2 == c2.key && f2 == c2.type)
    return u2;
  if (t2 > (s2 ? 1 : 0)) {
    for (i2 = u2 - 1, r2 = u2 + 1;i2 >= 0 || r2 < l2.length; )
      if ((c2 = l2[o2 = i2 >= 0 ? i2-- : r2++]) != null && (2 & c2.__u) == 0 && e2 == c2.key && f2 == c2.type)
        return o2;
  }
  return -1;
}
function T(n2, l2, u2) {
  l2[0] == "-" ? n2.setProperty(l2, u2 == null ? "" : u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || y.test(l2) ? u2 : u2 + "px";
}
function j(n2, l2, u2, t2, i2) {
  var r2, o2;
  n:
    if (l2 == "style")
      if (typeof u2 == "string")
        n2.style.cssText = u2;
      else {
        if (typeof t2 == "string" && (n2.style.cssText = t2 = ""), t2)
          for (l2 in t2)
            u2 && l2 in u2 || T(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            t2 && u2[l2] == t2[l2] || T(n2.style, l2, u2[l2]);
      }
    else if (l2[0] == "o" && l2[1] == "n")
      r2 = l2 != (l2 = l2.replace(f, "$1")), o2 = l2.toLowerCase(), l2 = o2 in n2 || l2 == "onFocusOut" || l2 == "onFocusIn" ? o2.slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = c, n2.addEventListener(l2, r2 ? a : s, r2)) : n2.removeEventListener(l2, r2 ? a : s, r2);
    else {
      if (i2 == "http://www.w3.org/2000/svg")
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l2 != "width" && l2 != "height" && l2 != "href" && l2 != "list" && l2 != "form" && l2 != "tabIndex" && l2 != "download" && l2 != "rowSpan" && l2 != "colSpan" && l2 != "role" && l2 != "popover" && l2 in n2)
        try {
          n2[l2] = u2 == null ? "" : u2;
          break n;
        } catch (n3) {}
      typeof u2 == "function" || (u2 == null || u2 === false && l2[4] != "-" ? n2.removeAttribute(l2) : n2.setAttribute(l2, l2 == "popover" && u2 == 1 ? "" : u2));
    }
}
function F(n2) {
  return function(u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n2];
      if (u2.t == null)
        u2.t = c++;
      else if (u2.t < t2.u)
        return;
      return t2(l.event ? l.event(u2) : u2);
    }
  };
}
function O(n2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, p2, v2, y2, _2, m2, b, S2, C2, M2, $2, P2, A2, H, L2, T2, j2 = u2.type;
  if (u2.constructor != null)
    return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), o2 = [f2 = u2.__e = t2.__e]), (a2 = l.__b) && a2(u2);
  n:
    if (typeof j2 == "function")
      try {
        if (b = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C2 = (a2 = j2.contextType) && i2[a2.__c], M2 = a2 ? C2 ? C2.props.value : a2.__ : i2, t2.__c ? m2 = (h2 = u2.__c = t2.__c).__ = h2.__E : (S2 ? u2.__c = h2 = new j2(b, M2) : (u2.__c = h2 = new x(b, M2), h2.constructor = j2, h2.render = E), C2 && C2.sub(h2), h2.state || (h2.state = {}), h2.__n = i2, p2 = h2.__d = true, h2.__h = [], h2._sb = []), S2 && h2.__s == null && (h2.__s = h2.state), S2 && j2.getDerivedStateFromProps != null && (h2.__s == h2.state && (h2.__s = d({}, h2.__s)), d(h2.__s, j2.getDerivedStateFromProps(b, h2.__s))), v2 = h2.props, y2 = h2.state, h2.__v = u2, p2)
          S2 && j2.getDerivedStateFromProps == null && h2.componentWillMount != null && h2.componentWillMount(), S2 && h2.componentDidMount != null && h2.__h.push(h2.componentDidMount);
        else {
          if (S2 && j2.getDerivedStateFromProps == null && b !== v2 && h2.componentWillReceiveProps != null && h2.componentWillReceiveProps(b, M2), u2.__v == t2.__v || !h2.__e && h2.shouldComponentUpdate != null && h2.shouldComponentUpdate(b, h2.__s, M2) === false) {
            for (u2.__v != t2.__v && (h2.props = b, h2.state = h2.__s, h2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.some(function(n3) {
              n3 && (n3.__ = u2);
            }), $2 = 0;$2 < h2._sb.length; $2++)
              h2.__h.push(h2._sb[$2]);
            h2._sb = [], h2.__h.length && e2.push(h2);
            break n;
          }
          h2.componentWillUpdate != null && h2.componentWillUpdate(b, h2.__s, M2), S2 && h2.componentDidUpdate != null && h2.__h.push(function() {
            h2.componentDidUpdate(v2, y2, _2);
          });
        }
        if (h2.context = M2, h2.props = b, h2.__P = n2, h2.__e = false, P2 = l.__r, A2 = 0, S2) {
          for (h2.state = h2.__s, h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), H = 0;H < h2._sb.length; H++)
            h2.__h.push(h2._sb[H]);
          h2._sb = [];
        } else
          do {
            h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
          } while (h2.__d && ++A2 < 25);
        h2.state = h2.__s, h2.getChildContext != null && (i2 = d(d({}, i2), h2.getChildContext())), S2 && !p2 && h2.getSnapshotBeforeUpdate != null && (_2 = h2.getSnapshotBeforeUpdate(v2, y2)), L2 = a2, a2 != null && a2.type === k && a2.key == null && (L2 = V(a2.props.children)), f2 = I(n2, w(L2) ? L2 : [L2], u2, t2, i2, r2, o2, e2, f2, c2, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && e2.push(h2), m2 && (h2.__E = h2.__ = null);
      } catch (n3) {
        if (u2.__v = null, c2 || o2 != null)
          if (n3.then) {
            for (u2.__u |= c2 ? 160 : 128;f2 && f2.nodeType == 8 && f2.nextSibling; )
              f2 = f2.nextSibling;
            o2[o2.indexOf(f2)] = null, u2.__e = f2;
          } else {
            for (T2 = o2.length;T2--; )
              g(o2[T2]);
            z(u2);
          }
        else
          u2.__e = t2.__e, u2.__k = t2.__k, n3.then || z(u2);
        l.__e(n3, u2, t2);
      }
    else
      o2 == null && u2.__v == t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : f2 = u2.__e = q(t2.__e, u2, t2, i2, r2, o2, e2, c2, s2);
  return (a2 = l.diffed) && a2(u2), 128 & u2.__u ? undefined : f2;
}
function z(n2) {
  n2 && n2.__c && (n2.__c.__e = true), n2 && n2.__k && n2.__k.forEach(z);
}
function N(n2, u2, t2) {
  for (var i2 = 0;i2 < t2.length; i2++)
    B(t2[i2], t2[++i2], t2[++i2]);
  l.__c && l.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l.__e(n3, u3.__v);
    }
  });
}
function V(n2) {
  return typeof n2 != "object" || n2 == null || n2.__b && n2.__b > 0 ? n2 : w(n2) ? n2.map(V) : d({}, n2);
}
function q(u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, v2, y2, d2, _2, m2, b = i2.props || p, k2 = t2.props, x2 = t2.type;
  if (x2 == "svg" ? o2 = "http://www.w3.org/2000/svg" : x2 == "math" ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), e2 != null) {
    for (a2 = 0;a2 < e2.length; a2++)
      if ((d2 = e2[a2]) && "setAttribute" in d2 == !!x2 && (x2 ? d2.localName == x2 : d2.nodeType == 3)) {
        u2 = d2, e2[a2] = null;
        break;
      }
  }
  if (u2 == null) {
    if (x2 == null)
      return document.createTextNode(k2);
    u2 = document.createElementNS(o2, x2, k2.is && k2), c2 && (l.__m && l.__m(t2, e2), c2 = false), e2 = null;
  }
  if (x2 == null)
    b === k2 || c2 && u2.data == k2 || (u2.data = k2);
  else {
    if (e2 = e2 && n.call(u2.childNodes), !c2 && e2 != null)
      for (b = {}, a2 = 0;a2 < u2.attributes.length; a2++)
        b[(d2 = u2.attributes[a2]).name] = d2.value;
    for (a2 in b)
      if (d2 = b[a2], a2 == "children")
        ;
      else if (a2 == "dangerouslySetInnerHTML")
        v2 = d2;
      else if (!(a2 in k2)) {
        if (a2 == "value" && "defaultValue" in k2 || a2 == "checked" && "defaultChecked" in k2)
          continue;
        j(u2, a2, null, d2, o2);
      }
    for (a2 in k2)
      d2 = k2[a2], a2 == "children" ? y2 = d2 : a2 == "dangerouslySetInnerHTML" ? h2 = d2 : a2 == "value" ? _2 = d2 : a2 == "checked" ? m2 = d2 : c2 && typeof d2 != "function" || b[a2] === d2 || j(u2, a2, d2, b[a2], o2);
    if (h2)
      c2 || v2 && (h2.__html == v2.__html || h2.__html == u2.innerHTML) || (u2.innerHTML = h2.__html), t2.__k = [];
    else if (v2 && (u2.innerHTML = ""), I(t2.type == "template" ? u2.content : u2, w(y2) ? y2 : [y2], t2, i2, r2, x2 == "foreignObject" ? "http://www.w3.org/1999/xhtml" : o2, e2, f2, e2 ? e2[0] : i2.__k && S(i2, 0), c2, s2), e2 != null)
      for (a2 = e2.length;a2--; )
        g(e2[a2]);
    c2 || (a2 = "value", x2 == "progress" && _2 == null ? u2.removeAttribute("value") : _2 != null && (_2 !== u2[a2] || x2 == "progress" && !_2 || x2 == "option" && _2 != b[a2]) && j(u2, a2, _2, b[a2], o2), a2 = "checked", m2 != null && m2 != u2[a2] && j(u2, a2, m2, b[a2], o2));
  }
  return u2;
}
function B(n2, u2, t2) {
  try {
    if (typeof n2 == "function") {
      var i2 = typeof n2.__u == "function";
      i2 && n2.__u(), i2 && u2 == null || (n2.__u = n2(u2));
    } else
      n2.current = u2;
  } catch (n3) {
    l.__e(n3, t2);
  }
}
function D(n2, u2, t2) {
  var i2, r2;
  if (l.unmount && l.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || B(i2, null, u2)), (i2 = n2.__c) != null) {
    if (i2.componentWillUnmount)
      try {
        i2.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u2);
      }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k)
    for (r2 = 0;r2 < i2.length; r2++)
      i2[r2] && D(i2[r2], u2, t2 || typeof n2.type != "function");
  t2 || g(n2.__e), n2.__c = n2.__ = n2.__e = undefined;
}
function E(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function G(u2, t2, i2) {
  var r2, o2, e2, f2;
  t2 == document && (t2 = document.documentElement), l.__ && l.__(u2, t2), o2 = (r2 = typeof i2 == "function") ? null : i2 && i2.__k || t2.__k, e2 = [], f2 = [], O(t2, u2 = (!r2 && i2 || t2).__k = _(k, null, [u2]), o2 || p, p, t2.namespaceURI, !r2 && i2 ? [i2] : o2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, e2, !r2 && i2 ? i2 : o2 ? o2.__e : t2.firstChild, r2, f2), N(e2, u2, f2);
}
function Q(n2) {
  function l2(n3) {
    var u2, t2;
    return this.getChildContext || (u2 = new Set, (t2 = {})[l2.__c] = this, this.getChildContext = function() {
      return t2;
    }, this.componentWillUnmount = function() {
      u2 = null;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value != n4.value && u2.forEach(function(n5) {
        n5.__e = true, M(n5);
      });
    }, this.sub = function(n4) {
      u2.add(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u2 && u2.delete(n4), l3 && l3.call(n4);
      };
    }), n3.children;
  }
  return l2.__c = "__cC" + h++, l2.__ = n2, l2.Provider = l2.__l = (l2.Consumer = function(n3, l3) {
    return n3.children(l3);
  }).contextType = l2, l2;
}
n = v.slice, l = { __e: function(n2, l2, u2, t2) {
  for (var i2, r2, o2;l2 = l2.__; )
    if ((i2 = l2.__c) && !i2.__)
      try {
        if ((r2 = i2.constructor) && r2.getDerivedStateFromError != null && (i2.setState(r2.getDerivedStateFromError(n2)), o2 = i2.__d), i2.componentDidCatch != null && (i2.componentDidCatch(n2, t2 || {}), o2 = i2.__d), o2)
          return i2.__E = i2;
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, u = 0, t = function(n2) {
  return n2 != null && n2.constructor == null;
}, x.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s != null && this.__s != this.state ? this.__s : this.__s = d({}, this.state), typeof n2 == "function" && (n2 = n2(d({}, u2), this.props)), n2 && d(u2, n2), n2 != null && this.__v && (l2 && this._sb.push(l2), M(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x.prototype.render = k, i = [], o = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, $.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = F(false), a = F(true), h = 0;
// node_modules/htm/dist/htm.module.js
var n2 = function(t2, s2, r2, e2) {
  var u2;
  s2[0] = 0;
  for (var h2 = 1;h2 < s2.length; h2++) {
    var p2 = s2[h2++], a2 = s2[h2] ? (s2[0] |= p2 ? 1 : 2, r2[s2[h2++]]) : s2[++h2];
    p2 === 3 ? e2[0] = a2 : p2 === 4 ? e2[1] = Object.assign(e2[1] || {}, a2) : p2 === 5 ? (e2[1] = e2[1] || {})[s2[++h2]] = a2 : p2 === 6 ? e2[1][s2[++h2]] += a2 + "" : p2 ? (u2 = t2.apply(a2, n2(t2, a2, r2, ["", null])), e2.push(u2), a2[0] ? s2[0] |= 2 : (s2[h2 - 2] = 0, s2[h2] = u2)) : e2.push(a2);
  }
  return e2;
};
var t2 = new Map;
function htm_module_default(s2) {
  var r2 = t2.get(this);
  return r2 || (r2 = new Map, t2.set(this, r2)), (r2 = n2(this, r2.get(s2) || (r2.set(s2, r2 = function(n3) {
    for (var t3, s3, r3 = 1, e2 = "", u2 = "", h2 = [0], p2 = function(n4) {
      r3 === 1 && (n4 || (e2 = e2.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h2.push(0, n4, e2) : r3 === 3 && (n4 || e2) ? (h2.push(3, n4, e2), r3 = 2) : r3 === 2 && e2 === "..." && n4 ? h2.push(4, n4, 0) : r3 === 2 && e2 && !n4 ? h2.push(5, 0, true, e2) : r3 >= 5 && ((e2 || !n4 && r3 === 5) && (h2.push(r3, 0, e2, s3), r3 = 6), n4 && (h2.push(r3, n4, 0, s3), r3 = 6)), e2 = "";
    }, a2 = 0;a2 < n3.length; a2++) {
      a2 && (r3 === 1 && p2(), p2(a2));
      for (var l2 = 0;l2 < n3[a2].length; l2++)
        t3 = n3[a2][l2], r3 === 1 ? t3 === "<" ? (p2(), h2 = [h2], r3 = 3) : e2 += t3 : r3 === 4 ? e2 === "--" && t3 === ">" ? (r3 = 1, e2 = "") : e2 = t3 + e2[0] : u2 ? t3 === u2 ? u2 = "" : e2 += t3 : t3 === '"' || t3 === "'" ? u2 = t3 : t3 === ">" ? (p2(), r3 = 1) : r3 && (t3 === "=" ? (r3 = 5, s3 = e2, e2 = "") : t3 === "/" && (r3 < 5 || n3[a2][l2 + 1] === ">") ? (p2(), r3 === 3 && (h2 = h2[0]), r3 = h2, (h2 = h2[0]).push(2, 0, r3), r3 = 0) : t3 === " " || t3 === "\t" || t3 === `
` || t3 === "\r" ? (p2(), r3 = 2) : e2 += t3), r3 === 3 && e2 === "!--" && (r3 = 4, h2 = h2[0]);
    }
    return p2(), h2;
  }(s2)), r2), arguments, [])).length > 1 ? r2 : r2[0];
}

// node_modules/htm/preact/index.module.js
var m2 = htm_module_default.bind(_);

// node_modules/preact/hooks/dist/hooks.module.js
var t3;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = l;
var e2 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l2 = c2.__c;
var m3 = c2.unmount;
var s2 = c2.__;
function p2(n3, t4) {
  c2.__h && c2.__h(r2, n3, o2 || t4), o2 = 0;
  var u3 = r2.__H || (r2.__H = { __: [], __h: [] });
  return n3 >= u3.__.length && u3.__.push({}), u3.__[n3];
}
function d2(n3) {
  return o2 = 1, h2(D2, n3);
}
function h2(n3, u3, i3) {
  var o3 = p2(t3++, 2);
  if (o3.t = n3, !o3.__c && (o3.__ = [i3 ? i3(u3) : D2(undefined, u3), function(n4) {
    var t4 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t4, n4);
    t4 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r2, !r2.__f)) {
    var f3 = function(n4, t4, r3) {
      if (!o3.__c.__H)
        return true;
      var u4 = o3.__c.__H.__.filter(function(n5) {
        return !!n5.__c;
      });
      if (u4.every(function(n5) {
        return !n5.__N;
      }))
        return !c3 || c3.call(this, n4, t4, r3);
      var i4 = o3.__c.props !== n4;
      return u4.forEach(function(n5) {
        if (n5.__N) {
          var t5 = n5.__[0];
          n5.__ = n5.__N, n5.__N = undefined, t5 !== n5.__[0] && (i4 = true);
        }
      }), c3 && c3.call(this, n4, t4, r3) || i4;
    };
    r2.__f = true;
    var { shouldComponentUpdate: c3, componentWillUpdate: e3 } = r2;
    r2.componentWillUpdate = function(n4, t4, r3) {
      if (this.__e) {
        var u4 = c3;
        c3 = undefined, f3(n4, t4, r3), c3 = u4;
      }
      e3 && e3.call(this, n4, t4, r3);
    }, r2.shouldComponentUpdate = f3;
  }
  return o3.__N || o3.__;
}
function y2(n3, u3) {
  var i3 = p2(t3++, 3);
  !c2.__s && C2(i3.__H, u3) && (i3.__ = n3, i3.u = u3, r2.__H.__h.push(i3));
}
function _2(n3, u3) {
  var i3 = p2(t3++, 4);
  !c2.__s && C2(i3.__H, u3) && (i3.__ = n3, i3.u = u3, r2.__h.push(i3));
}
function A2(n3) {
  return o2 = 5, T2(function() {
    return { current: n3 };
  }, []);
}
function T2(n3, r3) {
  var u3 = p2(t3++, 7);
  return C2(u3.__H, r3) && (u3.__ = n3(), u3.__H = r3, u3.__h = n3), u3.__;
}
function x2(n3) {
  var u3 = r2.context[n3.__c], i3 = p2(t3++, 9);
  return i3.c = n3, u3 ? (i3.__ == null && (i3.__ = true, u3.sub(r2)), u3.props.value) : n3.__;
}
function j2() {
  for (var n3;n3 = f2.shift(); )
    if (n3.__P && n3.__H)
      try {
        n3.__H.__h.forEach(z2), n3.__H.__h.forEach(B2), n3.__H.__h = [];
      } catch (t4) {
        n3.__H.__h = [], c2.__e(t4, n3.__v);
      }
}
c2.__b = function(n3) {
  r2 = null, e2 && e2(n3);
}, c2.__ = function(n3, t4) {
  n3 && t4.__k && t4.__k.__m && (n3.__m = t4.__k.__m), s2 && s2(n3, t4);
}, c2.__r = function(n3) {
  a2 && a2(n3), t3 = 0;
  var i3 = (r2 = n3.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n4) {
    n4.__N && (n4.__ = n4.__N), n4.u = n4.__N = undefined;
  })) : (i3.__h.forEach(z2), i3.__h.forEach(B2), i3.__h = [], t3 = 0)), u2 = r2;
}, c2.diffed = function(n3) {
  v2 && v2(n3);
  var t4 = n3.__c;
  t4 && t4.__H && (t4.__H.__h.length && (f2.push(t4) !== 1 && i2 === c2.requestAnimationFrame || ((i2 = c2.requestAnimationFrame) || w2)(j2)), t4.__H.__.forEach(function(n4) {
    n4.u && (n4.__H = n4.u), n4.u = undefined;
  })), u2 = r2 = null;
}, c2.__c = function(n3, t4) {
  t4.some(function(n4) {
    try {
      n4.__h.forEach(z2), n4.__h = n4.__h.filter(function(n5) {
        return !n5.__ || B2(n5);
      });
    } catch (r3) {
      t4.some(function(n5) {
        n5.__h && (n5.__h = []);
      }), t4 = [], c2.__e(r3, n4.__v);
    }
  }), l2 && l2(n3, t4);
}, c2.unmount = function(n3) {
  m3 && m3(n3);
  var t4, r3 = n3.__c;
  r3 && r3.__H && (r3.__H.__.forEach(function(n4) {
    try {
      z2(n4);
    } catch (n5) {
      t4 = n5;
    }
  }), r3.__H = undefined, t4 && c2.__e(t4, r3.__v));
};
var k2 = typeof requestAnimationFrame == "function";
function w2(n3) {
  var t4, r3 = function() {
    clearTimeout(u3), k2 && cancelAnimationFrame(t4), setTimeout(n3);
  }, u3 = setTimeout(r3, 35);
  k2 && (t4 = requestAnimationFrame(r3));
}
function z2(n3) {
  var t4 = r2, u3 = n3.__c;
  typeof u3 == "function" && (n3.__c = undefined, u3()), r2 = t4;
}
function B2(n3) {
  var t4 = r2;
  n3.__c = n3.__(), r2 = t4;
}
function C2(n3, t4) {
  return !n3 || n3.length !== t4.length || t4.some(function(t5, r3) {
    return t5 !== n3[r3];
  });
}
function D2(n3, t4) {
  return typeof t4 == "function" ? t4(n3) : t4;
}

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader;
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder;
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i3 = 0;i3 < chars.length; i3++) {
  lookup[chars.charCodeAt(i3)] = i3;
}
var decode = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i3, p3 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i3 = 0;i3 < len; i3 += 4) {
    encoded1 = lookup[base64.charCodeAt(i3)];
    encoded2 = lookup[base64.charCodeAt(i3 + 1)];
    encoded3 = lookup[base64.charCodeAt(i3 + 2)];
    encoded4 = lookup[base64.charCodeAt(i3 + 3)];
    bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i3) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i3] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i3 = 0;i3 < encodedPackets.length; i3++) {
    const decodedPacket = decodePacket(encodedPackets[i3], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j3 = 0;
  for (let i3 = 0;i3 < size; i3++) {
    buffer[i3] = chunks[0][j3++];
    if (j3 === chunks[0].length) {
      chunks.shift();
      j3 = 0;
    }
  }
  if (chunks.length && j3 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j3);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder;
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n3 = view.getUint32(0);
          if (n3 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n3 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (arguments.length == 0) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (arguments.length == 1) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i3 = 0;i3 < callbacks.length; i3++) {
    cb = callbacks[i3];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i3, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i3 = 1;i3 < arguments.length; i3++) {
    args[i3 - 1] = arguments[i3];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i3 = 0, len = callbacks.length;i3 < len; ++i3) {
      callbacks[i3].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globals.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
var defaultBinaryType = "arraybuffer";
function createCookieJar() {}

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k3) => {
    if (obj.hasOwnProperty(k3)) {
      acc[k3] = obj[k3];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c3 = 0, length = 0;
  for (let i3 = 0, l3 = str.length;i3 < l3; i3++) {
    c3 = str.charCodeAt(i3);
    if (c3 < 128) {
      length += 1;
    } else if (c3 < 2048) {
      length += 2;
    } else if (c3 < 55296 || c3 >= 57344) {
      length += 3;
    } else {
      i3++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i3 in obj) {
    if (obj.hasOwnProperty(i3)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i3) + "=" + encodeURIComponent(obj[i3]);
    }
  }
  return str;
}
function decode2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i3 = 0, l3 = pairs.length;i3 < l3; i3++) {
    let pair = pairs[i3].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}

class Transport extends Emitter {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {}
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  pause(onPause) {}
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}

// node_modules/engine.io-client/build/esm/transports/polling.js
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this._poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  onData(data) {
    const callback = (packet) => {
      if (this.readyState === "opening" && packet.type === "open") {
        this.onOpen();
      }
      if (packet.type === "close") {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if (this.readyState !== "closed") {
      this._polling = false;
      this.emitReserved("pollComplete");
      if (this.readyState === "open") {
        this._poll();
      } else {}
    }
  }
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if (this.readyState === "open") {
      close();
    } else {
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (this.opts.timestampRequests !== false) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest;
} catch (err) {}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty() {}

class BaseXHR extends Polling {
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = location.protocol === "https:";
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}

class Request extends Emitter {
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = opts.data !== undefined ? opts.data : null;
    this._create();
  }
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i3 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i3)) {
              xhr.setRequestHeader(i3, this._opts.extraHeaders[i3]);
            }
          }
        }
      } catch (e3) {}
      if (this._method === "POST") {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e3) {}
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e3) {}
      (_a = this._opts.cookieJar) === null || _a === undefined || _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === undefined || _a2.parseCookies(xhr.getResponseHeader("set-cookie"));
        }
        if (xhr.readyState !== 4)
          return;
        if (xhr.status === 200 || xhr.status === 1223) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e3) {
      this.setTimeoutFn(() => {
        this._onError(e3);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  _cleanup(fromError) {
    if (typeof this._xhr === "undefined" || this._xhr === null) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e3) {}
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i3 in Request.requests) {
    if (Request.requests.hasOwnProperty(i3)) {
      Request.requests[i3].abort();
    }
  }
}
var hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();

class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if (typeof XMLHttpRequest !== "undefined" && (!xdomain || hasCORS)) {
      return new XMLHttpRequest;
    }
  } catch (e3) {}
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e3) {}
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";

class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e3) => this.onError("websocket error", e3);
  }
  write(packets) {
    this.writable = false;
    for (let i3 = 0;i3 < packets.length; i3++) {
      const packet = packets[i3];
      const lastPacket = i3 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e3) {}
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {};
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;

class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}

// node_modules/engine.io-client/build/esm/transports/webtransport.js
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {});
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i3 = 0;i3 < packets.length; i3++) {
      const packet = packets[i3];
      const lastPacket = i3 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === undefined || _a.close();
  }
}

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8000) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e3 = str.indexOf("]");
  if (b != -1 && e3 != -1) {
    str = str.substring(0, b) + str.substring(b, e3).replace(/:/g, ";") + str.substring(e3, str.length);
  }
  let m4 = re.exec(str || ""), uri = {}, i3 = 14;
  while (i3--) {
    uri[parts[i3]] = m4[i3] || "";
  }
  if (b != -1 && e3 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}

class SocketWithoutUpgrade extends Emitter {
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t4) => {
      const transportName = t4.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t4;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode2(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = this.transport.name === "websocket";
    this.emitReserved("open");
    this.flush();
  }
  _onPacket(packet) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {}
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if (this.readyState === "closed")
      return;
    this._resetPingTimeout();
  }
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (this.writeBuffer.length === 0) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i3 = 0;i3 < this.writeBuffer.length; i3++) {
      const data = this.writeBuffer[i3].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i3 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i3);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  _sendPacket(type, data, options, fn) {
    if (typeof data === "function") {
      fn = data;
      data = undefined;
    }
    if (typeof options === "function") {
      fn = options;
      options = null;
    }
    if (this.readyState === "closing" || this.readyState === "closed") {
      return;
    }
    options = options || {};
    options.compress = options.compress !== false;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if (this.readyState === "opening" || this.readyState === "open") {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  _onClose(reason, description) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i3 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i3 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i3, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol;

class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if (this.readyState === "open" && this.opts.upgrade) {
      for (let i3 = 0;i3 < this._upgrades.length; i3++) {
        this._probe(this._upgrades[i3]);
      }
    }
  }
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if (msg.type === "pong" && msg.data === "probe") {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = transport.name === "websocket";
          this.transport.pause(() => {
            if (failed)
              return;
            if (this.readyState === "closed")
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i3 = 0;i3 < upgrades.length; i3++) {
      if (~this.transports.indexOf(upgrades[i3]))
        filteredUpgrades.push(upgrades[i3]);
    }
    return filteredUpgrades;
  }
}

class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o3 = typeof uri === "object" ? uri : opts;
    if (!o3.transports || o3.transports && typeof o3.transports[0] === "string") {
      o3.transports = (o3.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t4) => !!t4);
    }
    super(uri, o3);
  }
}
// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (uri == null)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if (uri.charAt(0) === "/") {
      if (uri.charAt(1) === "/") {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if (typeof loc !== "undefined") {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  protocol: () => protocol3,
  PacketType: () => PacketType,
  Encoder: () => Encoder,
  Decoder: () => Decoder
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i3 = 0, l3 = obj.length;i3 < l3; i3++) {
      if (hasBinary(obj[i3])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i3 = 0;i3 < data.length; i3++) {
      newData[i3] = _deconstructPacket(data[i3], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i3 = 0;i3 < data.length; i3++) {
      data[i3] = _reconstructPacket(data[i3], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));

class Encoder {
  constructor(replacer) {
    this.replacer = replacer;
  }
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && obj.nsp !== "/") {
      str += obj.nsp + ",";
    }
    if (obj.id != null) {
      str += obj.id;
    }
    if (obj.data != null) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}

class Decoder extends Emitter {
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str) {
    let i3 = 0;
    const p3 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p3.type] === undefined) {
      throw new Error("unknown packet type " + p3.type);
    }
    if (p3.type === PacketType.BINARY_EVENT || p3.type === PacketType.BINARY_ACK) {
      const start = i3 + 1;
      while (str.charAt(++i3) !== "-" && i3 != str.length) {}
      const buf = str.substring(start, i3);
      if (buf != Number(buf) || str.charAt(i3) !== "-") {
        throw new Error("Illegal attachments");
      }
      p3.attachments = Number(buf);
    }
    if (str.charAt(i3 + 1) === "/") {
      const start = i3 + 1;
      while (++i3) {
        const c3 = str.charAt(i3);
        if (c3 === ",")
          break;
        if (i3 === str.length)
          break;
      }
      p3.nsp = str.substring(start, i3);
    } else {
      p3.nsp = "/";
    }
    const next = str.charAt(i3 + 1);
    if (next !== "" && Number(next) == next) {
      const start = i3 + 1;
      while (++i3) {
        const c3 = str.charAt(i3);
        if (c3 == null || Number(c3) != c3) {
          --i3;
          break;
        }
        if (i3 === str.length)
          break;
      }
      p3.id = Number(str.substring(start, i3 + 1));
    }
    if (str.charAt(++i3)) {
      const payload = this.tryParse(str.substr(i3));
      if (Decoder.isPayloadValid(p3.type, payload)) {
        p3.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p3;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e3) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === undefined;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}

class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});

class Socket2 extends Emitter {
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if (this.io._readyState === "open")
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if (typeof args[args.length - 1] === "function") {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === undefined ? undefined : _a.transport) === null || _b === undefined ? undefined : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === undefined ? undefined : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {} else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== undefined ? _a : this._opts.ackTimeout;
    if (timeout === undefined) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i3 = 0;i3 < this.sendBuffer.length; i3++) {
        if (this.sendBuffer[i3].id === id) {
          this.sendBuffer.splice(i3, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    if (packet.id != null) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = undefined;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i3 = 0;i3 < listeners.length; i3++) {
        if (listener === listeners[i3]) {
          listeners.splice(i3, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i3 = 0;i3 < listeners.length; i3++) {
        if (listener === listeners[i3]) {
          listeners.splice(i3, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1000);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== undefined ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(opts.timeout == null ? 20000 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || exports_esm;
    this.encoder = new _parser.Encoder;
    this.decoder = new _parser.Decoder;
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v3) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v3;
    if (!v3) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v3) {
    if (v3 === undefined)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v3;
    return this;
  }
  reconnectionDelay(v3) {
    var _a;
    if (v3 === undefined)
      return this._reconnectionDelay;
    this._reconnectionDelay = v3;
    (_a = this.backoff) === null || _a === undefined || _a.setMin(v3);
    return this;
  }
  randomizationFactor(v3) {
    var _a;
    if (v3 === undefined)
      return this._randomizationFactor;
    this._randomizationFactor = v3;
    (_a = this.backoff) === null || _a === undefined || _a.setJitter(v3);
    return this;
  }
  reconnectionDelayMax(v3) {
    var _a;
    if (v3 === undefined)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v3;
    (_a = this.backoff) === null || _a === undefined || _a.setMax(v3);
    return this;
  }
  timeout(v3) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v3;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (this._timeout !== false) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn) {
    return this.open(fn);
  }
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e3) {
      this.onclose("parse error", e3);
    }
  }
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  onerror(err) {
    this.emitReserved("error", err);
  }
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i3 = 0;i3 < encodedPackets.length; i3++) {
      this.engine.write(encodedPackets[i3], packet.options);
    }
  }
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  disconnect() {
    return this._close();
  }
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === undefined || _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// src/preact/socket.ts
function createSocketBridge(handlers = {}) {
  const basePath = window.location.pathname.endsWith("/") ? window.location.pathname : `${window.location.pathname}/`;
  const path = `${basePath}socket.io`;
  const secure = window.location.protocol === "https:";
  const socket = lookup2({ path, secure });
  socket.on("ui-controls", (data) => {
    handlers.onControls?.(data);
    socket.emit("ui-replay-state");
  });
  socket.on("ui-control", (data) => {
    handlers.onControl?.(data);
  });
  socket.on("show-toast", (data) => {
    handlers.onToast?.(data);
  });
  socket.on("ui-audio", (data) => {
    handlers.onAudio?.(data);
  });
  socket.on("ui-replay-done", () => {
    handlers.onReplayDone?.();
  });
  socket.on("connect", () => {
    handlers.onConnect?.(socket.id);
  });
  const emit = (event, msg = {}) => {
    const payload = { ...msg, socketid: socket.id };
    socket.emit(event, payload);
  };
  const dispose = () => {
    socket.removeAllListeners();
    socket.close();
  };
  return { socket, emit, dispose };
}

// src/preact/lib/tts.ts
function speakText(text, voiceUri, volume) {
  if (typeof window === "undefined" || !("speechSynthesis" in window))
    return;
  const utterance = new SpeechSynthesisUtterance(text);
  if (typeof voiceUri === "string" && window.speechSynthesis) {
    const voices = window.speechSynthesis.getVoices();
    const found = voices.find((v3) => v3.voiceURI === voiceUri);
    if (found)
      utterance.voice = found;
  }
  if (typeof volume === "number" && Number.isFinite(volume)) {
    const clamped = Math.max(0, Math.min(1, volume));
    utterance.volume = clamped;
  }
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(utterance);
}

// src/preact/state.ts
var tabHiddenKey = (idx, name) => `th${idx}${name}`;
var tabDisabledKey = (idx, name) => `td${idx}${name}`;
var groupHiddenKey = (key) => `g${key}`;
var groupCollapsedKey = (key) => `gc${key}`;
function persistTabVisibility(idx, name, hidden, disabled) {
  if (typeof window === "undefined" || !name)
    return;
  if (hidden === true) {
    window.localStorage.setItem(tabHiddenKey(idx, name), "true");
  } else if (hidden === false) {
    window.localStorage.setItem(tabHiddenKey(idx, name), "false");
  }
  if (disabled === true) {
    window.localStorage.setItem(tabDisabledKey(idx, name), "true");
  } else if (disabled === false) {
    window.localStorage.setItem(tabDisabledKey(idx, name), "false");
  }
}
function persistGroupVisibility(key, hidden) {
  if (typeof window === "undefined" || !key)
    return;
  if (hidden === true) {
    window.localStorage.setItem(groupHiddenKey(key), "true");
  } else if (hidden === false) {
    window.localStorage.removeItem(groupHiddenKey(key));
  }
}
function persistGroupCollapse(key, collapsed) {
  if (typeof window === "undefined" || !key)
    return;
  if (collapsed === true) {
    window.localStorage.setItem(groupCollapsedKey(key), "true");
  } else if (collapsed === false) {
    window.localStorage.removeItem(groupCollapsedKey(key));
  }
}
var initialState = {
  connection: "connecting",
  socketId: "",
  menu: [],
  globals: [],
  site: null,
  theme: null,
  locales: null,
  lang: null,
  selectedTabIndex: null,
  replayDone: false,
  toasts: []
};
function useDashboardState() {
  const [state, setState] = d2(initialState);
  const [bridge, setBridge] = d2(null);
  y2(() => {
    const b = createSocketBridge({
      onConnect: (id) => {
        setState((prev) => ({ ...prev, connection: "ready", socketId: id }));
      },
      onControls: (payload) => {
        const data = payload || {};
        const menu = data.menu ?? [];
        const globals = data.globals ?? [];
        const site = data.site ?? null;
        const theme = data.theme ?? null;
        const locales = data.locales ?? null;
        const lang = data.lang ?? null;
        const defaultTab = getFirstVisibleTab(menu);
        setState((prev) => ({
          ...prev,
          connection: "ready",
          menu,
          globals,
          site,
          theme,
          locales,
          lang,
          selectedTabIndex: defaultTab
        }));
      },
      onReplayDone: () => {
        setState((prev) => ({ ...prev, replayDone: true, connection: "ready" }));
      },
      onControl: (payload) => {
        setState((prev) => handleUiControl(prev, payload));
      },
      onToast: (payload) => {
        setState((prev) => pushToast(prev, payload));
      },
      onAudio: (payload) => {
        handleAudioEvent(payload);
      }
    });
    setBridge(b);
    return () => b.dispose();
  }, []);
  const selectedTab = T2(() => {
    if (state.selectedTabIndex == null)
      return null;
    return state.menu[state.selectedTabIndex] ?? null;
  }, [state.menu, state.selectedTabIndex]);
  const selectTab = (index) => {
    setState((prev) => ({ ...prev, selectedTabIndex: index }));
    bridge?.emit("ui-change", { tab: index });
  };
  y2(() => {
    const timers = [];
    state.toasts.forEach((toast) => {
      if (toast.displayTime && toast.displayTime > 0) {
        const timer = window.setTimeout(() => {
          setState((prev) => ({ ...prev, toasts: prev.toasts.filter((t4) => t4.id !== toast.id) }));
        }, toast.displayTime);
        timers.push(timer);
      }
    });
    return () => {
      timers.forEach((t4) => window.clearTimeout(t4));
    };
  }, [state.toasts]);
  return {
    state,
    selectedTab,
    actions: {
      selectTab,
      emit: bridge?.emit ?? null,
      dismissToast: (id) => setState((prev) => ({ ...prev, toasts: prev.toasts.filter((t4) => t4.id !== id) }))
    }
  };
}
function getFirstVisibleTab(menu) {
  for (let i3 = 0;i3 < menu.length; i3 += 1) {
    const tab = menu[i3];
    if (tab && !tab.hidden && !tab.disabled) {
      return i3;
    }
  }
  return menu.length > 0 ? 0 : null;
}
function updateControlById(menu, id, controlPatch) {
  if (id == null)
    return menu;
  return menu.map((tab) => {
    const items = (tab.items ?? []).map((group) => {
      const controls = (group.items ?? []).map((ctrl) => {
        if (ctrl.id === id) {
          return { ...ctrl, ...controlPatch };
        }
        return ctrl;
      });
      return { ...group, items: controls };
    });
    return { ...tab, items };
  });
}
function applyTabVisibility(menu, tabsMsg) {
  return menu.map((tab, idx) => {
    const name = (tab.header || tab.name || "").toString();
    const show = Array.isArray(tabsMsg.show) ? tabsMsg.show : [];
    const hide = Array.isArray(tabsMsg.hide) ? tabsMsg.hide : [];
    const enable = Array.isArray(tabsMsg.enable) ? tabsMsg.enable : [];
    const disable = Array.isArray(tabsMsg.disable) ? tabsMsg.disable : [];
    const next = { ...tab };
    const willShow = show.includes(name);
    const willHide = hide.includes(name);
    const willEnable = enable.includes(name);
    const willDisable = disable.includes(name);
    if (willShow)
      next.hidden = false;
    if (willHide)
      next.hidden = true;
    if (willEnable)
      next.disabled = false;
    if (willDisable)
      next.disabled = true;
    persistTabVisibility(idx, name, willShow ? false : willHide ? true : undefined, willEnable ? false : willDisable ? true : undefined);
    return next;
  });
}
function applyGroupVisibility(menu, groupMsg) {
  const show = Array.isArray(groupMsg.show) ? groupMsg.show : [];
  const hide = Array.isArray(groupMsg.hide) ? groupMsg.hide : [];
  const collapse = Array.isArray(groupMsg.collapse) ? groupMsg.collapse : [];
  const expand = Array.isArray(groupMsg.expand) ? groupMsg.expand : [];
  return menu.map((tab) => {
    const items = (tab.items ?? []).map((group) => {
      const key = `${tab.header ?? tab.name ?? ""} ${group.header?.name ?? ""}`.replace(/ /g, "_");
      const nextHeader = { ...group.header ?? {}, config: { ...group.header?.config ?? {} } };
      const willShow = show.includes(key);
      const willHide = hide.includes(key);
      const willCollapse = collapse.includes(key);
      const willExpand = expand.includes(key);
      if (willShow) {
        nextHeader.config.hidden = false;
      }
      if (willHide) {
        nextHeader.config.hidden = true;
      }
      if (willCollapse) {
        nextHeader.config.collapsed = true;
      }
      if (willExpand) {
        nextHeader.config.collapsed = false;
      }
      persistGroupVisibility(key, willHide ? true : willShow ? false : undefined);
      persistGroupCollapse(key, willCollapse ? true : willExpand ? false : undefined);
      return { ...group, header: nextHeader };
    });
    return { ...tab, items };
  });
}
function pushToast(prev, payload) {
  const msg = payload;
  const id = msg.id?.toString() || `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  const toast = {
    id,
    title: msg.title,
    message: msg.message,
    level: msg.level === "error" || msg.level === "warn" ? msg.level : undefined,
    displayTime: typeof msg.displayTime === "number" ? msg.displayTime : 3000,
    className: msg.className
  };
  const nextToasts = [...prev.toasts.filter((t4) => t4.id !== id), toast];
  return { ...prev, toasts: nextToasts };
}
function handleUiControl(prev, payload) {
  const msg = payload || {};
  let menu = prev.menu;
  let selectedTabIndex = prev.selectedTabIndex;
  const controlId = msg.id;
  if (msg.control && controlId !== undefined) {
    menu = updateControlById(menu, controlId, msg.control);
  }
  if (msg.options && controlId !== undefined) {
    const nextValue = msg.value ?? msg.payload;
    const resetSelection = Boolean(msg.resetSearch || msg.resetSelection);
    menu = updateControlById(menu, controlId, {
      options: msg.options,
      value: nextValue,
      resetSelection
    });
  }
  if (msg.tabs) {
    menu = applyTabVisibility(menu, msg.tabs);
    selectedTabIndex = getFirstVisibleTab(menu);
  }
  if (msg.tab !== undefined) {
    const requested = msg.tab;
    if (typeof requested === "string") {
      if (requested === "") {} else if (requested === "+1" || requested === "-1") {
        const delta = requested === "+1" ? 1 : -1;
        const next = (selectedTabIndex ?? 0) + delta;
        if (next >= 0 && next < menu.length && !menu[next].disabled)
          selectedTabIndex = next;
      } else {
        const idx = menu.findIndex((t4) => t4.header === requested || t4.name === requested);
        if (idx >= 0 && !menu[idx].disabled)
          selectedTabIndex = idx;
      }
    } else if (typeof requested === "number") {
      if (requested >= 0 && requested < menu.length && !menu[requested].disabled)
        selectedTabIndex = requested;
    }
  }
  if (msg.group) {
    menu = applyGroupVisibility(menu, msg.group);
  }
  return { ...prev, menu: [...menu], selectedTabIndex };
}
function handleAudioEvent(payload) {
  const msg = payload || {};
  if (msg.reset || msg.stop) {
    if (typeof window !== "undefined" && "speechSynthesis" in window) {
      window.speechSynthesis.cancel();
    }
    return;
  }
  if (msg.tts) {
    speakText(msg.tts, msg.voice, typeof msg.vol === "number" ? msg.vol / 100 : undefined);
    return;
  }
  if (msg.audio && typeof window !== "undefined") {
    const buffer = msg.audio instanceof Uint8Array ? msg.audio : new Uint8Array(msg.audio);
    const blob = new Blob([buffer], { type: "audio/mpeg" });
    const url2 = URL.createObjectURL(blob);
    const audio = new Audio(url2);
    audio.volume = typeof msg.vol === "number" ? Math.max(0, Math.min(1, msg.vol / 100)) : 1;
    audio.play().finally(() => URL.revokeObjectURL(url2));
  }
}

// src/preact/components/layout/layout-styles.ts
var LAYOUT_STYLE_ID = "nr-dashboard-layout-style";
var DASHBOARD_SCOPE = "#nr-dashboard-root";
function ensureLayoutStyles(doc = typeof document !== "undefined" ? document : undefined) {
  if (!doc)
    return;
  if (doc.getElementById(LAYOUT_STYLE_ID))
    return;
  const style = doc.createElement("style");
  style.id = LAYOUT_STYLE_ID;
  style.textContent = `
    ${DASHBOARD_SCOPE} {
      --nr-dashboard-card-bg: var(--nr-dashboard-groupBackgroundColor, transparent);
      --nr-dashboard-card-border: var(--nr-dashboard-groupBorderColor, transparent);
      --nr-dashboard-card-text: var(--nr-dashboard-groupTextColor, var(--nr-dashboard-widgetTextColor, inherit));
      --nr-dashboard-nav-active: var(--nr-dashboard-pageSidebarBackgroundColor, rgba(0, 0, 0, 0.04));
      --nr-dashboard-nav-border-active: var(--nr-dashboard-widgetBorderColor, rgba(0, 0, 0, 0.24));
      --nr-dashboard-nav-border: var(--nr-dashboard-widgetBorderColor, rgba(0, 0, 0, 0.12));
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs {
      list-style: none;
      padding: 4px 4px;
      margin: 0;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs li:last-child .nr-dashboard-tabs__btn {
      margin-bottom: 0;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      margin-bottom: 4px;
      border-radius: 4px;
      border: 1px solid var(--nr-dashboard-nav-border);
      background: rgba(0, 0, 0, 0.02);
      color: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 48px;
      justify-content: flex-start;
      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
      font-family: inherit;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn.is-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__icon {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      background: rgba(0, 0, 0, 0.06);
      border: 1px solid var(--nr-dashboard-nav-border);
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__icon i {
      font-size: 18px;
      line-height: 1;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__icon img {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__icon-glyph {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      width: 100%;
      height: 100%;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs--icon .nr-dashboard-tabs__label {
      display: none;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn.is-active {
      border-color: var(--nr-dashboard-nav-border-active);
      background: var(--nr-dashboard-nav-active);
      border-right: 4px solid var(--nr-dashboard-groupTextColor, var(--nr-dashboard-nav-border-active));
      box-shadow: inset -1px 0 0 rgba(0, 0, 0, 0.06);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      filter: grayscale(0.2);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn:not(:disabled):hover {
      background: rgba(0, 0, 0, 0.06);
      border-color: var(--nr-dashboard-nav-border-active);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__btn:focus-visible {
      outline: 2px solid var(--nr-dashboard-nav-border-active);
      outline-offset: 1px;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-tabs__label {
      min-width: 120px;
      display: inline-flex;
      align-items: center;
      line-height: 20px;
      letter-spacing: 0.02em;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card {
      border: 1px solid var(--nr-dashboard-card-border);
      border-radius: 10px;
      background: var(--nr-dashboard-card-bg);
      color: var(--nr-dashboard-card-text);
      min-height: 120px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
      padding: 8px;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__header {
      font-weight: 500;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__collapse {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 6px;
      min-width: 28px;
      min-height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 120ms ease;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__collapse:hover {
      background: rgba(0, 0, 0, 0.06);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__collapse:focus-visible {
      outline: 2px solid var(--nr-dashboard-widgetColor, #1f8af2);
      outline-offset: 2px;
      background: rgba(0, 0, 0, 0.06);
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-group-card__item {
      font-size: 12px;
      opacity: 0.9;
    }

    ${DASHBOARD_SCOPE} .nr-dashboard-widget-frame {
      background: var(--nr-dashboard-widgetBackgroundColor, transparent);
      border: 1px solid var(--nr-dashboard-widgetBorderColor, transparent);
      color: var(--nr-dashboard-widgetTextColor, inherit);
      border-radius: 8px;
    }

    .nr-dashboard-icon-press {
      position: relative;
      overflow: hidden;
      transition: transform 140ms ease, background 160ms ease;
    }

    .nr-dashboard-icon-press::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,0,0,0.14) 0%, rgba(0,0,0,0) 60%);
      opacity: 0;
      transform: scale(0.4);
      transition: opacity 220ms ease, transform 220ms ease;
    }

    .nr-dashboard-icon-press:active {
      transform: scale(0.96);
      background: rgba(255, 255, 255, 0.08);
    }

    .nr-dashboard-icon-press:active::after {
      opacity: 1;
      transform: scale(1.6);
      transition: opacity 120ms ease, transform 220ms ease;
    }

    .nr-dashboard-wheel-spin {
      animation: nr-dashboard-wheel 1.05s linear infinite;
    }

    .nr-dashboard-fade-in {
      animation: nr-dashboard-fade 1.2s ease-in;
    }

    @keyframes nr-dashboard-nav-backdrop {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes nr-dashboard-skeleton {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    @keyframes nr-dashboard-wheel {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes nr-dashboard-fade {
      0% { opacity: 0; }
      30% { opacity: 0; }
      100% { opacity: 1; }
    }
  `;
  doc.head.appendChild(style);
}

// src/preact/lib/i18n.ts
var defaultMessages = {
  required_label: "Required",
  error_required: "This field is required.",
  error_pattern: "Value does not match the required format.",
  error_min: "Value is before the allowed range.",
  error_max: "Value is after the allowed range.",
  collapsed: "Collapsed",
  no_widgets: "No widgets in this group yet.",
  char_counter: "{used}/{max}",
  expand_group: "Expand group",
  collapse_group: "Collapse group",
  no_groups: "No groups in this tab yet.",
  no_tabs: "No tabs yet",
  form_no_fields: "No fields configured.",
  submit_label: "Submit",
  loading: "Loading dashboard...",
  app_title: "Node-RED Dashboard v2",
  tabs_label: "Tabs",
  no_tabs_defined_title: "No tabs defined yet.",
  no_tabs_defined_body: "Add UI nodes in Node-RED and deploy to see them here.",
  select_tab_prompt: "Select a tab to view its content.",
  widget_count_one: "{count} widget",
  widget_count_other: "{count} widgets",
  tab_label: "Tab {index}",
  input_label: "Input {index}",
  date_label: "Date {index}",
  form_label: "Form {index}",
  toast_label: "Toast {index}",
  toast_message: "Toast message",
  toast_close: "Close notification",
  toast_overlay_title: "Notification",
  toast_overlay_close: "Dismiss notification",
  socket_status: "Socket: {status}",
  socket_status_with_id: "Socket: {status} ({id})",
  status_connected: "Connected",
  status_connecting: "Connecting",
  status_disconnected: "Disconnected",
  widget_preview_empty: "(no value yet)",
  text_label: "Text {index}",
  dimensions_px: "{width}{height} px",
  link_open: "Open {label}",
  audio_controls: "Audio controls for {label}",
  number_value_label: "{label}: {value}",
  gauge_label: "Gauge {index}",
  group_label: "Group {index}",
  slider_value_label: "{label}: {value}",
  date_value_label: "{label}: {value}",
  gauge_value_label: "{label}: {value} {units}"
};
function interpolate(template, params) {
  if (!params)
    return template;
  return Object.entries(params).reduce((acc, [key, val]) => acc.replaceAll(`{${key}}`, String(val)), template);
}
function normalizeLang(lang) {
  if (!lang)
    return "en";
  return lang.replace("_", "-").toLowerCase();
}
function resolveMessages(locales, lang) {
  if (!locales)
    return defaultMessages;
  const normalized = normalizeLang(lang);
  const exact = locales[normalized];
  if (exact)
    return { ...defaultMessages, ...exact };
  const prefix = normalized.split("-")[0];
  const base = locales[prefix];
  if (base)
    return { ...defaultMessages, ...base };
  return defaultMessages;
}
var I18nContext = Q({
  t: (key, fallback, params) => interpolate(fallback ?? key, params),
  lang: "en"
});
function I18nProvider(props) {
  const { lang, locales, children } = props;
  const resolvedLang = normalizeLang(lang ?? "en");
  const messages = T2(() => resolveMessages(locales, resolvedLang), [locales, resolvedLang]);
  const t4 = (key, fallback, params) => {
    const template = messages[key] ?? fallback ?? key;
    return interpolate(template, params);
  };
  return m2`<${I18nContext.Provider} value=${{ t: t4, lang: resolvedLang }}>${children}</${I18nContext.Provider}>`;
}
function useI18n() {
  return x2(I18nContext);
}
function hydrateLocales() {
  if (typeof window === "undefined")
    return;
  const maybe = window.__nrDashboardLocales;
  if (maybe && typeof maybe === "object") {
    return maybe;
  }
  return;
}

// src/preact/components/layout/TabNav.ts
function TabNav(props) {
  const { menu, selectedIndex, onSelect, variant = "full" } = props;
  ensureLayoutStyles();
  const { t: t4 } = useI18n();
  const iconOnly = variant === "icon";
  const visibleMenu = menu.map((tab, originalIndex) => ({ tab, originalIndex })).filter(({ tab }) => !tab.hidden);
  const renderLetterFallback = (tab, idx) => {
    const raw = tab.header || tab.name || t4("tab_label", "Tab {index}", { index: idx + 1 });
    const trimmed = raw.trim();
    if (trimmed.length === 0)
      return "?";
    return trimmed[0].toUpperCase();
  };
  const renderIcon = (tab, idx) => {
    const icon = (tab.icon ?? "").trim();
    const letter = renderLetterFallback(tab, idx);
    if (icon.length === 0) {
      return m2`<span class="nr-dashboard-tabs__icon">${letter}</span>`;
    }
    const isUrl = /^https?:\/\//i.test(icon);
    if (isUrl) {
      return m2`<span class="nr-dashboard-tabs__icon"><img src=${icon} alt="" /></span>`;
    }
    if (icon.startsWith("mi-")) {
      const glyph = icon.slice(3);
      return m2`<span class="nr-dashboard-tabs__icon"><span class=${`material-icons ${icon}`} aria-hidden="true">${glyph}</span></span>`;
    }
    if (icon.startsWith("fa-")) {
      return m2`<span class="nr-dashboard-tabs__icon"><i class=${`fa fa-fw ${icon}`} aria-hidden="true"></i></span>`;
    }
    if (icon.startsWith("wi-")) {
      return m2`<span class="nr-dashboard-tabs__icon"><i class=${`wi wi-fw ${icon}`} aria-hidden="true"></i></span>`;
    }
    if (icon.startsWith("icofont-")) {
      return m2`<span class="nr-dashboard-tabs__icon"><i class=${`icofont icofont-fw ${icon}`} aria-hidden="true"></i></span>`;
    }
    if (icon.startsWith("iconify-")) {
      const [, size] = icon.split(" ");
      const iconName = icon.split(" ")[0].slice(8);
      return m2`<span class="nr-dashboard-tabs__icon"><i class="iconify" data-icon=${iconName} data-width=${size ?? "1.3em"} data-height=${size ?? "1.3em"} aria-hidden="true"></i></span>`;
    }
    return m2`<span class="nr-dashboard-tabs__icon">${letter}</span>`;
  };
  return m2`<ul class=${`nr-dashboard-tabs ${iconOnly ? "nr-dashboard-tabs--icon" : ""}`.trim()}>
    ${visibleMenu.length === 0 ? m2`<li style=${{ opacity: 0.6 }}>${t4("no_tabs", "No tabs yet")}</li>` : visibleMenu.map(({ tab, originalIndex }, idx) => {
    const active = originalIndex === selectedIndex;
    const label = tab.header || tab.name || t4("tab_label", "Tab {index}", { index: idx + 1 });
    const icon = tab.icon ? renderIcon(tab, idx) : null;
    return m2`<li key=${tab.id ?? tab.header ?? originalIndex}>
            <button
              class=${`nr-dashboard-tabs__btn ${iconOnly ? "is-icon" : ""} ${active ? "is-active" : ""}`.trim()}
              disabled=${tab.disabled}
              type="button"
              aria-label=${label}
              title=${label}
              onClick=${() => onSelect(originalIndex)}
            >
              ${icon}
              <span class="nr-dashboard-tabs__label">${label}</span>
            </button>
          </li>`;
  })}
  </ul>`;
}

// src/preact/components/layout/utils.ts
function groupColumnSpan(group, maxColumns) {
  const width = group?.header?.config?.width;
  const span = coerceNumber(width, maxColumns || 1);
  const capped = Math.max(1, Math.min(maxColumns || 1, span));
  return Number.isFinite(capped) ? capped : 1;
}
function useLayoutAnnouncements(groups, sizes, tabId) {
  y2(() => {
    if (typeof window === "undefined")
      return;
    const detail = { tabId, groupCount: groups.length, sizes };
    window.dispatchEvent(new CustomEvent("dashboard:layout", { detail }));
    window.dispatchEvent(new Event("resize"));
  }, [
    tabId,
    groups.length,
    sizes.columns,
    sizes.gx,
    sizes.gy,
    sizes.px,
    sizes.py,
    sizes.cx,
    sizes.cy,
    sizes.sx,
    sizes.sy,
    sizes.dense
  ]);
}
function coerceNumber(value2, fallback) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : fallback;
}

// src/preact/hooks/useElementSize.ts
function useElementSize() {
  const ref = A2(null);
  const [size, setSize] = d2({ width: 0, height: 0 });
  y2(() => {
    const el = ref.current;
    if (!el || typeof ResizeObserver === "undefined")
      return;
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (!entry)
        return;
      const { width, height } = entry.contentRect;
      setSize({ width, height });
    });
    observer.observe(el);
    return () => observer.disconnect();
  }, []);
  return [ref, size];
}

// src/preact/components/widgets/text.ts
function applyFormat(format, value2) {
  if (!format)
    return value2 === undefined || value2 === null ? "" : String(value2);
  return format.replace(/{{\s*payload\s*}}/g, String(value2 ?? ""));
}
function layoutStyles(ctrl) {
  const align = ctrl.layoutAlign || "space-between center";
  const [justify = "flex-start", alignItems = "center"] = align.split(" ");
  const dir = ctrl.layout === "column" || ctrl.layout === "col" || ctrl.layout === "col-center" ? "column" : "row";
  return {
    display: "flex",
    flexDirection: dir,
    justifyContent: justify,
    alignItems,
    gap: dir === "row" ? "8px" : "4px"
  };
}
function mergeStyleString(base, style) {
  if (!style)
    return base;
  const decls = style.split(";").map((s3) => s3.trim()).filter(Boolean);
  const merged = { ...base };
  decls.forEach((d3) => {
    const [k3, v3] = d3.split(":");
    if (k3 && v3) {
      merged[k3.trim()] = v3.trim();
    }
  });
  return merged;
}
function TextWidget(props) {
  const { control, index } = props;
  const asText = control;
  const { t: t4 } = useI18n();
  const label = asText.label || asText.name || t4("text_label", "Text {index}", { index: index + 1 });
  const raw = asText.value ?? asText.text ?? "";
  const formatted = applyFormat(asText.format, raw);
  const color = typeof asText.color === "string" ? asText.color : undefined;
  const fontSize = asText.fontSize ? `${asText.fontSize}px` : undefined;
  const fontFamily = asText.font;
  const fontWeight = asText.fontWeight ?? 500;
  const [ref] = useElementSize();
  const container = mergeStyleString({
    ...layoutStyles(asText),
    width: "100%",
    padding: "4px 2px"
  }, asText.style);
  return m2`<div ref=${ref} class=${asText.className || ""} style=${container}>
    <div style=${{ fontSize: "13px", opacity: 0.75, color: "var(--nr-dashboard-widgetTextColor, inherit)" }}>${label}</div>
    <div
      style=${{
    fontSize: fontSize || "16px",
    fontWeight,
    color: color || "var(--nr-dashboard-widgetTextColor, inherit)",
    lineHeight: 1.4,
    wordBreak: "break-word",
    fontFamily
  }}
    >
      ${formatted}
    </div>
  </div>`;
}

// src/preact/lib/payload.ts
function resolveTypedPayload(value2, type) {
  const t4 = (type || "str").toString();
  if (t4 === "date")
    return Date.now();
  if (t4 === "num" || t4 === "number") {
    const n3 = Number(value2);
    if (Number.isFinite(n3))
      return n3;
    if (typeof value2 === "string" && value2.trim() === "")
      return 0;
    return value2;
  }
  if (t4 === "bool" || t4 === "boolean") {
    if (value2 === "false" || value2 === 0 || value2 === "0")
      return false;
    return Boolean(value2 ?? true);
  }
  if (t4 === "json") {
    if (typeof value2 === "object" && value2 !== null)
      return value2;
    if (typeof value2 === "string") {
      try {
        return JSON.parse(value2);
      } catch {
        return value2;
      }
    }
    return value2;
  }
  if (t4 === "bin") {
    if (value2 instanceof Uint8Array)
      return value2;
    if (typeof value2 === "string") {
      try {
        return Uint8Array.from(atob(value2), (c3) => c3.charCodeAt(0));
      } catch {
        return value2;
      }
    }
    return value2;
  }
  return value2;
}

// src/preact/components/widgets/button.ts
function resolveButtonColor(ctrl) {
  if (typeof ctrl.bgcolor === "string" && ctrl.bgcolor)
    return ctrl.bgcolor;
  if (typeof ctrl.color === "string" && ctrl.color)
    return ctrl.color;
  return "#1f8af2";
}
function buildButtonEmit(ctrl, fallbackLabel) {
  const val = resolveTypedPayload(ctrl.payload ?? true, ctrl.payloadType);
  return {
    payload: val,
    topic: ctrl.topic ?? fallbackLabel,
    type: "button"
  };
}
function ButtonWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asButton = control;
  const { t: t4 } = useI18n();
  const label = asButton.label || asButton.name || t4("button_label", "Button {index}", { index: index + 1 });
  const color = resolveButtonColor(asButton) || "var(--nr-dashboard-widgetColor, #1f8af2)";
  const [hovered, setHovered] = d2(false);
  const [focused, setFocused] = d2(false);
  const [pressed, setPressed] = d2(false);
  const ripple = hovered || pressed;
  const handleClick = () => {
    const payload = buildButtonEmit(asButton, label);
    onEmit?.("ui-control", payload);
  };
  return m2`<button
    type="button"
    title=${asButton.tooltip || undefined}
    class=${asButton.className || ""}
    disabled=${Boolean(disabled)}
    onClick=${onEmit ? handleClick : undefined}
    onMouseEnter=${() => setHovered(true)}
    onMouseLeave=${() => setHovered(false)}
    onMouseDown=${() => setPressed(true)}
    onMouseUp=${() => setPressed(false)}
    onBlur=${() => {
    setFocused(false);
    setPressed(false);
  }}
    onFocus=${() => setFocused(true)}
    style=${{
    width: "100%",
    minHeight: "38px",
    padding: "10px 14px",
    borderRadius: "6px",
    border: "1px solid color-mix(in srgb, var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.24)) 70%, transparent)",
    background: color,
    color: "var(--nr-dashboard-widgetTextColor, #fff)",
    fontWeight: 700,
    cursor: onEmit ? "pointer" : "default",
    outline: "none",
    boxShadow: focused ? "0 0 0 2px color-mix(in srgb, var(--nr-dashboard-widgetColor, #1f8af2) 30%, transparent)" : hovered ? "0 2px 6px rgba(0,0,0,0.18)" : "0 1px 3px rgba(0,0,0,0.16)",
    filter: hovered ? "brightness(1.01)" : "none",
    transform: pressed ? "translateY(1px)" : "none",
    transition: "box-shadow 140ms ease, filter 140ms ease, background 140ms ease, transform 100ms ease",
    letterSpacing: "0.02em",
    position: "relative",
    overflow: "hidden"
  }}
  >
    ${asButton.icon ? m2`<span class="fa ${asButton.icon}" style=${{ marginRight: "6px" }}></span>` : null}
    ${label}
    <span
      aria-hidden="true"
      style=${{
    position: "absolute",
    inset: 0,
    background: "radial-gradient(circle at center, rgba(255,255,255,0.16), transparent 60%)",
    opacity: ripple ? 0.28 : 0,
    transition: "opacity 150ms ease",
    pointerEvents: "none"
  }}
    ></span>
  </button>`;
}

// src/preact/components/widgets/switch.ts
function resolveSwitchColors(ctrl, checked) {
  if (checked)
    return ctrl.oncolor || "#3ddc97";
  return ctrl.offcolor || "rgba(255,255,255,0.12)";
}
function buildSwitchEmit(ctrl, fallbackLabel, next) {
  return {
    payload: next ? ctrl.onvalue ?? true : ctrl.offvalue ?? false,
    topic: ctrl.topic ?? fallbackLabel,
    type: "switch"
  };
}
function matchesValue(candidate, target) {
  if (candidate === target)
    return true;
  try {
    return JSON.stringify(candidate) === JSON.stringify(target);
  } catch {
    return false;
  }
}
function SwitchWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asSwitch = control;
  const { t: t4 } = useI18n();
  const label = asSwitch.label || asSwitch.name || t4("switch_label", "Switch {index}", { index: index + 1 });
  const toChecked = (val) => {
    if (asSwitch.onvalue !== undefined || asSwitch.offvalue !== undefined) {
      if (matchesValue(val, asSwitch.onvalue))
        return true;
      if (matchesValue(val, asSwitch.offvalue))
        return false;
    }
    return Boolean(val);
  };
  const [checked, setChecked] = d2(toChecked(asSwitch.value ?? asSwitch.state));
  const [hovered, setHovered] = d2(false);
  const [focused, setFocused] = d2(false);
  y2(() => {
    setChecked(toChecked(asSwitch.value ?? asSwitch.state));
  }, [asSwitch.value, asSwitch.state, asSwitch.onvalue, asSwitch.offvalue]);
  const toggle = () => {
    if (disabled)
      return;
    const next = !checked;
    setChecked(next);
    if (!onEmit)
      return;
    if (asSwitch.passthru === false && asSwitch.decouple) {
      const payload2 = buildSwitchEmit(asSwitch, label, next);
      onEmit("ui-control", payload2);
      return;
    }
    const payload = buildSwitchEmit(asSwitch, label, next);
    onEmit("ui-control", payload);
  };
  const resolvedColor = resolveSwitchColors(asSwitch, checked);
  const bg = checked ? asSwitch.oncolor ?? `var(--nr-dashboard-widgetColor, ${resolvedColor})` : asSwitch.offcolor ?? `var(--nr-dashboard-widgetBorderColor, ${resolvedColor})`;
  const isCenter = (asSwitch.className || "").split(" ").includes("center");
  const [ripple, setRipple] = d2(false);
  return m2`<label
    class=${asSwitch.className || ""}
    style=${{
    display: "flex",
    alignItems: "center",
    gap: "12px",
    cursor: "default",
    userSelect: "none",
    opacity: disabled ? 0.55 : 1,
    paddingLeft: "14px",
    margin: isCenter ? "0 auto" : undefined
  }}
  >
    <div
      onClick=${onEmit ? toggle : undefined}
      onMouseEnter=${() => setHovered(true)}
      onMouseLeave=${() => setHovered(false)}
      onFocus=${() => setFocused(true)}
      onBlur=${() => setFocused(false)}
      onMouseDown=${() => setRipple(true)}
      onMouseUp=${() => setRipple(false)}
      onMouseOut=${() => setRipple(false)}
      onKeyDown=${(e3) => {
    if (e3.key === "Enter" || e3.key === " " || e3.key === "Spacebar") {
      e3.preventDefault();
      toggle();
    }
  }}
      tabIndex=${disabled ? -1 : 0}
      role="switch"
      aria-checked=${checked}
      style=${{
    width: "46px",
    height: "26px",
    borderRadius: "13px",
    background: bg,
    position: "relative",
    transition: "background 120ms ease, transform 120ms ease, box-shadow 120ms ease",
    boxShadow: focused ? "0 0 0 3px color-mix(in srgb, var(--nr-dashboard-widgetColor, #3ddc97) 32%, transparent)" : hovered ? "0 1px 4px var(--nr-dashboard-switch-shadow, rgba(0,0,0,0.28))" : "none",
    overflow: "hidden"
  }}
    >
      <span
        aria-hidden="true"
        style=${{
    position: "absolute",
    inset: 0,
    background: "radial-gradient(circle at center, rgba(255,255,255,0.22), transparent 55%)",
    opacity: ripple ? 0.28 : 0,
    transition: "opacity 180ms ease",
    pointerEvents: "none"
  }}
      ></span>
      <div
        style=${{
    position: "absolute",
    top: "3px",
    left: checked ? "24px" : "3px",
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "var(--nr-dashboard-widgetTextColor, #fff)",
    boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
    transition: "left 120ms ease"
  }}
      ></div>
    </div>
    <div style=${{ display: "flex", flexDirection: "column", gap: "0" }}>
      <span style=${{ fontWeight: 500, color: "var(--nr-dashboard-widgetTextColor, inherit)" }}>
        ${checked && asSwitch.onicon ? m2`<span class="fa ${asSwitch.onicon}" style=${{ marginRight: "6px" }}></span>` : null}
        ${!checked && asSwitch.officon ? m2`<span class="fa ${asSwitch.officon}" style=${{ marginRight: "6px" }}></span>` : null}
        ${label}
      </span>
    </div>
  </label>`;
}

// src/preact/components/styles/fieldStyles.ts
var fieldWrapperStyles = {
  display: "grid",
  gap: "6px",
  width: "100%"
};
var fieldLabelStyles = {
  fontSize: "13px",
  opacity: 0.85,
  color: "var(--nr-dashboard-widgetTextColor, inherit)",
  lineHeight: 1.3
};
var fieldHelperStyles = {
  fontSize: "11px",
  opacity: 0.7,
  color: "var(--nr-dashboard-widgetTextColor, inherit)"
};
function buildFieldStyles(opts = {}) {
  const { error, focused, disabled, hasAdornment, dense } = opts;
  const borderColor = error ? "var(--nr-dashboard-errorColor, #f87171)" : "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.18))";
  const focusRing = error ? "0 0 0 2px color-mix(in srgb, var(--nr-dashboard-errorColor, #f87171) 55%, transparent)" : focused ? "0 0 0 2px color-mix(in srgb, var(--nr-dashboard-widgetColor, #1f8af2) 55%, transparent)" : "none";
  return {
    width: "100%",
    padding: dense ? "8px 10px" : "10px 12px",
    borderRadius: "8px",
    border: `1px solid ${borderColor}`,
    background: "var(--nr-dashboard-widgetFieldBg, var(--nr-dashboard-widgetBackgroundColor, transparent))",
    color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)",
    outline: "none",
    boxShadow: focusRing,
    transition: "box-shadow 140ms ease, border-color 140ms ease, background 140ms ease",
    appearance: "none",
    WebkitAppearance: "none",
    opacity: disabled ? 0.55 : 1,
    cursor: disabled ? "not-allowed" : "text",
    paddingRight: hasAdornment ? "40px" : dense ? "10px" : "12px"
  };
}
var adornmentStyles = {
  position: "absolute",
  right: "10px",
  top: "50%",
  transform: "translateY(-50%)",
  pointerEvents: "none",
  color: "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.6))",
  fontSize: "12px",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center"
};

// src/preact/components/widgets/text-input.ts
function inputType(mode) {
  if (!mode)
    return "text";
  if (mode.startsWith("time"))
    return "time";
  if (mode === "date")
    return "date";
  if (mode === "datetime-local")
    return "datetime-local";
  if (mode === "password")
    return "password";
  if (mode === "email")
    return "email";
  if (mode === "number")
    return "number";
  return "text";
}
function buildTextEmit(ctrl, fallbackLabel, value2) {
  return {
    payload: value2,
    topic: ctrl.topic ?? fallbackLabel,
    type: "text-input"
  };
}
function TextInputWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asInput = control;
  const { t: t4 } = useI18n();
  const label = asInput.label || asInput.name || t4("input_label", "Input {index}", { index: index + 1 });
  const [value2, setValue] = d2(asInput.value ?? "");
  const [error, setError] = d2("");
  const [focused, setFocused] = d2(false);
  const maxLength = control.maxlength;
  const delay = Number.isFinite(asInput.delay) ? Number(asInput.delay) : 0;
  const sendOnEnter = delay <= 0 || control.type === "text-input-CR";
  const timer = A2(undefined);
  const type = T2(() => inputType(asInput.mode), [asInput.mode]);
  const pattern = asInput.pattern ? new RegExp(asInput.pattern) : null;
  const isColorMode = asInput.mode === "color";
  const validate = (next) => {
    if (asInput.required && next.trim().length === 0) {
      setError(asInput.error || t4("error_required", "This field is required."));
      return false;
    }
    if (pattern && !pattern.test(next)) {
      setError(asInput.error || t4("error_pattern", "Value does not match the required format."));
      return false;
    }
    setError("");
    return true;
  };
  y2(() => () => {
    if (timer.current !== undefined) {
      clearTimeout(timer.current);
    }
  }, []);
  const emitValue = (next) => {
    if (!onEmit)
      return;
    if (!validate(next))
      return;
    const payload = buildTextEmit(asInput, label, next);
    onEmit("ui-control", payload);
  };
  const scheduleEmit = (next) => {
    if (!onEmit)
      return;
    if (delay <= 0)
      return;
    if (timer.current !== undefined)
      clearTimeout(timer.current);
    timer.current = window.setTimeout(() => emitValue(next), delay);
  };
  const handleChange = (e3) => {
    const target = e3.target;
    const next = target.value;
    setValue(next);
    if (!sendOnEnter) {
      scheduleEmit(next);
    }
  };
  const handleKeyDown = (e3) => {
    if (sendOnEnter && e3.key === "Enter") {
      emitValue(value2);
    }
  };
  const handleBlur = () => {
    validate(value2);
    if (asInput.sendOnBlur) {
      emitValue(value2);
    }
  };
  const fieldStyles = buildFieldStyles({ error: Boolean(error), focused, disabled: Boolean(disabled), hasAdornment: isColorMode });
  const colorSwatch = isColorMode ? m2`<span
        aria-hidden="true"
        style=${{
    width: "18px",
    height: "18px",
    borderRadius: "4px",
    border: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.35))",
    background: value2 || "#cccccc",
    boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.15)"
  }}
      ></span>` : null;
  return m2`<label style=${fieldWrapperStyles}>
    <span style=${fieldLabelStyles}>${label}</span>
    ${asInput.required ? m2`<span style=${fieldHelperStyles}>${t4("required_label", "Required")}</span>` : null}
    <div style=${{ position: "relative", width: "100%" }}>
      <div
        style=${{
    ...fieldStyles,
    display: "flex",
    alignItems: "center",
    gap: "8px"
  }}
      >
        ${colorSwatch}
        <input
          class=${asInput.className || ""}
          type=${type}
          value=${value2}
          title=${asInput.tooltip || undefined}
          disabled=${Boolean(disabled)}
          aria-invalid=${error ? "true" : "false"}
          aria-errormessage=${error ? `err-${index}` : undefined}
          inputMode=${type === "number" ? "decimal" : type === "email" ? "email" : undefined}
          maxLength=${maxLength || undefined}
          onInput=${handleChange}
          onKeyDown=${handleKeyDown}
          onBlur=${() => {
    handleBlur();
    setFocused(false);
  }}
          onFocus=${() => setFocused(true)}
          style=${{
    flex: 1,
    background: "transparent",
    border: "none",
    color: "var(--nr-dashboard-widgetTextColor, inherit)",
    outline: "none",
    padding: 0,
    fontSize: "14px",
    minWidth: 0
  }}
        />
      </div>
    </div>
    ${typeof maxLength === "number" ? m2`<span style=${{ ...fieldHelperStyles, alignSelf: "flex-end" }}>
          ${t4("char_counter", "{used}/{max}", { used: value2.length, max: maxLength })}
        </span>` : null}
    ${error ? m2`<span
          id=${`err-${index}`}
          role="alert"
          style=${{ color: "var(--nr-dashboard-errorColor, #f87171)", fontSize: "12px" }}
        >${error}</span>` : null}
  </label>`;
}

// src/preact/lib/format.ts
function formatNumber(value2, lang) {
  const formatter = new Intl.NumberFormat(lang || undefined);
  return formatter.format(value2);
}
function toDate(value2, mode) {
  if (!value2)
    return;
  if (mode === "time") {
    const maybe2 = new Date(`1970-01-01T${value2}`);
    return Number.isNaN(maybe2.getTime()) ? undefined : maybe2;
  }
  const maybe = mode === "datetime" ? new Date(value2) : new Date(value2);
  return Number.isNaN(maybe.getTime()) ? undefined : maybe;
}
function formatDateInput(value2, mode, lang) {
  const date = toDate(value2, mode === "datetime" ? "datetime" : mode);
  if (!date)
    return;
  const options = {};
  if (mode === "time") {
    options.timeStyle = "short";
  } else if (mode === "datetime") {
    options.dateStyle = "medium";
    options.timeStyle = "short";
  } else {
    options.dateStyle = "medium";
  }
  return new Intl.DateTimeFormat(lang || undefined, options).format(date);
}

// src/preact/components/widgets/numeric.ts
function toNumber(value2, fallback) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : fallback;
}
function clampValue(value2, min, max, wrap) {
  if (wrap) {
    if (value2 > max)
      return min;
    if (value2 < min)
      return max;
    return value2;
  }
  return Math.min(max, Math.max(min, value2));
}
function buildNumericEmit(ctrl, fallbackLabel, value2) {
  return {
    payload: value2,
    topic: ctrl.topic ?? fallbackLabel,
    type: "numeric"
  };
}
function NumericWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asNum = control;
  const { t: t4, lang } = useI18n();
  const label = asNum.label || asNum.name || t4("number_label", "Number {index}", { index: index + 1 });
  const min = toNumber(asNum.min, Number.MIN_SAFE_INTEGER);
  const max = toNumber(asNum.max, Number.MAX_SAFE_INTEGER);
  const step = toNumber(asNum.step, 1) || 1;
  const [value2, setValue] = d2(clampValue(toNumber(asNum.value ?? asNum.min ?? 0, 0), min, max, !!asNum.wrap));
  const [focused, setFocused] = d2(false);
  const formatter = T2(() => new Intl.NumberFormat(lang || undefined), [lang]);
  y2(() => {
    const next = clampValue(toNumber(asNum.value ?? asNum.min ?? 0, 0), min, max, !!asNum.wrap);
    setValue(next);
  }, [asNum.value, asNum.min, min, max, asNum.wrap]);
  const update = (next) => {
    const clamped = clampValue(next, min, max, !!asNum.wrap);
    setValue(clamped);
    if (onEmit) {
      const payload = buildNumericEmit(asNum, label, clamped);
      onEmit("ui-control", payload);
    }
  };
  const handleChange = (e3) => {
    const target = e3.target;
    const next = toNumber(target.value, value2);
    update(next);
  };
  const format = asNum.format || "";
  const [prePart, rest] = format.split("{{");
  const [, postPart = ""] = (rest || "").split("}}");
  const pre = prePart || "";
  const post = postPart || "";
  const fieldStyles = buildFieldStyles({ focused, disabled: Boolean(disabled), hasAdornment: Boolean(post || pre) });
  return m2`<label style=${fieldWrapperStyles}>
    <span style=${fieldLabelStyles}>${label}</span>
    <div style=${{ position: "relative", width: "100%" }}>
      <div
        style=${{
    ...fieldStyles,
    display: "flex",
    alignItems: "center",
    gap: "8px",
    paddingRight: post ? "48px" : fieldStyles.paddingRight
  }}
      >
        ${pre ? m2`<span style=${fieldHelperStyles}>${pre}</span>` : null}
        <input
          class=${asNum.className || ""}
          type="number"
          min=${min}
          max=${max}
          step=${step}
          value=${value2}
          title=${asNum.tooltip || undefined}
          disabled=${Boolean(disabled)}
          aria-valuetext=${t4("number_value_label", "{label}: {value}", { label, value: formatNumber(value2, lang) })}
          onInput=${handleChange}
          onFocus=${() => setFocused(true)}
          onBlur=${() => setFocused(false)}
          style=${{
    flex: 1,
    background: "transparent",
    border: "none",
    color: "var(--nr-dashboard-widgetTextColor, inherit)",
    outline: "none",
    padding: 0,
    fontSize: "14px",
    minWidth: 0
  }}
        />
        ${post ? m2`<span style=${{ ...adornmentStyles, position: "static", transform: "none" }}>${post}</span>` : null}
      </div>
    </div>
    <span style=${{ ...fieldHelperStyles, alignSelf: "flex-end" }}>${t4("number_value_label", "{label}: {value}", { label, value: formatter.format(value2) })}</span>
  </label>`;
}

// src/preact/components/widgets/dropdown.ts
function parseOptionValue(val, type) {
  if (!type || type.startsWith("str"))
    return val;
  if (type === "number" || type === "num") {
    const n3 = Number(val);
    return Number.isFinite(n3) ? n3 : val;
  }
  if (type === "json") {
    try {
      return JSON.parse(val);
    } catch {
      return val;
    }
  }
  try {
    return JSON.parse(val);
  } catch {
    return val;
  }
}
function serializeOptionValue(val) {
  if (val === null || val === undefined)
    return "";
  if (typeof val === "string")
    return val;
  try {
    return JSON.stringify(val);
  } catch {
    return String(val);
  }
}
function inferType(opt) {
  if (!opt)
    return;
  if (opt.type)
    return opt.type;
  if (typeof opt.value === "number")
    return "number";
  if (typeof opt.value === "string")
    return "string";
  return "json";
}
function parseWithOptions(raw, opts) {
  const matched = opts.find((o3) => serializeOptionValue(o3.value) === raw);
  return parseOptionValue(raw, inferType(matched));
}
function normalizeValue(value2, opts, multiple) {
  if (multiple) {
    if (Array.isArray(value2)) {
      return value2.map((v3) => parseWithOptions(serializeOptionValue(v3), opts));
    }
    if (value2 === null || value2 === undefined || value2 === "")
      return [];
    if (typeof value2 === "string") {
      return value2.split(",").map((v3) => v3.trim()).filter(Boolean).map((v3) => parseWithOptions(v3, opts));
    }
    return [value2];
  }
  if (value2 === undefined)
    return null;
  if (value2 === "")
    return null;
  const serialized = serializeOptionValue(value2);
  return parseWithOptions(serialized, opts);
}
function buildDropdownEmit(ctrl, fallbackLabel, value2) {
  return {
    payload: value2,
    topic: ctrl.topic ?? fallbackLabel,
    type: "dropdown"
  };
}
function DropdownWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asDrop = control;
  const { t: t4 } = useI18n();
  const label = asDrop.label || asDrop.name || t4("dropdown_label", "Select {index}", { index: index + 1 });
  const opts = T2(() => asDrop.options ?? [], [asDrop.options]);
  const multiple = Boolean(asDrop.multiple);
  const [value2, setValue] = d2(normalizeValue(asDrop.value, opts, multiple));
  const lastReset = A2(false);
  const [focused, setFocused] = d2(false);
  y2(() => {
    const normalized = normalizeValue(asDrop.value, opts, multiple);
    if (multiple) {
      const filtered = normalized.filter((v3) => opts.some((o3) => serializeOptionValue(o3.value) === serializeOptionValue(v3)));
      setValue(filtered);
    } else {
      const exists = opts.some((o3) => serializeOptionValue(o3.value) === serializeOptionValue(normalized));
      setValue(exists ? normalized : null);
    }
  }, [asDrop.value, asDrop.resetSelection, multiple, opts]);
  y2(() => {
    if (asDrop.resetSelection && !lastReset.current) {
      setValue(multiple ? [] : null);
      lastReset.current = true;
    }
    if (!asDrop.resetSelection) {
      lastReset.current = false;
    }
  }, [asDrop.resetSelection, multiple]);
  const handleChange = (e3) => {
    const target = e3.target;
    if (multiple) {
      const selected = [];
      Array.from(target.selectedOptions).forEach((opt) => {
        selected.push(parseOptionValue(opt.value, opt.dataset.type));
      });
      setValue(selected);
      if (onEmit)
        onEmit("ui-control", buildDropdownEmit(asDrop, label, selected));
    } else {
      const opt = target.selectedOptions[0];
      if (!opt)
        return;
      const parsed = parseOptionValue(opt.value, opt.dataset.type);
      setValue(parsed);
      if (onEmit)
        onEmit("ui-control", buildDropdownEmit(asDrop, label, parsed));
    }
  };
  const fieldStyles = buildFieldStyles({ focused, disabled: Boolean(disabled), hasAdornment: true });
  return m2`<label style=${fieldWrapperStyles}>
    <span style=${fieldLabelStyles}>${label}</span>
    <div style=${{ position: "relative", width: "100%" }}>
      <select
        multiple=${multiple}
        class=${asDrop.className || ""}
        title=${asDrop.tooltip || undefined}
        disabled=${Boolean(disabled)}
        value=${!multiple ? serializeOptionValue(value2) : undefined}
        onChange=${handleChange}
        onFocus=${() => setFocused(true)}
        onBlur=${() => setFocused(false)}
        style=${{
    ...fieldStyles,
    paddingRight: "44px",
    cursor: Boolean(disabled) ? "not-allowed" : "pointer",
    display: "block"
  }}
      >
        ${asDrop.place && !multiple ? m2`<option value="" disabled selected=${value2 == null || value2 === ""}>${asDrop.place}</option>` : null}
        ${opts.map((opt) => {
    const serialized = typeof opt.value === "string" ? opt.value : JSON.stringify(opt.value);
    const inferredType = opt.type ? opt.type : typeof opt.value === "number" ? "number" : typeof opt.value === "string" ? "string" : "json";
    const selected = multiple ? Array.isArray(value2) && value2.some((v3) => JSON.stringify(v3) === JSON.stringify(opt.value)) : JSON.stringify(value2) === JSON.stringify(opt.value);
    return m2`<option
            value=${serialized}
            data-type=${inferredType}
            disabled=${opt.disabled || false}
            selected=${selected}
          >
            ${opt.label ?? opt.value}
          </option>`;
  })}
      </select>
      <span aria-hidden="true" style=${adornmentStyles}></span>
    </div>
  </label>`;
}

// src/preact/components/widgets/slider.ts
var DEFAULT_THROTTLE_MS = 10;
var SLIDER_STYLE_ID = "nr-dashboard-slider-style";
var MAX_TICKS = 10;
function ensureSliderStyles(doc = typeof document !== "undefined" ? document : undefined) {
  if (!doc)
    return;
  if (doc.getElementById(SLIDER_STYLE_ID))
    return;
  const style = doc.createElement("style");
  style.id = SLIDER_STYLE_ID;
  style.textContent = `
    :root {
      --nr-dashboard-slider-track: var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.18));
      --nr-dashboard-slider-fill: var(--nr-dashboard-widgetColor, #1f8af2);
      --nr-dashboard-slider-thumb: var(--nr-dashboard-widgetColor, #1f8af2);
      --nr-dashboard-slider-thumb-shadow: 0 1px 2px var(--nr-dashboard-widgetBorderColor, rgba(0,0,0,0.25));
      --nr-dashboard-slider-focus: var(--nr-dashboard-widgetColor, #1f8af2);
      --nr-dashboard-slider-text: var(--nr-dashboard-widgetTextColor, #e9ecf1);
      --nr-dashboard-slider-chip-bg: var(--nr-dashboard-widgetBackgroundColor, transparent);
      --nr-dashboard-slider-chip-shadow: 0 2px 6px var(--nr-dashboard-widgetBorderColor, rgba(0,0,0,0.2));
    }

    .nr-dashboard-slider {
      display: flex;
      flex-direction: column;
      gap: 6px;
      width: 100%;
      align-items: stretch;
      padding: 0 12px;
    }

    .nr-dashboard-slider.is-vertical {
      flex-direction: row;
      padding: 0;
      font-size: 12px;
    }

    .nr-dashboard-slider__row {
      display: flex;
      align-items: center;
      gap: 0;
      width: 100%;
    }

    .nr-dashboard-slider__label {
      font-size: 13px;
      opacity: 0.8;
      white-space: nowrap;
      margin-right: 15px;
    }

    .nr-dashboard-slider__label.is-vertical {
      margin-left: 8px;
      margin-top: 6px;
      padding-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
    }

    .nr-dashboard-slider__minmax {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      opacity: 0.7;
      color: var(--nr-dashboard-slider-text);
      padding: 0 2px;
    }

    .nr-dashboard-slider__range {
      width: 100%;
      accent-color: var(--nr-dashboard-slider-fill);
      background: transparent;
      touch-action: none;
      height: 6px;
    }

    .nr-dashboard-slider__range.is-vertical {
      width: 24px;
      height: 200px;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
    }

    .nr-dashboard-slider__range::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background: var(--nr-dashboard-slider-track);
    }

    .nr-dashboard-slider__range::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 16px;
      width: 16px;
      margin-top: -5px;
      border-radius: 50%;
      background: var(--nr-dashboard-slider-thumb);
      box-shadow: var(--nr-dashboard-slider-thumb-shadow);
      border: 1px solid transparent;
    }

    .nr-dashboard-slider__range:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--nr-dashboard-slider-focus) 30%, transparent);
    }

    .nr-dashboard-slider__track {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 1;
    }

    .nr-dashboard-slider__track.is-vertical {
      flex-direction: column;
      height: 200px;
      width: 36px;
    }

    .nr-dashboard-slider__range::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background: var(--nr-dashboard-slider-track);
    }

    .nr-dashboard-slider__range::-moz-range-progress {
      height: 6px;
      border-radius: 999px;
      background: var(--nr-dashboard-slider-fill);
    }

    .nr-dashboard-slider__range::-moz-range-thumb {
      height: 14px;
      width: 14px;
      border-radius: 50%;
      background: var(--nr-dashboard-slider-thumb);
      box-shadow: var(--nr-dashboard-slider-thumb-shadow);
      border: 1px solid transparent;
    }

    .nr-dashboard-slider__sign {
      position: absolute;
      padding: 4px 8px;
      border-radius: 12px;
        background: var(--nr-dashboard-slider-chip-bg);
        color: var(--nr-dashboard-slider-text);
      font-size: 11px;
      box-shadow: var(--nr-dashboard-slider-chip-shadow);
      pointer-events: none;
      white-space: nowrap;
    }

    .nr-dashboard-slider__sign.is-vertical {
      left: calc(50% + 14px);
      transform: translate(-50%, -50%);
    }

    .nr-dashboard-slider__value {
      opacity: 0.6;
      font-size: 12px;
      color: var(--nr-dashboard-slider-text);
    }
  `;
  doc.head.appendChild(style);
}
function toNumber2(value2, fallback) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : fallback;
}
function normalizeSliderRange(minValue, maxValue, invert) {
  const rawMin = toNumber2(minValue, 0);
  const rawMax = toNumber2(maxValue, 10);
  const min = Math.min(rawMin, rawMax);
  const max = Math.max(rawMin, rawMax);
  const shouldInvert = Boolean(invert) || rawMin > rawMax;
  return { min, max, invert: shouldInvert };
}
function clampSliderValue(value2, min, max) {
  return Math.min(max, Math.max(min, value2));
}
function buildSliderEmit(ctrl, fallbackLabel, value2) {
  return {
    payload: value2,
    topic: ctrl.topic ?? fallbackLabel,
    type: "slider"
  };
}
function SliderWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const asSlider = control;
  const { t: t4, lang } = useI18n();
  const label = asSlider.label || asSlider.name || t4("slider_label", "Slider {index}", { index: index + 1 });
  const isDisabled = Boolean(disabled);
  ensureSliderStyles();
  const { min, max, invert } = normalizeSliderRange(asSlider.min, asSlider.max, asSlider.invert);
  const step = Math.abs(toNumber2(asSlider.step, 1)) || 1;
  const outs = asSlider.outs === "end" ? "end" : "all";
  const isVertical = toNumber2(asSlider.width ?? 0, 0) < toNumber2(asSlider.height ?? 0, 0);
  const isDiscrete = outs === "end";
  const forceSign = Boolean(asSlider.showSign);
  const formatter = new Intl.NumberFormat(lang || undefined);
  const initial = clampSliderValue(toNumber2(asSlider.value ?? min, min), min, max);
  const [value2, setValue] = d2(initial);
  const [dragging, setDragging] = d2(false);
  y2(() => {
    setValue(clampSliderValue(toNumber2(asSlider.value ?? min, min), min, max));
  }, [asSlider.value, min, max]);
  const timer = A2(undefined);
  y2(() => () => {
    if (timer.current !== undefined) {
      clearTimeout(timer.current);
    }
  }, []);
  const toDisplayValue = (logical) => invert ? max - (logical - min) : logical;
  const fromDisplayValue = (display) => invert ? max - (display - min) : display;
  const emit = (next) => {
    if (!onEmit || isDisabled)
      return;
    onEmit("ui-control", buildSliderEmit(asSlider, label, next));
  };
  const scheduleEmit = (next) => {
    if (!onEmit || isDisabled)
      return;
    if (outs !== "all")
      return;
    if (timer.current !== undefined)
      clearTimeout(timer.current);
    timer.current = window.setTimeout(() => {
      timer.current = undefined;
      emit(next);
    }, DEFAULT_THROTTLE_MS);
  };
  const handleInput = (e3) => {
    if (isDisabled)
      return;
    const target = e3.target;
    const rawDisplay = toNumber2(target.value, toDisplayValue(value2));
    const logical = clampSliderValue(fromDisplayValue(rawDisplay), min, max);
    setValue(logical);
    if (outs === "all") {
      scheduleEmit(logical);
    }
  };
  const handleChange = (e3) => {
    if (isDisabled || outs !== "end")
      return;
    const target = e3.target;
    const rawDisplay = toNumber2(target.value, toDisplayValue(value2));
    const logical = clampSliderValue(fromDisplayValue(rawDisplay), min, max);
    setValue(logical);
    emit(logical);
  };
  const handleWheel = (e3) => {
    if (isDisabled || outs !== "all")
      return;
    e3.preventDefault();
    const delta = e3.deltaY > 0 ? step : -step;
    const next = clampSliderValue(value2 + delta, min, max);
    setValue(next);
    scheduleEmit(next);
  };
  const sliderValue = toDisplayValue(value2);
  const span = Math.max(1, max - min);
  const percent = Math.min(1, Math.max(0, (sliderValue - min) / span));
  const stepCount = step > 0 ? Math.floor((max - min) / step) : 0;
  const showTicks = stepCount > 0 && stepCount <= MAX_TICKS;
  const showSign = forceSign || dragging;
  const sliderStyle = isVertical ? {
    width: "32px",
    height: "200px",
    writingMode: "bt-lr",
    WebkitAppearance: "slider-vertical",
    background: `linear-gradient(to top, var(--nr-dashboard-slider-fill) ${percent * 100}%, var(--nr-dashboard-slider-track) ${percent * 100}%)`
  } : {
    width: "100%",
    background: `linear-gradient(to right, var(--nr-dashboard-slider-fill) ${percent * 100}%, var(--nr-dashboard-slider-track) ${percent * 100}%)`
  };
  const containerClass = ["nr-dashboard-slider", asSlider.className || "", isVertical ? "is-vertical" : ""].filter(Boolean).join(" ");
  return m2`<div class=${containerClass}>
    ${!isVertical ? m2`<div class="nr-dashboard-slider__row">
          <span class="nr-dashboard-slider__label">${label}</span>
          <div class=${`nr-dashboard-slider__track ${isVertical ? "is-vertical" : ""}`.trim()}>
            <input
              class=${`nr-dashboard-slider__range ${isVertical ? "is-vertical" : ""}`.trim()}
              type="range"
              min=${min}
              max=${max}
              step=${step}
              value=${sliderValue}
              title=${asSlider.tooltip || undefined}
              disabled=${isDisabled}
              aria-valuetext=${t4("slider_value_label", "{label}: {value}", { label, value: formatNumber(value2, lang) })}
              onInput=${handleInput}
              onChange=${handleChange}
              onWheel=${handleWheel}
              onPointerDown=${() => setDragging(true)}
              onPointerUp=${() => setDragging(false)}
              onPointerCancel=${() => setDragging(false)}
              onBlur=${() => setDragging(false)}
              onMouseLeave=${() => setDragging(false)}
              style=${{
    ...sliderStyle,
    transform: isVertical && invert ? "rotate(180deg)" : undefined
  }}
            />
            ${showTicks ? m2`<div class=${`nr-dashboard-slider__ticks ${isVertical ? "is-vertical" : ""}`.trim()}>
                  ${Array.from({ length: stepCount + 1 }).map((_3, idx) => {
    const pos = idx / stepCount * 100;
    const active = percent * 100 >= pos;
    const style = isVertical ? { top: `${100 - pos}%`, left: "0" } : { left: `${pos}%`, top: "0" };
    return m2`<span
                      class=${`nr-dashboard-slider__tick ${isVertical ? "is-vertical" : ""} ${active ? "is-active" : ""}`.trim()}
                      style=${style}
                    ></span>`;
  })}
                </div>` : null}
            ${showSign ? m2`<span
                  class=${`nr-dashboard-slider__sign ${isVertical ? "is-vertical" : ""}`.trim()}
                  style=${isVertical ? { top: `${100 - percent * 100}%` } : { left: `${percent * 100}%`, transform: "translate(-50%, -120%)" }}
                >${formatter.format(value2)}</span>` : null}
          </div>
        </div>` : m2`<div class=${`nr-dashboard-slider__track ${isVertical ? "is-vertical" : ""}`.trim()}>
          <input
            class=${`nr-dashboard-slider__range ${isVertical ? "is-vertical" : ""}`.trim()}
            type="range"
            min=${min}
            max=${max}
            step=${step}
            value=${sliderValue}
            title=${asSlider.tooltip || undefined}
            disabled=${isDisabled}
            aria-valuetext=${t4("slider_value_label", "{label}: {value}", { label, value: formatNumber(value2, lang) })}
            onInput=${handleInput}
            onChange=${handleChange}
            onWheel=${handleWheel}
            onPointerDown=${() => setDragging(true)}
            onPointerUp=${() => setDragging(false)}
            onPointerCancel=${() => setDragging(false)}
            onBlur=${() => setDragging(false)}
            onMouseLeave=${() => setDragging(false)}
            style=${{
    ...sliderStyle,
    transform: isVertical && invert ? "rotate(180deg)" : undefined
  }}
          />
          ${showTicks ? m2`<div class=${`nr-dashboard-slider__ticks ${isVertical ? "is-vertical" : ""}`.trim()}>
                ${Array.from({ length: stepCount + 1 }).map((_3, idx) => {
    const pos = idx / stepCount * 100;
    const active = percent * 100 >= pos;
    const style = isVertical ? { top: `${100 - pos}%`, left: "0" } : { left: `${pos}%`, top: "0" };
    return m2`<span
                    class=${`nr-dashboard-slider__tick ${isVertical ? "is-vertical" : ""} ${active ? "is-active" : ""}`.trim()}
                    style=${style}
                  ></span>`;
  })}
              </div>` : null}
          ${showSign ? m2`<span
                class=${`nr-dashboard-slider__sign ${isVertical ? "is-vertical" : ""}`.trim()}
                style=${isVertical ? { top: `${100 - percent * 100}%` } : { left: `${percent * 100}%`, transform: "translate(-50%, -120%)" }}
              >${formatter.format(value2)}</span>` : null}
        </div>`}
    ${!isVertical ? m2`<div class="nr-dashboard-slider__minmax">
          <span>${formatter.format(min)}</span>
          <span>${formatter.format(max)}</span>
        </div>` : null}
    ${isVertical ? m2`<span class="nr-dashboard-slider__label is-vertical">${label}</span>` : null}
    <span class="nr-dashboard-slider__value">${formatter.format(value2)}</span>
  </div>`;
}

// node_modules/echarts/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d3, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
    d4.__proto__ = b2;
  } || function(d4, b2) {
    for (var p3 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p3))
        d4[p3] = b2[p3];
  };
  return extendStatics(d3, b);
};
function __extends(d3, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d3, b);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
}

// node_modules/zrender/lib/core/platform.js
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map = {};
  if (typeof JSON === "undefined") {
    return map;
  }
  for (var i3 = 0;i3 < mapStr.length; i3++) {
    var char = String.fromCharCode(i3 + 32);
    var size = (mapStr.charCodeAt(i3) - OFFSET) / SCALE;
    map[char] = size;
  }
  return map;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        var res = /((?:\d+)?\.?\d*)px/.exec(font);
        var fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
        var width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (var i3 = 0;i3 < text.length; i3++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i3]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width };
      }
    };
  }(),
  loadImage: function(src, onload, onerror) {
    var image = new Image;
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};

// node_modules/zrender/lib/core/util.js
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val) {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val) {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  var args = [];
  for (var _i = 0;_i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i3 = 0, len = source.length;i3 < len; i3++) {
        result[i3] = clone(source[i3]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i3 = 0, len = source.length;i3 < len; i3++) {
          result[i3] = source[i3];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone(source[key]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject2(source) || !isObject2(target)) {
    return overwrite ? clone(source) : target;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject2(sourceProp) && isObject2(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone(source[key]);
      }
    }
  }
  return target;
}
function extend(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function defaults(target, source, overlay) {
  var keysArr = keys(source);
  for (var i3 = 0, len = keysArr.length;i3 < len; i3++) {
    var key = keysArr[i3];
    if (overlay ? source[key] != null : target[key] == null) {
      target[key] = source[key];
    }
  }
  return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value2) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value2);
    }
    for (var i3 = 0, len = array.length;i3 < len; i3++) {
      if (array[i3] === value2) {
        return i3;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;
  function F2() {}
  F2.prototype = baseClazz.prototype;
  clazz.prototype = new F2;
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin2(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    var keyList = Object.getOwnPropertyNames(source);
    for (var i3 = 0;i3 < keyList.length; i3++) {
      var key = keyList[i3];
      if (key !== "constructor") {
        if (override ? source[key] != null : target[key] == null) {
          target[key] = source[key];
        }
      }
    }
  } else {
    defaults(target, source, override);
  }
}
function isArrayLike(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (var i3 = 0, len = arr.length;i3 < len; i3++) {
      cb.call(context, arr[i3], i3, arr);
    }
  } else {
    for (var key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    var result = [];
    for (var i3 = 0, len = arr.length;i3 < len; i3++) {
      result.push(cb.call(context, arr[i3], i3, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i3 = 0, len = arr.length;i3 < len; i3++) {
    memo = cb.call(context, memo, arr[i3], i3, arr);
  }
  return memo;
}
function filter(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    var result = [];
    for (var i3 = 0, len = arr.length;i3 < len; i3++) {
      if (cb.call(context, arr[i3], i3, arr)) {
        result.push(arr[i3]);
      }
    }
    return result;
  }
}
function find(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i3 = 0, len = arr.length;i3 < len; i3++) {
    if (cb.call(context, arr[i3], i3, arr)) {
      return arr[i3];
    }
  }
}
function keys(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keyList = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i = 2;_i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry(func) {
  var args = [];
  for (var _i = 1;_i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray(value2) {
  if (Array.isArray) {
    return Array.isArray(value2);
  }
  return objToString.call(value2) === "[object Array]";
}
function isFunction(value2) {
  return typeof value2 === "function";
}
function isString(value2) {
  return typeof value2 === "string";
}
function isStringSafe(value2) {
  return objToString.call(value2) === "[object String]";
}
function isNumber(value2) {
  return typeof value2 === "number";
}
function isObject2(value2) {
  var type = typeof value2;
  return type === "function" || !!value2 && type === "object";
}
function isBuiltInObject(value2) {
  return !!BUILTIN_OBJECT[objToString.call(value2)];
}
function isTypedArray(value2) {
  return !!TYPED_ARRAY[objToString.call(value2)];
}
function isDom(value2) {
  return typeof value2 === "object" && typeof value2.nodeType === "number" && typeof value2.ownerDocument === "object";
}
function isGradientObject(value2) {
  return value2.colorStops != null;
}
function isImagePatternObject(value2) {
  return value2.image != null;
}
function isRegExp(value2) {
  return objToString.call(value2) === "[object RegExp]";
}
function eqNaN(value2) {
  return value2 !== value2;
}
function retrieve() {
  var args = [];
  for (var _i = 0;_i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  for (var i3 = 0, len = args.length;i3 < len; i3++) {
    if (args[i3] != null) {
      return args[i3];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr) {
  var args = [];
  for (var _i = 1;_i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  var len = val.length;
  if (len === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var MapPolyfill = function() {
  function MapPolyfill2() {
    this.data = {};
  }
  MapPolyfill2.prototype["delete"] = function(key) {
    var existed = this.has(key);
    if (existed) {
      delete this.data[key];
    }
    return existed;
  };
  MapPolyfill2.prototype.has = function(key) {
    return this.data.hasOwnProperty(key);
  };
  MapPolyfill2.prototype.get = function(key) {
    return this.data[key];
  };
  MapPolyfill2.prototype.set = function(key, value2) {
    this.data[key] = value2;
    return this;
  };
  MapPolyfill2.prototype.keys = function() {
    return keys(this.data);
  };
  MapPolyfill2.prototype.forEach = function(callback) {
    var data = this.data;
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        callback(data[key], key);
      }
    }
  };
  return MapPolyfill2;
}();
var isNativeMapSupported = typeof Map === "function";
function maybeNativeMap() {
  return isNativeMapSupported ? new Map : new MapPolyfill;
}
var HashMap = function() {
  function HashMap2(obj) {
    var isArr = isArray(obj);
    this.data = maybeNativeMap();
    var thisMap = this;
    obj instanceof HashMap2 ? obj.each(visit) : obj && each(obj, visit);
    function visit(value2, key) {
      isArr ? thisMap.set(value2, key) : thisMap.set(key, value2);
    }
  }
  HashMap2.prototype.hasKey = function(key) {
    return this.data.has(key);
  };
  HashMap2.prototype.get = function(key) {
    return this.data.get(key);
  };
  HashMap2.prototype.set = function(key, value2) {
    this.data.set(key, value2);
    return value2;
  };
  HashMap2.prototype.each = function(cb, context) {
    this.data.forEach(function(value2, key) {
      cb.call(context, value2, key);
    });
  };
  HashMap2.prototype.keys = function() {
    var keys2 = this.data.keys();
    return isNativeMapSupported ? Array.from(keys2) : keys2;
  };
  HashMap2.prototype.removeKey = function(key) {
    this.data["delete"](key);
  };
  return HashMap2;
}();
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a3, b) {
  var newArray = new a3.constructor(a3.length + b.length);
  for (var i3 = 0;i3 < a3.length; i3++) {
    newArray[i3] = a3[i3];
  }
  var offset = a3.length;
  for (var i3 = 0;i3 < b.length; i3++) {
    newArray[i3 + offset] = b[i3];
  }
  return newArray;
}
function createObject(proto, properties) {
  var obj;
  if (Object.create) {
    obj = Object.create(proto);
  } else {
    var StyleCtor = function() {};
    StyleCtor.prototype = proto;
    obj = new StyleCtor;
  }
  if (properties) {
    extend(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  var domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop() {}
var RADIAN_TO_DEGREE = 180 / Math.PI;

// node_modules/zrender/lib/core/env.js
var Browser = function() {
  function Browser2() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
  return Browser2;
}();
var Env = function() {
  function Env2() {
    this.browser = new Browser;
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
  return Env2;
}();
var env = new Env;
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (!env.hasGlobalWindow || "Deno" in window) {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  var browser = env2.browser;
  var firefox = ua.match(/Firefox\/([\d.]+)/);
  var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge?\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
    browser.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  var style = document.documentElement.style;
  env2.transform3dSupported = (browser.ie && ("transition" in style) || browser.edge || ("WebKitCSSMatrix" in window) && ("m11" in new WebKitCSSMatrix) || ("MozPerspective" in style)) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
}
var env_default = env;

// node_modules/echarts/lib/util/clazz.js
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  var ret = {
    main: "",
    sub: ""
  };
  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto) {
    if (true) {
      each(mandatoryMethods, function(method) {
        if (!proto[method]) {
          console.warn("Method `" + method + "` should be implemented" + (proto.type ? " in " + proto.type : "") + ".");
        }
      });
    }
    var superClass = this;
    var ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          return _super.apply(this, arguments) || this;
        }
        return class_1;
      }(superClass);
    } else {
      ExtendedClass = function() {
        (proto.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend(ExtendedClass.prototype, proto);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn) {
  return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  var classAttr = ["__\x00is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  if (true) {
    assert(!target.isInstance, 'The method "is" can not be defined.');
  }
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = [];
  for (var _i = 2;_i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  var storage = {};
  target.registerClass = function(clz) {
    var componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        if (true) {
          if (storage[componentTypeInfo.main]) {
            console.warn(componentTypeInfo.main + " exists.");
          }
        }
        storage[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    var clz = storage[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + "." + "type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each(obj, function(o3, type) {
        type !== IS_CONTAINER && result.push(o3);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    return !!storage[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    var types = [];
    each(storage, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    var container = storage[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}

// node_modules/echarts/lib/model/mixin/makeStyleMapper.js
function makeStyleMapper(properties, ignoreParent) {
  for (var i3 = 0;i3 < properties.length; i3++) {
    if (!properties[i3][1]) {
      properties[i3][1] = properties[i3][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    var style = {};
    for (var i4 = 0;i4 < properties.length; i4++) {
      var propName = properties[i4][1];
      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }
      var val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i4][0]] = val;
      }
    }
    return style;
  };
}

// node_modules/echarts/lib/model/mixin/areaStyle.js
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
  function AreaStyleMixin2() {}
  AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  };
  return AreaStyleMixin2;
}();

// node_modules/zrender/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics2 = function(d3, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
    d4.__proto__ = b2;
  } || function(d4, b2) {
    for (var p3 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p3))
        d4[p3] = b2[p3];
  };
  return extendStatics2(d3, b);
};
function __extends2(d3, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d3, b);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
}

// node_modules/zrender/lib/core/LRU.js
var Entry = function() {
  function Entry2(val) {
    this.value = val;
  }
  return Entry2;
}();
var LinkedList = function() {
  function LinkedList2() {
    this._len = 0;
  }
  LinkedList2.prototype.insert = function(val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  LinkedList2.prototype.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  };
  LinkedList2.prototype.remove = function(entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  LinkedList2.prototype.len = function() {
    return this._len;
  };
  LinkedList2.prototype.clear = function() {
    this.head = this.tail = null;
    this._len = 0;
  };
  return LinkedList2;
}();
var LRU = function() {
  function LRU2(maxSize) {
    this._list = new LinkedList;
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  LRU2.prototype.put = function(key, value2) {
    var list = this._list;
    var map2 = this._map;
    var removed = null;
    if (map2[key] == null) {
      var len = list.len();
      var entry = this._lastRemovedEntry;
      if (len >= this._maxSize && len > 0) {
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map2[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value2;
      } else {
        entry = new Entry(value2);
      }
      entry.key = key;
      list.insertEntry(entry);
      map2[key] = entry;
    }
    return removed;
  };
  LRU2.prototype.get = function(key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRU2.prototype.clear = function() {
    this._list.clear();
    this._map = {};
  };
  LRU2.prototype.len = function() {
    return this._list.len();
  };
  return LRU2;
}();
var LRU_default = LRU;

// node_modules/zrender/lib/graphic/helper/image.js
var globalImageCache = new LRU_default(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = { hostEl, cb: onload, cbPayload };
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i3 = 0;i3 < cachedImgObj.pending.length; i3++) {
    var pendingWrap = cachedImgObj.pending[i3];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}

// node_modules/zrender/lib/core/matrix.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
function copy(out, m4) {
  out[0] = m4[0];
  out[1] = m4[1];
  out[2] = m4[2];
  out[3] = m4[3];
  out[4] = m4[4];
  out[5] = m4[5];
  return out;
}
function mul(out, m1, m22) {
  var out0 = m1[0] * m22[0] + m1[2] * m22[1];
  var out1 = m1[1] * m22[0] + m1[3] * m22[1];
  var out2 = m1[0] * m22[2] + m1[2] * m22[3];
  var out3 = m1[1] * m22[2] + m1[3] * m22[3];
  var out4 = m1[0] * m22[4] + m1[2] * m22[5] + m1[4];
  var out5 = m1[1] * m22[4] + m1[3] * m22[5] + m1[5];
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = out3;
  out[4] = out4;
  out[5] = out5;
  return out;
}
function translate(out, a3, v3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4] + v3[0];
  out[5] = a3[5] + v3[1];
  return out;
}
function rotate(out, a3, rad, pivot) {
  if (pivot === undefined) {
    pivot = [0, 0];
  }
  var aa = a3[0];
  var ac = a3[2];
  var atx = a3[4];
  var ab = a3[1];
  var ad = a3[3];
  var aty = a3[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
  out[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
  return out;
}
function scale(out, a3, v3) {
  var vx = v3[0];
  var vy = v3[1];
  out[0] = a3[0] * vx;
  out[1] = a3[1] * vy;
  out[2] = a3[2] * vx;
  out[3] = a3[3] * vy;
  out[4] = a3[4] * vx;
  out[5] = a3[5] * vy;
  return out;
}
function invert(out, a3) {
  var aa = a3[0];
  var ac = a3[2];
  var atx = a3[4];
  var ab = a3[1];
  var ad = a3[3];
  var aty = a3[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

// node_modules/zrender/lib/core/Point.js
var Point = function() {
  function Point2(x3, y3) {
    this.x = x3 || 0;
    this.y = y3 || 0;
  }
  Point2.prototype.copy = function(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.set = function(x3, y3) {
    this.x = x3;
    this.y = y3;
    return this;
  };
  Point2.prototype.equal = function(other) {
    return other.x === this.x && other.y === this.y;
  };
  Point2.prototype.add = function(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  };
  Point2.prototype.scale = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  };
  Point2.prototype.scaleAndAdd = function(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  };
  Point2.prototype.sub = function(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  };
  Point2.prototype.dot = function(other) {
    return this.x * other.x + this.y * other.y;
  };
  Point2.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Point2.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  };
  Point2.prototype.normalize = function() {
    var len = this.len();
    this.x /= len;
    this.y /= len;
    return this;
  };
  Point2.prototype.distance = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.distanceSquare = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return dx * dx + dy * dy;
  };
  Point2.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  Point2.prototype.transform = function(m4) {
    if (!m4) {
      return;
    }
    var x3 = this.x;
    var y3 = this.y;
    this.x = m4[0] * x3 + m4[2] * y3 + m4[4];
    this.y = m4[1] * x3 + m4[3] * y3 + m4[5];
    return this;
  };
  Point2.prototype.toArray = function(out) {
    out[0] = this.x;
    out[1] = this.y;
    return out;
  };
  Point2.prototype.fromArray = function(input) {
    this.x = input[0];
    this.y = input[1];
  };
  Point2.set = function(p3, x3, y3) {
    p3.x = x3;
    p3.y = y3;
  };
  Point2.copy = function(p3, p22) {
    p3.x = p22.x;
    p3.y = p22.y;
  };
  Point2.len = function(p3) {
    return Math.sqrt(p3.x * p3.x + p3.y * p3.y);
  };
  Point2.lenSquare = function(p3) {
    return p3.x * p3.x + p3.y * p3.y;
  };
  Point2.dot = function(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  };
  Point2.add = function(out, p0, p1) {
    out.x = p0.x + p1.x;
    out.y = p0.y + p1.y;
  };
  Point2.sub = function(out, p0, p1) {
    out.x = p0.x - p1.x;
    out.y = p0.y - p1.y;
  };
  Point2.scale = function(out, p0, scalar) {
    out.x = p0.x * scalar;
    out.y = p0.y * scalar;
  };
  Point2.scaleAndAdd = function(out, p0, p1, scalar) {
    out.x = p0.x + p1.x * scalar;
    out.y = p0.y + p1.y * scalar;
  };
  Point2.lerp = function(out, p0, p1, t4) {
    var onet = 1 - t4;
    out.x = onet * p0.x + t4 * p1.x;
    out.y = onet * p0.y + t4 * p1.y;
  };
  return Point2;
}();
var Point_default = Point;

// node_modules/zrender/lib/core/BoundingRect.js
var mathMin = Math.min;
var mathMax = Math.max;
var lt = new Point_default;
var rb = new Point_default;
var lb = new Point_default;
var rt = new Point_default;
var minTv = new Point_default;
var maxTv = new Point_default;
var BoundingRect = function() {
  function BoundingRect2(x3, y3, width, height) {
    if (width < 0) {
      x3 = x3 + width;
      width = -width;
    }
    if (height < 0) {
      y3 = y3 + height;
      height = -height;
    }
    this.x = x3;
    this.y = y3;
    this.width = width;
    this.height = height;
  }
  BoundingRect2.prototype.union = function(other) {
    var x3 = mathMin(other.x, this.x);
    var y3 = mathMin(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax(other.x + other.width, this.x + this.width) - x3;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax(other.y + other.height, this.y + this.height) - y3;
    } else {
      this.height = other.height;
    }
    this.x = x3;
    this.y = y3;
  };
  BoundingRect2.prototype.applyTransform = function(m4) {
    BoundingRect2.applyTransform(this, this, m4);
  };
  BoundingRect2.prototype.calculateTransform = function(b) {
    var a3 = this;
    var sx = b.width / a3.width;
    var sy = b.height / a3.height;
    var m4 = create();
    translate(m4, m4, [-a3.x, -a3.y]);
    scale(m4, m4, [sx, sy]);
    translate(m4, m4, [b.x, b.y]);
    return m4;
  };
  BoundingRect2.prototype.intersect = function(b, mtv) {
    if (!b) {
      return false;
    }
    if (!(b instanceof BoundingRect2)) {
      b = BoundingRect2.create(b);
    }
    var a3 = this;
    var ax0 = a3.x;
    var ax1 = a3.x + a3.width;
    var ay0 = a3.y;
    var ay1 = a3.y + a3.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      var dMin = Infinity;
      var dMax = 0;
      var d0 = Math.abs(ax1 - bx0);
      var d1 = Math.abs(bx1 - ax0);
      var d22 = Math.abs(ay1 - by0);
      var d3 = Math.abs(by1 - ay0);
      var dx = Math.min(d0, d1);
      var dy = Math.min(d22, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point_default.set(maxTv, -d0, 0);
          } else {
            Point_default.set(maxTv, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point_default.set(minTv, d0, 0);
          } else {
            Point_default.set(minTv, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d22 < d3) {
            Point_default.set(maxTv, 0, -d22);
          } else {
            Point_default.set(maxTv, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d22 < d3) {
            Point_default.set(minTv, 0, d22);
          } else {
            Point_default.set(minTv, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point_default.copy(mtv, overlap ? minTv : maxTv);
    }
    return overlap;
  };
  BoundingRect2.prototype.contain = function(x3, y3) {
    var rect = this;
    return x3 >= rect.x && x3 <= rect.x + rect.width && y3 >= rect.y && y3 <= rect.y + rect.height;
  };
  BoundingRect2.prototype.clone = function() {
    return new BoundingRect2(this.x, this.y, this.width, this.height);
  };
  BoundingRect2.prototype.copy = function(other) {
    BoundingRect2.copy(this, other);
  };
  BoundingRect2.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };
  BoundingRect2.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  };
  BoundingRect2.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  };
  BoundingRect2.create = function(rect) {
    return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
  };
  BoundingRect2.copy = function(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
  };
  BoundingRect2.applyTransform = function(target, source, m4) {
    if (!m4) {
      if (target !== source) {
        BoundingRect2.copy(target, source);
      }
      return;
    }
    if (m4[1] < 0.00001 && m4[1] > -0.00001 && m4[2] < 0.00001 && m4[2] > -0.00001) {
      var sx = m4[0];
      var sy = m4[3];
      var tx = m4[4];
      var ty = m4[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt.x = lb.x = source.x;
    lt.y = rt.y = source.y;
    rb.x = rt.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt.transform(m4);
    rt.transform(m4);
    rb.transform(m4);
    lb.transform(m4);
    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);
    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);
    var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);
    var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  };
  return BoundingRect2;
}();
var BoundingRect_default = BoundingRect;

// node_modules/zrender/lib/contain/text.js
var textWidthCache = {};
function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRU_default(500);
  }
  var width = cacheOfFont.get(text);
  if (width == null) {
    width = platformApi.measureText(text, font).width;
    cacheOfFont.put(text, width);
  }
  return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
  var width = getWidth(text, font);
  var height = getLineHeight(font);
  var x3 = adjustTextX(0, width, textAlign);
  var y3 = adjustTextY(0, height, textBaseline);
  var rect = new BoundingRect_default(x3, y3, width, height);
  return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
  var textLines = ((text || "") + "").split(`
`);
  var len = textLines.length;
  if (len === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    var uniondRect = new BoundingRect_default(0, 0, 0, 0);
    for (var i3 = 0;i3 < textLines.length; i3++) {
      var rect = innerGetBoundingRect(textLines[i3], font, textAlign, textBaseline);
      i3 === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x3, width, textAlign) {
  if (textAlign === "right") {
    x3 -= width;
  } else if (textAlign === "center") {
    x3 -= width / 2;
  }
  return x3;
}
function adjustTextY(y3, height, verticalAlign) {
  if (verticalAlign === "middle") {
    y3 -= height / 2;
  } else if (verticalAlign === "bottom") {
    y3 -= height;
  }
  return y3;
}
function getLineHeight(font) {
  return getWidth("", font);
}
function parsePercent(value2, maxValue) {
  if (typeof value2 === "string") {
    if (value2.lastIndexOf("%") >= 0) {
      return parseFloat(value2) / 100 * maxValue;
    }
    return parseFloat(value2);
  }
  return value2;
}
function calculateTextPosition(out, opts, rect) {
  var textPosition = opts.position || "inside";
  var distance = opts.distance != null ? opts.distance : 5;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var x3 = rect.x;
  var y3 = rect.y;
  var textAlign = "left";
  var textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x3 += parsePercent(textPosition[0], rect.width);
    y3 += parsePercent(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x3 -= distance;
        y3 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x3 += distance + width;
        y3 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x3 += width / 2;
        y3 -= distance;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x3 += width / 2;
        y3 += height + distance;
        textAlign = "center";
        break;
      case "inside":
        x3 += width / 2;
        y3 += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x3 += distance;
        y3 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x3 += width - distance;
        y3 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x3 += width / 2;
        y3 += distance;
        textAlign = "center";
        break;
      case "insideBottom":
        x3 += width / 2;
        y3 += height - distance;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x3 += distance;
        y3 += distance;
        break;
      case "insideTopRight":
        x3 += width - distance;
        y3 += distance;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x3 += distance;
        y3 += height - distance;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x3 += width - distance;
        y3 += height - distance;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out = out || {};
  out.x = x3;
  out.y = y3;
  out.align = textAlign;
  out.verticalAlign = textVerticalAlign;
  return out;
}

// node_modules/zrender/lib/graphic/helper/parseText.js
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText2(out, text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    out.text = "";
    out.isTruncated = false;
    return;
  }
  var textLines = (text + "").split(`
`);
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  var isTruncated = false;
  var truncateOut = {};
  for (var i3 = 0, len = textLines.length;i3 < len; i3++) {
    truncateSingleLine(truncateOut, textLines[i3], options);
    textLines[i3] = truncateOut.textLine;
    isTruncated = isTruncated || truncateOut.isTruncated;
  }
  out.text = textLines.join(`
`);
  out.isTruncated = isTruncated;
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  var preparedOpts = extend({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth("", font);
  var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i3 = 0;i3 < minChar && contentWidth >= ascCharWidth; i3++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(out, textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    out.textLine = "";
    out.isTruncated = false;
    return;
  }
  var lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    out.textLine = textLine;
    out.isTruncated = false;
    return;
  }
  for (var j3 = 0;; j3++) {
    if (lineWidth <= contentWidth || j3 >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j3 === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  out.textLine = textLine;
  out.isTruncated = true;
}
function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i3 = 0;
  for (var len = text.length;i3 < len && width < contentWidth; i3++) {
    var charCode = text.charCodeAt(i3);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i3;
}
function parsePlainText(text, style) {
  text != null && (text += "");
  var overflow = style.overflow;
  var padding = style.padding;
  var font = style.font;
  var truncate = overflow === "truncate";
  var calculatedLineHeight = getLineHeight(font);
  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  var bgColorDrawn = !!style.backgroundColor;
  var truncateLineOverflow = style.lineOverflow === "truncate";
  var isTruncated = false;
  var width = style.width;
  var lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text ? text.split(`
`) : [];
  }
  var contentHeight = lines.length * lineHeight;
  var height = retrieve2(style.height, contentHeight);
  if (contentHeight > height && truncateLineOverflow) {
    var lineCount = Math.floor(height / lineHeight);
    isTruncated = isTruncated || lines.length > lineCount;
    lines = lines.slice(0, lineCount);
  }
  if (text && truncate && width != null) {
    var options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    var singleOut = {};
    for (var i3 = 0;i3 < lines.length; i3++) {
      truncateSingleLine(singleOut, lines[i3], options);
      lines[i3] = singleOut.textLine;
      isTruncated = isTruncated || singleOut.isTruncated;
    }
  }
  var outerHeight = height;
  var contentWidth = 0;
  for (var i3 = 0;i3 < lines.length; i3++) {
    contentWidth = Math.max(getWidth(lines[i3], font), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  var outerWidth = contentWidth;
  if (padding) {
    outerHeight += padding[0] + padding[2];
    outerWidth += padding[1] + padding[3];
    width += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth = width;
  }
  return {
    lines,
    height,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width,
    isTruncated
  };
}
var RichTextToken = function() {
  function RichTextToken2() {}
  return RichTextToken2;
}();
var RichTextLine = function() {
  function RichTextLine2(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
  return RichTextLine2;
}();
var RichTextContentBlock = function() {
  function RichTextContentBlock2() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
    this.isTruncated = false;
  }
  return RichTextContentBlock2;
}();
function parseRichText(text, style) {
  var contentBlock = new RichTextContentBlock;
  text != null && (text += "");
  if (!text) {
    return contentBlock;
  }
  var topWidth = style.width;
  var topHeight = style.height;
  var overflow = style.overflow;
  var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
  }
  var pendingList = [];
  var calculatedHeight = 0;
  var calculatedWidth = 0;
  var stlPadding = style.padding;
  var truncate = overflow === "truncate";
  var truncateLine = style.lineOverflow === "truncate";
  var tmpTruncateOut = {};
  function finishLine(line2, lineWidth2, lineHeight2) {
    line2.width = lineWidth2;
    line2.lineHeight = lineHeight2;
    calculatedHeight += lineHeight2;
    calculatedWidth = Math.max(calculatedWidth, lineWidth2);
  }
  outer:
    for (var i3 = 0;i3 < contentBlock.lines.length; i3++) {
      var line = contentBlock.lines[i3];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j3 = 0;j3 < line.tokens.length; j3++) {
        var token = line.tokens[j3];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {};
        var textPadding = token.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || style.align;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          var originalLength = contentBlock.lines.length;
          if (j3 > 0) {
            line.tokens = line.tokens.slice(0, j3);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i3 + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i3);
          }
          contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = getWidth(token.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              truncateText2(tmpTruncateOut, token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token.text = tmpTruncateOut.text;
              contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;
              token.width = token.contentWidth = getWidth(token.text, font);
            }
          } else {
            token.contentWidth = getWidth(token.text, font);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i3 = 0;i3 < pendingList.length; i3++) {
    var token = pendingList[i3];
    var percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  var isEmptyStr = str === "";
  var tokenStyle = styleName && style.rich[styleName] || {};
  var lines = block.lines;
  var font = tokenStyle.font || style.font;
  var newLine = false;
  var strLines;
  var linesWidths;
  if (wrapInfo) {
    var tokenPadding = tokenStyle.padding;
    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split(`
`);
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth_1;
    } else {
      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split(`
`);
  }
  for (var i3 = 0;i3 < strLines.length; i3++) {
    var text = strLines[i3];
    var token = new RichTextToken;
    token.styleName = styleName;
    token.text = text;
    token.isLineHolder = !text && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i3] : getWidth(text, font);
    }
    if (!i3 && !newLine) {
      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine)).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isAlphabeticLetter(ch) {
  var code = ch.charCodeAt(0);
  return code >= 32 && code <= 591 || code >= 880 && code <= 4351 || code >= 4608 && code <= 5119 || code >= 7680 && code <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isAlphabeticLetter(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
  var lines = [];
  var linesWidths = [];
  var line = "";
  var currentWord = "";
  var currentWordWidth = 0;
  var accumWidth = 0;
  for (var i3 = 0;i3 < text.length; i3++) {
    var ch = text.charAt(i3);
    if (ch === `
`) {
      if (currentWord) {
        line += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line);
      linesWidths.push(accumWidth);
      line = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    var chWidth = getWidth(ch, font);
    var inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line || currentWord) {
        if (inWord) {
          if (!line) {
            line = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line);
          linesWidths.push(accumWidth);
          line = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line += ch;
    }
  }
  if (!lines.length && !line) {
    line = text;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line += currentWord;
  }
  if (line) {
    lines.push(line);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}

// node_modules/zrender/lib/core/vector.js
function create2(x3, y3) {
  if (x3 == null) {
    x3 = 0;
  }
  if (y3 == null) {
    y3 = 0;
  }
  return [x3, y3];
}
function clone2(v3) {
  return [v3[0], v3[1]];
}
function add(out, v1, v22) {
  out[0] = v1[0] + v22[0];
  out[1] = v1[1] + v22[1];
  return out;
}
function sub(out, v1, v22) {
  out[0] = v1[0] - v22[0];
  out[1] = v1[1] - v22[1];
  return out;
}
function len(v3) {
  return Math.sqrt(lenSquare(v3));
}
function lenSquare(v3) {
  return v3[0] * v3[0] + v3[1] * v3[1];
}
function scale2(out, v3, s3) {
  out[0] = v3[0] * s3;
  out[1] = v3[1] * s3;
  return out;
}
function normalize(out, v3) {
  var d3 = len(v3);
  if (d3 === 0) {
    out[0] = 0;
    out[1] = 0;
  } else {
    out[0] = v3[0] / d3;
    out[1] = v3[1] / d3;
  }
  return out;
}
function distance(v1, v22) {
  return Math.sqrt((v1[0] - v22[0]) * (v1[0] - v22[0]) + (v1[1] - v22[1]) * (v1[1] - v22[1]));
}
var dist = distance;
function distanceSquare(v1, v22) {
  return (v1[0] - v22[0]) * (v1[0] - v22[0]) + (v1[1] - v22[1]) * (v1[1] - v22[1]);
}
var distSquare = distanceSquare;
function lerp(out, v1, v22, t4) {
  out[0] = v1[0] + t4 * (v22[0] - v1[0]);
  out[1] = v1[1] + t4 * (v22[1] - v1[1]);
  return out;
}
function applyTransform(out, v3, m4) {
  var x3 = v3[0];
  var y3 = v3[1];
  out[0] = m4[0] * x3 + m4[2] * y3 + m4[4];
  out[1] = m4[1] * x3 + m4[3] * y3 + m4[5];
  return out;
}
function min(out, v1, v22) {
  out[0] = Math.min(v1[0], v22[0]);
  out[1] = Math.min(v1[1], v22[1]);
  return out;
}
function max(out, v1, v22) {
  out[0] = Math.max(v1[0], v22[0]);
  out[1] = Math.max(v1[1], v22[1]);
  return out;
}

// node_modules/zrender/lib/core/Transformable.js
var mIdentity = identity;
var EPSILON = 0.00005;
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create();
var abs = Math.abs;
var Transformable = function() {
  function Transformable2() {}
  Transformable2.prototype.getLocalTransform = function(m4) {
    return Transformable2.getLocalTransform(this, m4);
  };
  Transformable2.prototype.setPosition = function(arr) {
    this.x = arr[0];
    this.y = arr[1];
  };
  Transformable2.prototype.setScale = function(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  };
  Transformable2.prototype.setSkew = function(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  };
  Transformable2.prototype.setOrigin = function(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  };
  Transformable2.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  };
  Transformable2.prototype.updateTransform = function() {
    var parentTransform = this.parent && this.parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m4 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      if (m4) {
        mIdentity(m4);
        this.invTransform = null;
      }
      return;
    }
    m4 = m4 || create();
    if (needLocalTransform) {
      this.getLocalTransform(m4);
    } else {
      mIdentity(m4);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul(m4, parentTransform, m4);
      } else {
        copy(m4, parentTransform);
      }
    }
    this.transform = m4;
    this._resolveGlobalScaleRatio(m4);
  };
  Transformable2.prototype._resolveGlobalScaleRatio = function(m4) {
    var globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m4[0] *= sx;
      m4[1] *= sx;
      m4[2] *= sy;
      m4[3] *= sy;
    }
    this.invTransform = this.invTransform || create();
    invert(this.invTransform, m4);
  };
  Transformable2.prototype.getComputedTransform = function() {
    var transformNode = this;
    var ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  };
  Transformable2.prototype.setLocalTransform = function(m4) {
    if (!m4) {
      return;
    }
    var sx = m4[0] * m4[0] + m4[1] * m4[1];
    var sy = m4[2] * m4[2] + m4[3] * m4[3];
    var rotation = Math.atan2(m4[1], m4[0]);
    var shearX = Math.PI / 2 + rotation - Math.atan2(m4[3], m4[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m4[4];
    this.y = +m4[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  };
  Transformable2.prototype.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent = this.parent;
    var m4 = this.transform;
    if (parent && parent.transform) {
      parent.invTransform = parent.invTransform || create();
      mul(tmpTransform, parent.invTransform, m4);
      m4 = tmpTransform;
    }
    var ox = this.originX;
    var oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul(tmpTransform, m4, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m4 = tmpTransform;
    }
    this.setLocalTransform(m4);
  };
  Transformable2.prototype.getGlobalScale = function(out) {
    var m4 = this.transform;
    out = out || [];
    if (!m4) {
      out[0] = 1;
      out[1] = 1;
      return out;
    }
    out[0] = Math.sqrt(m4[0] * m4[0] + m4[1] * m4[1]);
    out[1] = Math.sqrt(m4[2] * m4[2] + m4[3] * m4[3]);
    if (m4[0] < 0) {
      out[0] = -out[0];
    }
    if (m4[3] < 0) {
      out[1] = -out[1];
    }
    return out;
  };
  Transformable2.prototype.transformCoordToLocal = function(x3, y3) {
    var v22 = [x3, y3];
    var invTransform = this.invTransform;
    if (invTransform) {
      applyTransform(v22, v22, invTransform);
    }
    return v22;
  };
  Transformable2.prototype.transformCoordToGlobal = function(x3, y3) {
    var v22 = [x3, y3];
    var transform = this.transform;
    if (transform) {
      applyTransform(v22, v22, transform);
    }
    return v22;
  };
  Transformable2.prototype.getLineScale = function() {
    var m4 = this.transform;
    return m4 && abs(m4[0] - 1) > 0.0000000001 && abs(m4[3] - 1) > 0.0000000001 ? Math.sqrt(abs(m4[0] * m4[3] - m4[2] * m4[1])) : 1;
  };
  Transformable2.prototype.copyTransform = function(source) {
    copyTransform(this, source);
  };
  Transformable2.getLocalTransform = function(target, m4) {
    m4 = m4 || [];
    var ox = target.originX || 0;
    var oy = target.originY || 0;
    var sx = target.scaleX;
    var sy = target.scaleY;
    var ax = target.anchorX;
    var ay = target.anchorY;
    var rotation = target.rotation || 0;
    var x3 = target.x;
    var y3 = target.y;
    var skewX = target.skewX ? Math.tan(target.skewX) : 0;
    var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      var dx = ox + ax;
      var dy = oy + ay;
      m4[4] = -dx * sx - skewX * dy * sy;
      m4[5] = -dy * sy - skewY * dx * sx;
    } else {
      m4[4] = m4[5] = 0;
    }
    m4[0] = sx;
    m4[3] = sy;
    m4[1] = skewY * sx;
    m4[2] = skewX * sy;
    rotation && rotate(m4, m4, rotation);
    m4[4] += ox + x3;
    m4[5] += oy + y3;
    return m4;
  };
  Transformable2.initDefaultProps = function() {
    var proto = Transformable2.prototype;
    proto.scaleX = proto.scaleY = proto.globalScaleRatio = 1;
    proto.x = proto.y = proto.originX = proto.originY = proto.skewX = proto.skewY = proto.rotation = proto.anchorX = proto.anchorY = 0;
  }();
  return Transformable2;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (var i3 = 0;i3 < TRANSFORMABLE_PROPS.length; i3++) {
    var propName = TRANSFORMABLE_PROPS[i3];
    target[propName] = source[propName];
  }
}
var Transformable_default = Transformable;

// node_modules/zrender/lib/animation/easing.js
var easingFuncs = {
  linear: function(k3) {
    return k3;
  },
  quadraticIn: function(k3) {
    return k3 * k3;
  },
  quadraticOut: function(k3) {
    return k3 * (2 - k3);
  },
  quadraticInOut: function(k3) {
    if ((k3 *= 2) < 1) {
      return 0.5 * k3 * k3;
    }
    return -0.5 * (--k3 * (k3 - 2) - 1);
  },
  cubicIn: function(k3) {
    return k3 * k3 * k3;
  },
  cubicOut: function(k3) {
    return --k3 * k3 * k3 + 1;
  },
  cubicInOut: function(k3) {
    if ((k3 *= 2) < 1) {
      return 0.5 * k3 * k3 * k3;
    }
    return 0.5 * ((k3 -= 2) * k3 * k3 + 2);
  },
  quarticIn: function(k3) {
    return k3 * k3 * k3 * k3;
  },
  quarticOut: function(k3) {
    return 1 - --k3 * k3 * k3 * k3;
  },
  quarticInOut: function(k3) {
    if ((k3 *= 2) < 1) {
      return 0.5 * k3 * k3 * k3 * k3;
    }
    return -0.5 * ((k3 -= 2) * k3 * k3 * k3 - 2);
  },
  quinticIn: function(k3) {
    return k3 * k3 * k3 * k3 * k3;
  },
  quinticOut: function(k3) {
    return --k3 * k3 * k3 * k3 * k3 + 1;
  },
  quinticInOut: function(k3) {
    if ((k3 *= 2) < 1) {
      return 0.5 * k3 * k3 * k3 * k3 * k3;
    }
    return 0.5 * ((k3 -= 2) * k3 * k3 * k3 * k3 + 2);
  },
  sinusoidalIn: function(k3) {
    return 1 - Math.cos(k3 * Math.PI / 2);
  },
  sinusoidalOut: function(k3) {
    return Math.sin(k3 * Math.PI / 2);
  },
  sinusoidalInOut: function(k3) {
    return 0.5 * (1 - Math.cos(Math.PI * k3));
  },
  exponentialIn: function(k3) {
    return k3 === 0 ? 0 : Math.pow(1024, k3 - 1);
  },
  exponentialOut: function(k3) {
    return k3 === 1 ? 1 : 1 - Math.pow(2, -10 * k3);
  },
  exponentialInOut: function(k3) {
    if (k3 === 0) {
      return 0;
    }
    if (k3 === 1) {
      return 1;
    }
    if ((k3 *= 2) < 1) {
      return 0.5 * Math.pow(1024, k3 - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k3 - 1)) + 2);
  },
  circularIn: function(k3) {
    return 1 - Math.sqrt(1 - k3 * k3);
  },
  circularOut: function(k3) {
    return Math.sqrt(1 - --k3 * k3);
  },
  circularInOut: function(k3) {
    if ((k3 *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k3 * k3) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k3 -= 2) * k3) + 1);
  },
  elasticIn: function(k3) {
    var s3;
    var a3 = 0.1;
    var p3 = 0.4;
    if (k3 === 0) {
      return 0;
    }
    if (k3 === 1) {
      return 1;
    }
    if (!a3 || a3 < 1) {
      a3 = 1;
      s3 = p3 / 4;
    } else {
      s3 = p3 * Math.asin(1 / a3) / (2 * Math.PI);
    }
    return -(a3 * Math.pow(2, 10 * (k3 -= 1)) * Math.sin((k3 - s3) * (2 * Math.PI) / p3));
  },
  elasticOut: function(k3) {
    var s3;
    var a3 = 0.1;
    var p3 = 0.4;
    if (k3 === 0) {
      return 0;
    }
    if (k3 === 1) {
      return 1;
    }
    if (!a3 || a3 < 1) {
      a3 = 1;
      s3 = p3 / 4;
    } else {
      s3 = p3 * Math.asin(1 / a3) / (2 * Math.PI);
    }
    return a3 * Math.pow(2, -10 * k3) * Math.sin((k3 - s3) * (2 * Math.PI) / p3) + 1;
  },
  elasticInOut: function(k3) {
    var s3;
    var a3 = 0.1;
    var p3 = 0.4;
    if (k3 === 0) {
      return 0;
    }
    if (k3 === 1) {
      return 1;
    }
    if (!a3 || a3 < 1) {
      a3 = 1;
      s3 = p3 / 4;
    } else {
      s3 = p3 * Math.asin(1 / a3) / (2 * Math.PI);
    }
    if ((k3 *= 2) < 1) {
      return -0.5 * (a3 * Math.pow(2, 10 * (k3 -= 1)) * Math.sin((k3 - s3) * (2 * Math.PI) / p3));
    }
    return a3 * Math.pow(2, -10 * (k3 -= 1)) * Math.sin((k3 - s3) * (2 * Math.PI) / p3) * 0.5 + 1;
  },
  backIn: function(k3) {
    var s3 = 1.70158;
    return k3 * k3 * ((s3 + 1) * k3 - s3);
  },
  backOut: function(k3) {
    var s3 = 1.70158;
    return --k3 * k3 * ((s3 + 1) * k3 + s3) + 1;
  },
  backInOut: function(k3) {
    var s3 = 1.70158 * 1.525;
    if ((k3 *= 2) < 1) {
      return 0.5 * (k3 * k3 * ((s3 + 1) * k3 - s3));
    }
    return 0.5 * ((k3 -= 2) * k3 * ((s3 + 1) * k3 + s3) + 2);
  },
  bounceIn: function(k3) {
    return 1 - easingFuncs.bounceOut(1 - k3);
  },
  bounceOut: function(k3) {
    if (k3 < 1 / 2.75) {
      return 7.5625 * k3 * k3;
    } else if (k3 < 2 / 2.75) {
      return 7.5625 * (k3 -= 1.5 / 2.75) * k3 + 0.75;
    } else if (k3 < 2.5 / 2.75) {
      return 7.5625 * (k3 -= 2.25 / 2.75) * k3 + 0.9375;
    } else {
      return 7.5625 * (k3 -= 2.625 / 2.75) * k3 + 0.984375;
    }
  },
  bounceInOut: function(k3) {
    if (k3 < 0.5) {
      return easingFuncs.bounceIn(k3 * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k3 * 2 - 1) * 0.5 + 0.5;
  }
};
var easing_default = easingFuncs;

// node_modules/zrender/lib/core/curve.js
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON2 = 0.00000001;
var EPSILON_NUMERIC = 0.0001;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3;
var _v0 = create2();
var _v1 = create2();
var _v2 = create2();
function isAroundZero(val) {
  return val > -EPSILON2 && val < EPSILON2;
}
function isNotAroundZero2(val) {
  return val > EPSILON2 || val < -EPSILON2;
}
function cubicAt(p0, p1, p22, p3, t4) {
  var onet = 1 - t4;
  return onet * onet * (onet * p0 + 3 * t4 * p1) + t4 * t4 * (t4 * p3 + 3 * onet * p22);
}
function cubicDerivativeAt(p0, p1, p22, p3, t4) {
  var onet = 1 - t4;
  return 3 * (((p1 - p0) * onet + 2 * (p22 - p1) * t4) * onet + (p3 - p22) * t4 * t4);
}
function cubicRootAt(p0, p1, p22, p3, val, roots) {
  var a3 = p3 + 3 * (p1 - p22) - p0;
  var b = 3 * (p22 - p1 * 2 + p0);
  var c3 = 3 * (p1 - p0);
  var d3 = p0 - val;
  var A3 = b * b - 3 * a3 * c3;
  var B3 = b * c3 - 9 * a3 * d3;
  var C3 = c3 * c3 - 3 * b * d3;
  var n3 = 0;
  if (isAroundZero(A3) && isAroundZero(B3)) {
    if (isAroundZero(b)) {
      roots[0] = 0;
    } else {
      var t1 = -c3 / b;
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
    }
  } else {
    var disc = B3 * B3 - 4 * A3 * C3;
    if (isAroundZero(disc)) {
      var K = B3 / A3;
      var t1 = -b / a3 + K;
      var t22 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
      if (t22 >= 0 && t22 <= 1) {
        roots[n3++] = t22;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var Y1 = A3 * b + 1.5 * a3 * (-B3 + discSqrt);
      var Y2 = A3 * b + 1.5 * a3 * (-B3 - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }
      var t1 = (-b - (Y1 + Y2)) / (3 * a3);
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
    } else {
      var T3 = (2 * A3 * b - 3 * a3 * B3) / (2 * mathSqrt(A3 * A3 * A3));
      var theta = Math.acos(T3) / 3;
      var ASqrt = mathSqrt(A3);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a3);
      var t22 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a3);
      var t32 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a3);
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
      if (t22 >= 0 && t22 <= 1) {
        roots[n3++] = t22;
      }
      if (t32 >= 0 && t32 <= 1) {
        roots[n3++] = t32;
      }
    }
  }
  return n3;
}
function cubicExtrema(p0, p1, p22, p3, extrema) {
  var b = 6 * p22 - 12 * p1 + 6 * p0;
  var a3 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p22;
  var c3 = 3 * p1 - 3 * p0;
  var n3 = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero2(b)) {
      var t1 = -c3 / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema[n3++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc)) {
      extrema[0] = -b / (2 * a3);
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a3);
      var t22 = (-b - discSqrt) / (2 * a3);
      if (t1 >= 0 && t1 <= 1) {
        extrema[n3++] = t1;
      }
      if (t22 >= 0 && t22 <= 1) {
        extrema[n3++] = t22;
      }
    }
  }
  return n3;
}
function cubicSubdivide(p0, p1, p22, p3, t4, out) {
  var p01 = (p1 - p0) * t4 + p0;
  var p12 = (p22 - p1) * t4 + p1;
  var p23 = (p3 - p22) * t4 + p22;
  var p012 = (p12 - p01) * t4 + p01;
  var p123 = (p23 - p12) * t4 + p12;
  var p0123 = (p123 - p012) * t4 + p012;
  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123;
  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x22, y22, x3, y3, x4, y4, out) {
  var t4;
  var interval = 0.005;
  var d3 = Infinity;
  var prev;
  var next;
  var d1;
  var d22;
  _v0[0] = x4;
  _v0[1] = y4;
  for (var _t = 0;_t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x22, x3, _t);
    _v1[1] = cubicAt(y0, y1, y22, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d3) {
      t4 = _t;
      d3 = d1;
    }
  }
  d3 = Infinity;
  for (var i3 = 0;i3 < 32; i3++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t4 - interval;
    next = t4 + interval;
    _v1[0] = cubicAt(x0, x1, x22, x3, prev);
    _v1[1] = cubicAt(y0, y1, y22, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d3) {
      t4 = prev;
      d3 = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x22, x3, next);
      _v2[1] = cubicAt(y0, y1, y22, y3, next);
      d22 = distSquare(_v2, _v0);
      if (next <= 1 && d22 < d3) {
        t4 = next;
        d3 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out) {
    out[0] = cubicAt(x0, x1, x22, x3, t4);
    out[1] = cubicAt(y0, y1, y22, y3, t4);
  }
  return mathSqrt(d3);
}
function cubicLength(x0, y0, x1, y1, x22, y22, x3, y3, iteration) {
  var px = x0;
  var py = y0;
  var d3 = 0;
  var step = 1 / iteration;
  for (var i3 = 1;i3 <= iteration; i3++) {
    var t4 = i3 * step;
    var x4 = cubicAt(x0, x1, x22, x3, t4);
    var y4 = cubicAt(y0, y1, y22, y3, t4);
    var dx = x4 - px;
    var dy = y4 - py;
    d3 += Math.sqrt(dx * dx + dy * dy);
    px = x4;
    py = y4;
  }
  return d3;
}
function quadraticAt(p0, p1, p22, t4) {
  var onet = 1 - t4;
  return onet * (onet * p0 + 2 * t4 * p1) + t4 * t4 * p22;
}
function quadraticDerivativeAt(p0, p1, p22, t4) {
  return 2 * ((1 - t4) * (p1 - p0) + t4 * (p22 - p1));
}
function quadraticRootAt(p0, p1, p22, val, roots) {
  var a3 = p0 - 2 * p1 + p22;
  var b = 2 * (p1 - p0);
  var c3 = p0 - val;
  var n3 = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero2(b)) {
      var t1 = -c3 / b;
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a3);
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a3);
      var t22 = (-b - discSqrt) / (2 * a3);
      if (t1 >= 0 && t1 <= 1) {
        roots[n3++] = t1;
      }
      if (t22 >= 0 && t22 <= 1) {
        roots[n3++] = t22;
      }
    }
  }
  return n3;
}
function quadraticExtremum(p0, p1, p22) {
  var divider = p0 + p22 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p22, t4, out) {
  var p01 = (p1 - p0) * t4 + p0;
  var p12 = (p22 - p1) * t4 + p1;
  var p012 = (p12 - p01) * t4 + p01;
  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p012;
  out[4] = p12;
  out[5] = p22;
}
function quadraticProjectPoint(x0, y0, x1, y1, x22, y22, x3, y3, out) {
  var t4;
  var interval = 0.005;
  var d3 = Infinity;
  _v0[0] = x3;
  _v0[1] = y3;
  for (var _t = 0;_t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x22, _t);
    _v1[1] = quadraticAt(y0, y1, y22, _t);
    var d1 = distSquare(_v0, _v1);
    if (d1 < d3) {
      t4 = _t;
      d3 = d1;
    }
  }
  d3 = Infinity;
  for (var i3 = 0;i3 < 32; i3++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev = t4 - interval;
    var next = t4 + interval;
    _v1[0] = quadraticAt(x0, x1, x22, prev);
    _v1[1] = quadraticAt(y0, y1, y22, prev);
    var d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d3) {
      t4 = prev;
      d3 = d1;
    } else {
      _v2[0] = quadraticAt(x0, x1, x22, next);
      _v2[1] = quadraticAt(y0, y1, y22, next);
      var d22 = distSquare(_v2, _v0);
      if (next <= 1 && d22 < d3) {
        t4 = next;
        d3 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out) {
    out[0] = quadraticAt(x0, x1, x22, t4);
    out[1] = quadraticAt(y0, y1, y22, t4);
  }
  return mathSqrt(d3);
}
function quadraticLength(x0, y0, x1, y1, x22, y22, iteration) {
  var px = x0;
  var py = y0;
  var d3 = 0;
  var step = 1 / iteration;
  for (var i3 = 1;i3 <= iteration; i3++) {
    var t4 = i3 * step;
    var x3 = quadraticAt(x0, x1, x22, t4);
    var y3 = quadraticAt(y0, y1, y22, t4);
    var dx = x3 - px;
    var dy = y3 - py;
    d3 += Math.sqrt(dx * dx + dy * dy);
    px = x3;
    py = y3;
  }
  return d3;
}

// node_modules/zrender/lib/animation/cubicEasing.js
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic) {
    var points = cubic[1].split(",");
    var a_1 = +trim(points[0]);
    var b_1 = +trim(points[1]);
    var c_1 = +trim(points[2]);
    var d_1 = +trim(points[3]);
    if (isNaN(a_1 + b_1 + c_1 + d_1)) {
      return;
    }
    var roots_1 = [];
    return function(p3) {
      return p3 <= 0 ? 0 : p3 >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p3, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
    };
  }
}

// node_modules/zrender/lib/animation/Clip.js
var Clip = function() {
  function Clip2(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1000;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop;
    this.ondestroy = opts.ondestroy || noop;
    this.onrestart = opts.onrestart || noop;
    opts.easing && this.setEasing(opts.easing);
  }
  Clip2.prototype.step = function(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var life = this._life;
    var elapsedTime = globalTime - this._startTime - this._pausedTime;
    var percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    var easingFunc = this.easingFunc;
    var schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        var remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  };
  Clip2.prototype.pause = function() {
    this._paused = true;
  };
  Clip2.prototype.resume = function() {
    this._paused = false;
  };
  Clip2.prototype.setEasing = function(easing) {
    this.easing = easing;
    this.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
  };
  return Clip2;
}();
var Clip_default = Clip;

// node_modules/zrender/lib/tool/color.js
var kCSSColorTable = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function clampCssByte(i3) {
  i3 = Math.round(i3);
  return i3 < 0 ? 0 : i3 > 255 ? 255 : i3;
}
function clampCssFloat(f3) {
  return f3 < 0 ? 0 : f3 > 1 ? 1 : f3;
}
function parseCssInt(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m22, h3) {
  if (h3 < 0) {
    h3 += 1;
  } else if (h3 > 1) {
    h3 -= 1;
  }
  if (h3 * 6 < 1) {
    return m1 + (m22 - m1) * h3 * 6;
  }
  if (h3 * 2 < 1) {
    return m22;
  }
  if (h3 * 3 < 2) {
    return m1 + (m22 - m1) * (2 / 3 - h3) * 6;
  }
  return m1;
}
function lerpNumber(a3, b, p3) {
  return a3 + (b - a3) * p3;
}
function setRgba(out, r3, g2, b, a3) {
  out[0] = r3;
  out[1] = g2;
  out[2] = b;
  out[3] = a3;
  return out;
}
function copyRgba(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
var colorCache = new LRU_default(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse2(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  var strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      var iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      var iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("(");
  var ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length >= 3) {
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  var h3 = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s3 = parseCssFloat(hsla[1]);
  var l3 = parseCssFloat(hsla[2]);
  var m22 = l3 <= 0.5 ? l3 * (s3 + 1) : l3 + s3 - l3 * s3;
  var m1 = l3 * 2 - m22;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m22, h3 + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m22, h3) * 255), clampCssByte(cssHueToRgb(m1, m22, h3 - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function lift(color, level) {
  var colorArr = parse2(color);
  if (colorArr) {
    for (var i3 = 0;i3 < 3; i3++) {
      if (level < 0) {
        colorArr[i3] = colorArr[i3] * (1 - level) | 0;
      } else {
        colorArr[i3] = (255 - colorArr[i3]) * level + colorArr[i3] | 0;
      }
      if (colorArr[i3] > 255) {
        colorArr[i3] = 255;
      } else if (colorArr[i3] < 0) {
        colorArr[i3] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function lerp2(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value2 = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value2);
  var rightIndex = Math.ceil(value2);
  var leftColor = parse2(colors[leftIndex]);
  var rightColor = parse2(colors[rightIndex]);
  var dv = value2 - leftIndex;
  var color = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color,
    leftIndex,
    rightIndex,
    value: value2
  } : color;
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color, backgroundLum) {
  var arr = parse2(color);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
var liftedColorCache = new LRU_default(100);
function liftColor(color) {
  if (isString(color)) {
    var liftedColor = liftedColorCache.get(color);
    if (!liftedColor) {
      liftedColor = lift(color, -0.1);
      liftedColorCache.put(color, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color)) {
    var ret = extend({}, color);
    ret.colorStops = map(color.colorStops, function(stop) {
      return {
        offset: stop.offset,
        color: lift(stop.color, -0.1)
      };
    });
    return ret;
  }
  return color;
}

// node_modules/zrender/lib/svg/helper.js
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
var encodeBase64 = function() {
  if (env_default.hasGlobalWindow && isFunction(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    if (true) {
      logError("Base64 isn't natively supported in the current environment.");
    }
    return null;
  };
}();

// node_modules/zrender/lib/animation/Animator.js
var arraySlice = Array.prototype.slice;
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out, p0, p1, percent) {
  var len2 = p0.length;
  for (var i3 = 0;i3 < len2; i3++) {
    out[i3] = interpolateNumber(p0[i3], p1[i3], percent);
  }
  return out;
}
function interpolate2DArray(out, p0, p1, percent) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i3 = 0;i3 < len2; i3++) {
    if (!out[i3]) {
      out[i3] = [];
    }
    for (var j3 = 0;j3 < len22; j3++) {
      out[i3][j3] = interpolateNumber(p0[i3][j3], p1[i3][j3], percent);
    }
  }
  return out;
}
function add1DArray(out, p0, p1, sign) {
  var len2 = p0.length;
  for (var i3 = 0;i3 < len2; i3++) {
    out[i3] = p0[i3] + p1[i3] * sign;
  }
  return out;
}
function add2DArray(out, p0, p1, sign) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i3 = 0;i3 < len2; i3++) {
    if (!out[i3]) {
      out[i3] = [];
    }
    for (var j3 = 0;j3 < len22; j3++) {
      out[i3][j3] = p0[i3][j3] + p1[i3][j3] * sign;
    }
  }
  return out;
}
function fillColorStops(val0, val1) {
  var len0 = val0.length;
  var len1 = val1.length;
  var shorterArr = len0 > len1 ? val1 : val0;
  var shorterLen = Math.min(len0, len1);
  var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
  for (var i3 = shorterLen;i3 < Math.max(len0, len1); i3++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  var arr0 = val0;
  var arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i3 = arr0Len;i3 < arr1Len; i3++) {
        arr0.push(arrDim === 1 ? arr1[i3] : arraySlice.call(arr1[i3]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i3 = 0;i3 < arr0.length; i3++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i3])) {
        arr0[i3] = arr1[i3];
      }
    } else {
      for (var j3 = 0;j3 < len2; j3++) {
        if (isNaN(arr0[i3][j3])) {
          arr0[i3][j3] = arr1[i3][j3];
        }
      }
    }
  }
}
function cloneValue(value2) {
  if (isArrayLike(value2)) {
    var len2 = value2.length;
    if (isArrayLike(value2[0])) {
      var ret = [];
      for (var i3 = 0;i3 < len2; i3++) {
        ret.push(arraySlice.call(value2[i3]));
      }
      return ret;
    }
    return arraySlice.call(value2);
  }
  return value2;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value2) {
  return isArrayLike(value2 && value2[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = function() {
  function Track2(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  Track2.prototype.isFinished = function() {
    return this._finished;
  };
  Track2.prototype.setFinished = function() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  };
  Track2.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  };
  Track2.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  };
  Track2.prototype.addKeyframe = function(time, rawValue, easing) {
    this._needsSort = true;
    var keyframes = this.keyframes;
    var len2 = keyframes.length;
    var discrete = false;
    var valType = VALUE_TYPE_UNKOWN;
    var value2 = rawValue;
    if (isArrayLike(rawValue)) {
      var arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          var colorArray = parse2(rawValue);
          if (colorArray) {
            value2 = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        var parsedGradient = extend({}, value2);
        parsedGradient.colorStops = map(rawValue.colorStops, function(colorStop) {
          return {
            offset: colorStop.offset,
            color: parse2(colorStop.color)
          };
        });
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value2 = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    var kf = {
      time,
      value: value2,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  };
  Track2.prototype.prepare = function(maxTime, additiveTrack) {
    var kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a3, b) {
        return a3.time - b.time;
      });
    }
    var valType = this.valType;
    var kfsLen = kfs.length;
    var lastKf = kfs[kfsLen - 1];
    var isDiscrete = this.discrete;
    var isArr = isArrayValueType(valType);
    var isGradient = isGradientValueType(valType);
    for (var i3 = 0;i3 < kfsLen; i3++) {
      var kf = kfs[i3];
      var value2 = kf.value;
      var lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i3 !== kfsLen - 1) {
          fillArray(value2, lastValue, valType);
        } else if (isGradient) {
          fillColorStops(value2.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      var startValue = kfs[0].value;
      for (var i3 = 0;i3 < kfsLen; i3++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i3].additiveValue = kfs[i3].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i3].additiveValue = add1DArray([], kfs[i3].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i3].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i3].value, startValue, -1) : add2DArray([], kfs[i3].value, startValue, -1);
        }
      }
    }
  };
  Track2.prototype.step = function(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    var isAdditive = this._additiveTrack != null;
    var valueKey = isAdditive ? "additiveValue" : "value";
    var valType = this.valType;
    var keyframes = this.keyframes;
    var kfsNum = keyframes.length;
    var propName = this.propName;
    var isValueColor = valType === VALUE_TYPE_COLOR;
    var frameIdx;
    var lastFrame = this._lastFr;
    var mathMin2 = Math.min;
    var frame;
    var nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        var start = mathMin2(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start;frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame;frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    var interval = nextFrame.percent - frame.percent;
    var w3 = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w3 = nextFrame.easingFunc(w3);
    }
    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w3 < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w3) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w3);
    } else if (isGradientValueType(valType)) {
      var val = frame[valueKey];
      var nextVal_1 = nextFrame[valueKey];
      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient_1 ? "linear" : "radial",
        x: interpolateNumber(val.x, nextVal_1.x, w3),
        y: interpolateNumber(val.y, nextVal_1.y, w3),
        colorStops: map(val.colorStops, function(colorStop, idx) {
          var nextColorStop = nextVal_1.colorStops[idx];
          return {
            offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w3),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w3))
          };
        }),
        global: nextVal_1.global
      };
      if (isLinearGradient_1) {
        target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w3);
        target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w3);
      } else {
        target[propName].r = interpolateNumber(val.r, nextVal_1.r, w3);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w3);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      var value2 = interpolateNumber(frame[valueKey], nextFrame[valueKey], w3);
      if (isAdditive) {
        this._additiveValue = value2;
      } else {
        target[propName] = value2;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  };
  Track2.prototype._addToTarget = function(target) {
    var valType = this.valType;
    var propName = this.propName;
    var additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse2(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  };
  return Track2;
}();
var Animator = function() {
  function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  Animator2.prototype.getMaxTime = function() {
    return this._maxTime;
  };
  Animator2.prototype.getDelay = function() {
    return this._delay;
  };
  Animator2.prototype.getLoop = function() {
    return this._loop;
  };
  Animator2.prototype.getTarget = function() {
    return this._target;
  };
  Animator2.prototype.changeTarget = function(target) {
    this._target = target;
  };
  Animator2.prototype.when = function(time, props, easing) {
    return this.whenWithKeys(time, props, keys(props), easing);
  };
  Animator2.prototype.whenWithKeys = function(time, props, propNames, easing) {
    var tracks = this._tracks;
    for (var i3 = 0;i3 < propNames.length; i3++) {
      var propName = propNames[i3];
      var track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        var initialValue = undefined;
        var additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          var addtiveTrackKfs = additiveTrack.keyframes;
          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time);
    return this;
  };
  Animator2.prototype.pause = function() {
    this._clip.pause();
    this._paused = true;
  };
  Animator2.prototype.resume = function() {
    this._clip.resume();
    this._paused = false;
  };
  Animator2.prototype.isPaused = function() {
    return !!this._paused;
  };
  Animator2.prototype.duration = function(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  };
  Animator2.prototype._doneCallback = function() {
    this._setTracksFinished();
    this._clip = null;
    var doneList = this._doneCbs;
    if (doneList) {
      var len2 = doneList.length;
      for (var i3 = 0;i3 < len2; i3++) {
        doneList[i3].call(this);
      }
    }
  };
  Animator2.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var animation = this.animation;
    var abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (var i3 = 0;i3 < abortedList.length; i3++) {
        abortedList[i3].call(this);
      }
    }
  };
  Animator2.prototype._setTracksFinished = function() {
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i3 = 0;i3 < tracksKeys.length; i3++) {
      tracks[tracksKeys[i3]].setFinished();
    }
  };
  Animator2.prototype._getAdditiveTrack = function(trackName) {
    var additiveTrack;
    var additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (var i3 = 0;i3 < additiveAnimators.length; i3++) {
        var track = additiveAnimators[i3].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  };
  Animator2.prototype.start = function(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    var self2 = this;
    var tracks = [];
    var maxTime = this._maxTime || 0;
    for (var i3 = 0;i3 < this._trackKeys.length; i3++) {
      var propName = this._trackKeys[i3];
      var track = this._tracks[propName];
      var additiveTrack = this._getAdditiveTrack(propName);
      var kfs = track.keyframes;
      var kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          var lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      var clip = new Clip_default({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe: function(percent) {
          self2._started = 2;
          var additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            var stillHasAdditiveAnimator = false;
            for (var i4 = 0;i4 < additiveAnimators.length; i4++) {
              if (additiveAnimators[i4]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (var i4 = 0;i4 < tracks.length; i4++) {
            tracks[i4].step(self2._target, percent);
          }
          var onframeList = self2._onframeCbs;
          if (onframeList) {
            for (var i4 = 0;i4 < onframeList.length; i4++) {
              onframeList[i4](self2._target, percent);
            }
          }
        },
        ondestroy: function() {
          self2._doneCallback();
        }
      });
      this._clip = clip;
      if (this.animation) {
        this.animation.addClip(clip);
      }
      if (easing) {
        clip.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  };
  Animator2.prototype.stop = function(forwardToLast) {
    if (!this._clip) {
      return;
    }
    var clip = this._clip;
    if (forwardToLast) {
      clip.onframe(1);
    }
    this._abortedCallback();
  };
  Animator2.prototype.delay = function(time) {
    this._delay = time;
    return this;
  };
  Animator2.prototype.during = function(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.done = function(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.aborted = function(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.getClip = function() {
    return this._clip;
  };
  Animator2.prototype.getTrack = function(propName) {
    return this._tracks[propName];
  };
  Animator2.prototype.getTracks = function() {
    var _this = this;
    return map(this._trackKeys, function(key) {
      return _this._tracks[key];
    });
  };
  Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i3 = 0;i3 < propNames.length; i3++) {
      var track = tracks[propNames[i3]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    var allAborted = true;
    for (var i3 = 0;i3 < tracksKeys.length; i3++) {
      if (!tracks[tracksKeys[i3]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  };
  Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (var i3 = 0;i3 < trackKeys.length; i3++) {
      var propName = trackKeys[i3];
      var track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      var kfs = track.keyframes;
      var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  };
  Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
    trackKeys = trackKeys || keys(finalProps);
    for (var i3 = 0;i3 < trackKeys.length; i3++) {
      var propName = trackKeys[i3];
      var track = this._tracks[propName];
      if (!track) {
        continue;
      }
      var kfs = track.keyframes;
      if (kfs.length > 1) {
        var lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  };
  return Animator2;
}();
var Animator_default = Animator;

// node_modules/zrender/lib/core/Eventful.js
var Eventful = function() {
  function Eventful2(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  Eventful2.prototype.on = function(event, query, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    var _h = this._$handlers;
    if (typeof query === "function") {
      context = handler;
      handler = query;
      query = null;
    }
    if (!handler || !event) {
      return this;
    }
    var eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (var i3 = 0;i3 < _h[event].length; i3++) {
      if (_h[event][i3].h === handler) {
        return this;
      }
    }
    var wrap = {
      h: handler,
      query,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    var lastIndex = _h[event].length - 1;
    var lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return this;
  };
  Eventful2.prototype.isSilent = function(eventName) {
    var _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  };
  Eventful2.prototype.off = function(eventType, handler) {
    var _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        var newList = [];
        for (var i3 = 0, l3 = _h[eventType].length;i3 < l3; i3++) {
          if (_h[eventType][i3].h !== handler) {
            newList.push(_h[eventType][i3]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  };
  Eventful2.prototype.trigger = function(eventType) {
    var args = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[eventType];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var len2 = _h.length;
      for (var i3 = 0;i3 < len2; i3++) {
        var hItem = _h[i3];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  };
  Eventful2.prototype.triggerWithContext = function(type) {
    var args = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var ctx = args[argLen - 1];
      var len2 = _h.length;
      for (var i3 = 0;i3 < len2; i3++) {
        var hItem = _h[i3];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  };
  return Eventful2;
}();
var Eventful_default = Eventful;

// node_modules/zrender/lib/config.js
var dpr = 1;
if (env_default.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";

// node_modules/zrender/lib/graphic/constants.js
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;

// node_modules/zrender/lib/Element.js
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = true;
  return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0);
var Element = function() {
  function Element2(props) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  Element2.prototype._init = function(props) {
    this.attr(props);
  };
  Element2.prototype.drift = function(dx, dy, e3) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m4 = this.transform;
    if (!m4) {
      m4 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m4[4] += dx;
    m4[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  };
  Element2.prototype.beforeUpdate = function() {};
  Element2.prototype.afterUpdate = function() {};
  Element2.prototype.update = function() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  };
  Element2.prototype.updateInnerText = function(forceUpdate) {
    var textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      var textConfig = this.textConfig;
      var isLocal = textConfig.local;
      var innerTransformable = textEl.innerTransformable;
      var textAlign = undefined;
      var textVerticalAlign = undefined;
      var textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      var innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        var layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        var textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          var relOriginX = undefined;
          var relOriginY = undefined;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      var textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      var textFill = undefined;
      var textStroke = undefined;
      var autoStroke = undefined;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  };
  Element2.prototype.canBeInsideText = function() {
    return true;
  };
  Element2.prototype.getInsideTextFill = function() {
    return "#fff";
  };
  Element2.prototype.getInsideTextStroke = function(textFill) {
    return "#000";
  };
  Element2.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  };
  Element2.prototype.getOutsideStroke = function(textFill) {
    var backgroundColor = this.__zr && this.__zr.getBackgroundColor();
    var colorArr = typeof backgroundColor === "string" && parse2(backgroundColor);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    var alpha = colorArr[3];
    var isDark = this.__zr.isDarkMode();
    for (var i3 = 0;i3 < 3; i3++) {
      colorArr[i3] = colorArr[i3] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  };
  Element2.prototype.traverse = function(cb, context) {};
  Element2.prototype.attrKV = function(key, value2) {
    if (key === "textConfig") {
      this.setTextConfig(value2);
    } else if (key === "textContent") {
      this.setTextContent(value2);
    } else if (key === "clipPath") {
      this.setClipPath(value2);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend(this.extra, value2);
    } else {
      this[key] = value2;
    }
  };
  Element2.prototype.hide = function() {
    this.ignore = true;
    this.markRedraw();
  };
  Element2.prototype.show = function() {
    this.ignore = false;
    this.markRedraw();
  };
  Element2.prototype.attr = function(keyOrObj, value2) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value2);
    } else if (isObject2(keyOrObj)) {
      var obj = keyOrObj;
      var keysArr = keys(obj);
      for (var i3 = 0;i3 < keysArr.length; i3++) {
        var key = keysArr[i3];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  };
  Element2.prototype.saveCurrentToNormalState = function(toState) {
    this._innerSaveToNormal(toState);
    var normalState = this._normalState;
    for (var i3 = 0;i3 < this.animators.length; i3++) {
      var animator = this.animators[i3];
      var fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      var targetName = animator.targetName;
      var target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  };
  Element2.prototype._innerSaveToNormal = function(toState) {
    var normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  };
  Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
    for (var i3 = 0;i3 < primaryKeys.length; i3++) {
      var key = primaryKeys[i3];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  };
  Element2.prototype.hasState = function() {
    return this.currentStates.length > 0;
  };
  Element2.prototype.getState = function(name) {
    return this.states[name];
  };
  Element2.prototype.ensureState = function(name) {
    var states = this.states;
    if (!states[name]) {
      states[name] = {};
    }
    return states[name];
  };
  Element2.prototype.clearStates = function(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  };
  Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    var toNormalState = stateName === PRESERVED_NORMAL_STATE;
    var hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    var currentStates = this.currentStates;
    var animationCfg = this.stateTransition;
    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    var state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError("State " + stateName + " not exists.");
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  };
  Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      var stateObjects = [];
      var currentStates = this.currentStates;
      var len2 = states.length;
      var notChange = len2 === currentStates.length;
      if (notChange) {
        for (var i3 = 0;i3 < len2; i3++) {
          if (states[i3] !== currentStates[i3]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (var i3 = 0;i3 < len2; i3++) {
        var stateName = states[i3];
        var stateObj = undefined;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      var lastStateObj = stateObjects[len2 - 1];
      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      var mergedState = this._mergeStates(stateObjects);
      var animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  };
  Element2.prototype.isSilent = function() {
    var isSilent = this.silent;
    var ancestor = this.parent;
    while (!isSilent && ancestor) {
      if (ancestor.silent) {
        isSilent = true;
        break;
      }
      ancestor = ancestor.parent;
    }
    return isSilent;
  };
  Element2.prototype._updateAnimationTargets = function() {
    for (var i3 = 0;i3 < this.animators.length; i3++) {
      var animator = this.animators[i3];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  };
  Element2.prototype.removeState = function(state) {
    var idx = indexOf(this.currentStates, state);
    if (idx >= 0) {
      var currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  };
  Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
    var currentStates = this.currentStates.slice();
    var idx = indexOf(currentStates, oldState);
    var newStateExists = indexOf(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  };
  Element2.prototype.toggleState = function(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  };
  Element2.prototype._mergeStates = function(states) {
    var mergedState = {};
    var mergedTextConfig;
    for (var i3 = 0;i3 < states.length; i3++) {
      var state = states[i3];
      extend(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  };
  Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    var needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    var transitionTarget = {};
    var hasTransition = false;
    for (var i3 = 0;i3 < PRIMARY_STATES_KEYS.length; i3++) {
      var key = PRIMARY_STATES_KEYS[i3];
      var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (var i3 = 0;i3 < this.animators.length; i3++) {
        var animator = this.animators[i3];
        var targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  };
  Element2.prototype._attachComponent = function(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      if (true) {
        throw new Error("Text element has been added to zrender.");
      }
      return;
    }
    if (componentEl === this) {
      if (true) {
        throw new Error("Recursive component attachment.");
      }
      return;
    }
    var zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  };
  Element2.prototype._detachComponent = function(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  };
  Element2.prototype.getClipPath = function() {
    return this._clipPath;
  };
  Element2.prototype.setClipPath = function(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  };
  Element2.prototype.removeClipPath = function() {
    var clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextContent = function() {
    return this._textContent;
  };
  Element2.prototype.setTextContent = function(textEl) {
    var previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    if (true) {
      if (textEl.__zr && !textEl.__hostTarget) {
        throw new Error("Text element has been added to zrender.");
      }
    }
    textEl.innerTransformable = new Transformable_default;
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  };
  Element2.prototype.setTextConfig = function(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend(this.textConfig, cfg);
    this.markRedraw();
  };
  Element2.prototype.removeTextConfig = function() {
    this.textConfig = null;
    this.markRedraw();
  };
  Element2.prototype.removeTextContent = function() {
    var textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextGuideLine = function() {
    return this._textGuide;
  };
  Element2.prototype.setTextGuideLine = function(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  };
  Element2.prototype.removeTextGuideLine = function() {
    var textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  };
  Element2.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  };
  Element2.prototype.dirty = function() {
    this.markRedraw();
  };
  Element2.prototype._toggleHoverLayerFlag = function(inHover) {
    this.__inHover = inHover;
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  };
  Element2.prototype.addSelfToZr = function(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    var animators = this.animators;
    if (animators) {
      for (var i3 = 0;i3 < animators.length; i3++) {
        zr.animation.addAnimator(animators[i3]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  };
  Element2.prototype.removeSelfFromZr = function(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i3 = 0;i3 < animators.length; i3++) {
        zr.animation.removeAnimator(animators[i3]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  };
  Element2.prototype.animate = function(key, loop, allowDiscreteAnimation) {
    var target = key ? this[key] : this;
    if (true) {
      if (!target) {
        logError('Property "' + key + '" is not existed in element ' + this.id);
        return;
      }
    }
    var animator = new Animator_default(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  };
  Element2.prototype.addAnimator = function(animator, key) {
    var zr = this.__zr;
    var el = this;
    animator.during(function() {
      el.updateDuringAnimation(key);
    }).done(function() {
      var animators = el.animators;
      var idx = indexOf(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  };
  Element2.prototype.updateDuringAnimation = function(key) {
    this.markRedraw();
  };
  Element2.prototype.stopAnimation = function(scope, forwardToLast) {
    var animators = this.animators;
    var len2 = animators.length;
    var leftAnimators = [];
    for (var i3 = 0;i3 < len2; i3++) {
      var animator = animators[i3];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  };
  Element2.prototype.animateTo = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  };
  Element2.prototype.animateFrom = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  };
  Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
    var animators = animateTo(this, target, cfg, animationProps);
    for (var i3 = 0;i3 < animators.length; i3++) {
      animators[i3].__fromStateTransition = stateName;
    }
  };
  Element2.prototype.getBoundingRect = function() {
    return null;
  };
  Element2.prototype.getPaintRect = function() {
    return null;
  };
  Element2.initDefaultProps = function() {
    var elProto = Element2.prototype;
    elProto.type = "element";
    elProto.name = "";
    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
    elProto.__dirty = REDRAW_BIT;
    var logs = {};
    function logDeprecatedError(key, xKey, yKey) {
      if (!logs[key + xKey + yKey]) {
        console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
        logs[key + xKey + yKey] = true;
      }
    }
    function createLegacyProperty(key, privateKey, xKey, yKey) {
      Object.defineProperty(elProto, key, {
        get: function() {
          if (true) {
            logDeprecatedError(key, xKey, yKey);
          }
          if (!this[privateKey]) {
            var pos = this[privateKey] = [];
            enhanceArray(this, pos);
          }
          return this[privateKey];
        },
        set: function(pos) {
          if (true) {
            logDeprecatedError(key, xKey, yKey);
          }
          this[xKey] = pos[0];
          this[yKey] = pos[1];
          this[privateKey] = pos;
          enhanceArray(this, pos);
        }
      });
      function enhanceArray(self2, pos) {
        Object.defineProperty(pos, 0, {
          get: function() {
            return self2[xKey];
          },
          set: function(val) {
            self2[xKey] = val;
          }
        });
        Object.defineProperty(pos, 1, {
          get: function() {
            return self2[yKey];
          },
          set: function(val) {
            self2[yKey] = val;
          }
        });
      }
    }
    if (Object.defineProperty) {
      createLegacyProperty("position", "_legacyPos", "x", "y");
      createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
      createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
    }
  }();
  return Element2;
}();
mixin2(Element, Eventful_default);
mixin2(Element, Transformable_default);
function animateTo(animatable, target, cfg, animationProps, reverse) {
  cfg = cfg || {};
  var animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse);
  var finishCount = animators.length;
  var doneHappened = false;
  var cfgDone = cfg.done;
  var cfgAborted = cfg.aborted;
  var doneCb = function() {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  var abortedCb = function() {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during(function(target2, percent) {
      cfg.during(percent);
    });
  }
  for (var i3 = 0;i3 < animators.length; i3++) {
    var animator = animators[i3];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (var i3 = 0;i3 < len2; i3++) {
    source[i3] = target[i3];
  }
}
function is2DArray(value2) {
  return isArrayLike(value2[0]);
}
function copyValue(target, source, key) {
  if (isArrayLike(source[key])) {
    if (!isArrayLike(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source[key])) {
      var len2 = source[key].length;
      if (target[key].length !== len2) {
        target[key] = new source[key].constructor(len2);
        copyArrShallow(target[key], source[key], len2);
      }
    } else {
      var sourceArr = source[key];
      var targetArr = target[key];
      var len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        var len1 = sourceArr[0].length;
        for (var i3 = 0;i3 < len0; i3++) {
          if (!targetArr[i3]) {
            targetArr[i3] = Array.prototype.slice.call(sourceArr[i3]);
          } else {
            copyArrShallow(targetArr[i3], sourceArr[i3], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  var len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (var i3 = 0;i3 < len2; i3++) {
    if (arr0[i3] !== arr1[i3]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {
  var targetKeys = keys(target);
  var duration = cfg.duration;
  var delay = cfg.delay;
  var additive = cfg.additive;
  var setToFinal = cfg.setToFinal;
  var animateAll = !isObject2(animationProps);
  var existsAnimators = animatable.animators;
  var animationKeys = [];
  for (var k3 = 0;k3 < targetKeys.length; k3++) {
    var innerKey = targetKeys[k3];
    var targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject2(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  var keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (var i3 = 0;i3 < existsAnimators.length; i3++) {
      var animator = existsAnimators[i3];
      if (animator.targetName === topKey) {
        var allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          var idx = indexOf(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter(animationKeys, function(key) {
      return !isValueSame(target[key], animateObj[key]);
    });
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    var revertedSource = undefined;
    var reversedTarget = undefined;
    var sourceClone = undefined;
    if (reverse) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (var i3 = 0;i3 < keyLen; i3++) {
        var innerKey = animationKeys[i3];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (var i3 = 0;i3 < keyLen; i3++) {
        var innerKey = animationKeys[i3];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    var animator = new Animator_default(animateObj, false, false, additive ? filter(existsAnimators, function(animator2) {
      return animator2.targetName === topKey;
    }) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element_default = Element;

// node_modules/zrender/lib/graphic/Displayable.js
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS2 = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
  __extends2(Displayable2, _super);
  function Displayable2(props) {
    return _super.call(this, props) || this;
  }
  Displayable2.prototype._init = function(props) {
    var keysArr = keys(props);
    for (var i3 = 0;i3 < keysArr.length; i3++) {
      var key = keysArr[i3];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        _super.prototype.attrKV.call(this, key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Displayable2.prototype.beforeBrush = function() {};
  Displayable2.prototype.afterBrush = function() {};
  Displayable2.prototype.innerBeforeBrush = function() {};
  Displayable2.prototype.innerAfterBrush = function() {};
  Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    var m4 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m4 && !m4[0] && !m4[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (var i3 = 0;i3 < this.__clipPaths.length; ++i3) {
        if (this.__clipPaths[i3].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      var parent_1 = this.parent;
      while (parent_1) {
        if (parent_1.ignore) {
          return false;
        }
        parent_1 = parent_1.parent;
      }
    }
    return true;
  };
  Displayable2.prototype.contain = function(x3, y3) {
    return this.rectContain(x3, y3);
  };
  Displayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  Displayable2.prototype.rectContain = function(x3, y3) {
    var coord = this.transformCoordToLocal(x3, y3);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  };
  Displayable2.prototype.getPaintRect = function() {
    var rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var transform = this.transform;
      var elRect = this.getBoundingRect();
      var style = this.style;
      var shadowSize = style.shadowBlur || 0;
      var shadowOffsetX = style.shadowOffsetX || 0;
      var shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect_default(0, 0, 0, 0));
      if (transform) {
        BoundingRect_default.applyTransform(rect, elRect, transform);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      var tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  };
  Displayable2.prototype.setPrevPaintRect = function(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  };
  Displayable2.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  };
  Displayable2.prototype.animateStyle = function(loop) {
    return this.animate("style", loop);
  };
  Displayable2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  };
  Displayable2.prototype.attrKV = function(key, value2) {
    if (key !== "style") {
      _super.prototype.attrKV.call(this, key, value2);
    } else {
      if (!this.style) {
        this.useStyle(value2);
      } else {
        this.setStyle(value2);
      }
    }
  };
  Displayable2.prototype.setStyle = function(keyOrObj, value2) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value2;
    } else {
      extend(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  };
  Displayable2.prototype.dirtyStyle = function(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  };
  Displayable2.prototype.dirty = function() {
    this.dirtyStyle();
  };
  Displayable2.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  };
  Displayable2.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  };
  Displayable2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  };
  Displayable2.prototype.useStyle = function(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  };
  Displayable2.prototype.isStyleObject = function(obj) {
    return obj[STYLE_MAGIC_KEY];
  };
  Displayable2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS2);
  };
  Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        var sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          var changedKeys = keys(sourceStyle);
          for (var i3 = 0;i3 < changedKeys.length; i3++) {
            var key = changedKeys[i3];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        var targetKeys = keys(targetStyle);
        for (var i3 = 0;i3 < targetKeys.length; i3++) {
          var key = targetKeys[i3];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS2;
    for (var i3 = 0;i3 < statesKeys.length; i3++) {
      var key = statesKeys[i3];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  };
  Displayable2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedStyle;
    for (var i3 = 0;i3 < states.length; i3++) {
      var state = states[i3];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  };
  Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    extend(targetStyle, sourceStyle);
    return targetStyle;
  };
  Displayable2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  };
  Displayable2.initDefaultProps = function() {
    var dispProto = Displayable2.prototype;
    dispProto.type = "displayable";
    dispProto.invisible = false;
    dispProto.z = 0;
    dispProto.z2 = 0;
    dispProto.zlevel = 0;
    dispProto.culling = false;
    dispProto.cursor = "pointer";
    dispProto.rectHover = false;
    dispProto.incremental = false;
    dispProto._rect = null;
    dispProto.dirtyRectTolerance = 0;
    dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }();
  return Displayable2;
}(Element_default);
var tmpRect = new BoundingRect_default(0, 0, 0, 0);
var viewRect = new BoundingRect_default(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
var Displayable_default = Displayable;

// node_modules/zrender/lib/core/bbox.js
var mathMin2 = Math.min;
var mathMax2 = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = create2();
var end = create2();
var extremity = create2();
function fromLine(x0, y0, x1, y1, min2, max2) {
  min2[0] = mathMin2(x0, x1);
  min2[1] = mathMin2(y0, y1);
  max2[0] = mathMax2(x0, x1);
  max2[1] = mathMax2(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x22, y22, x3, y3, min2, max2) {
  var cubicExtrema2 = cubicExtrema;
  var cubicAt2 = cubicAt;
  var n3 = cubicExtrema2(x0, x1, x22, x3, xDim);
  min2[0] = Infinity;
  min2[1] = Infinity;
  max2[0] = -Infinity;
  max2[1] = -Infinity;
  for (var i3 = 0;i3 < n3; i3++) {
    var x4 = cubicAt2(x0, x1, x22, x3, xDim[i3]);
    min2[0] = mathMin2(x4, min2[0]);
    max2[0] = mathMax2(x4, max2[0]);
  }
  n3 = cubicExtrema2(y0, y1, y22, y3, yDim);
  for (var i3 = 0;i3 < n3; i3++) {
    var y4 = cubicAt2(y0, y1, y22, y3, yDim[i3]);
    min2[1] = mathMin2(y4, min2[1]);
    max2[1] = mathMax2(y4, max2[1]);
  }
  min2[0] = mathMin2(x0, min2[0]);
  max2[0] = mathMax2(x0, max2[0]);
  min2[0] = mathMin2(x3, min2[0]);
  max2[0] = mathMax2(x3, max2[0]);
  min2[1] = mathMin2(y0, min2[1]);
  max2[1] = mathMax2(y0, max2[1]);
  min2[1] = mathMin2(y3, min2[1]);
  max2[1] = mathMax2(y3, max2[1]);
}
function fromQuadratic(x0, y0, x1, y1, x22, y22, min2, max2) {
  var quadraticExtremum2 = quadraticExtremum;
  var quadraticAt2 = quadraticAt;
  var tx = mathMax2(mathMin2(quadraticExtremum2(x0, x1, x22), 1), 0);
  var ty = mathMax2(mathMin2(quadraticExtremum2(y0, y1, y22), 1), 0);
  var x3 = quadraticAt2(x0, x1, x22, tx);
  var y3 = quadraticAt2(y0, y1, y22, ty);
  min2[0] = mathMin2(x0, x22, x3);
  min2[1] = mathMin2(y0, y22, y3);
  max2[0] = mathMax2(x0, x22, x3);
  max2[1] = mathMax2(y0, y22, y3);
}
function fromArc(x3, y3, rx, ry, startAngle, endAngle, anticlockwise, min2, max2) {
  var vec2Min = min;
  var vec2Max = max;
  var diff = Math.abs(startAngle - endAngle);
  if (diff % PI2 < 0.0001 && diff > 0.0001) {
    min2[0] = x3 - rx;
    min2[1] = y3 - ry;
    max2[0] = x3 + rx;
    max2[1] = y3 + ry;
    return;
  }
  start[0] = mathCos(startAngle) * rx + x3;
  start[1] = mathSin(startAngle) * ry + y3;
  end[0] = mathCos(endAngle) * rx + x3;
  end[1] = mathSin(endAngle) * ry + y3;
  vec2Min(min2, start, end);
  vec2Max(max2, start, end);
  startAngle = startAngle % PI2;
  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }
  endAngle = endAngle % PI2;
  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }
  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (var angle = 0;angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x3;
      extremity[1] = mathSin(angle) * ry + y3;
      vec2Min(min2, extremity, min2);
      vec2Max(max2, extremity, max2);
    }
  }
}

// node_modules/zrender/lib/core/PathProxy.js
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min2 = [];
var max2 = [];
var min22 = [];
var max22 = [];
var mathMin3 = Math.min;
var mathMax3 = Math.max;
var mathCos2 = Math.cos;
var mathSin2 = Math.sin;
var mathAbs = Math.abs;
var PI = Math.PI;
var PI22 = PI * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  var n3 = Math.round(radian / PI * 1e8) / 1e8;
  return n3 % 2 * PI;
}
function normalizeArcAngles(angles, anticlockwise) {
  var newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI22;
  }
  var delta = newStartAngle - angles[0];
  var newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI22) {
    newEndAngle = newStartAngle + PI22;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI22) {
    newEndAngle = newStartAngle - PI22;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI22 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI22 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy = function() {
  function PathProxy2(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  PathProxy2.prototype.increaseVersion = function() {
    this._version++;
  };
  PathProxy2.prototype.getVersion = function() {
    return this._version;
  };
  PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  };
  PathProxy2.prototype.setDPR = function(dpr2) {
    this.dpr = dpr2;
  };
  PathProxy2.prototype.setContext = function(ctx) {
    this._ctx = ctx;
  };
  PathProxy2.prototype.getContext = function() {
    return this._ctx;
  };
  PathProxy2.prototype.beginPath = function() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  };
  PathProxy2.prototype.reset = function() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  };
  PathProxy2.prototype.moveTo = function(x3, y3) {
    this._drawPendingPt();
    this.addData(CMD.M, x3, y3);
    this._ctx && this._ctx.moveTo(x3, y3);
    this._x0 = x3;
    this._y0 = y3;
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.lineTo = function(x3, y3) {
    var dx = mathAbs(x3 - this._xi);
    var dy = mathAbs(y3 - this._yi);
    var exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD.L, x3, y3);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x3, y3);
    }
    if (exceedUnit) {
      this._xi = x3;
      this._yi = y3;
      this._pendingPtDist = 0;
    } else {
      var d22 = dx * dx + dy * dy;
      if (d22 > this._pendingPtDist) {
        this._pendingPtX = x3;
        this._pendingPtY = y3;
        this._pendingPtDist = d22;
      }
    }
    return this;
  };
  PathProxy2.prototype.bezierCurveTo = function(x1, y1, x22, y22, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD.C, x1, y1, x22, y22, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x22, y22, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x22, y22) {
    this._drawPendingPt();
    this.addData(CMD.Q, x1, y1, x22, y22);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x22, y22);
    }
    this._xi = x22;
    this._yi = y22;
    return this;
  };
  PathProxy2.prototype.arc = function(cx, cy, r3, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    var delta = endAngle - startAngle;
    this.addData(CMD.A, cx, cy, r3, r3, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r3, startAngle, endAngle, anticlockwise);
    this._xi = mathCos2(endAngle) * r3 + cx;
    this._yi = mathSin2(endAngle) * r3 + cy;
    return this;
  };
  PathProxy2.prototype.arcTo = function(x1, y1, x22, y22, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x22, y22, radius);
    }
    return this;
  };
  PathProxy2.prototype.rect = function(x3, y3, w3, h3) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x3, y3, w3, h3);
    this.addData(CMD.R, x3, y3, w3, h3);
    return this;
  };
  PathProxy2.prototype.closePath = function() {
    this._drawPendingPt();
    this.addData(CMD.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  };
  PathProxy2.prototype.fill = function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  };
  PathProxy2.prototype.stroke = function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  };
  PathProxy2.prototype.len = function() {
    return this._len;
  };
  PathProxy2.prototype.setData = function(data) {
    var len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (var i3 = 0;i3 < len2; i3++) {
      this.data[i3] = data[i3];
    }
    this._len = len2;
  };
  PathProxy2.prototype.appendPath = function(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    var len2 = path.length;
    var appendSize = 0;
    var offset = this._len;
    for (var i3 = 0;i3 < len2; i3++) {
      appendSize += path[i3].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }
    for (var i3 = 0;i3 < len2; i3++) {
      var appendPathData = path[i3].data;
      for (var k3 = 0;k3 < appendPathData.length; k3++) {
        this.data[offset++] = appendPathData[k3];
      }
    }
    this._len = offset;
  };
  PathProxy2.prototype.addData = function(cmd, a3, b, c3, d3, e3, f3, g2, h3) {
    if (!this._saveData) {
      return;
    }
    var data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (var i3 = 0;i3 < arguments.length; i3++) {
      data[this._len++] = arguments[i3];
    }
  };
  PathProxy2.prototype._drawPendingPt = function() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  };
  PathProxy2.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i3 = 0;i3 < this._len; i3++) {
        newData[i3] = this.data[i3];
      }
      this.data = newData;
    }
  };
  PathProxy2.prototype.toStatic = function() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    var data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  };
  PathProxy2.prototype.getBoundingRect = function() {
    min2[0] = min2[1] = min22[0] = min22[1] = Number.MAX_VALUE;
    max2[0] = max2[1] = max22[0] = max22[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var i3;
    for (i3 = 0;i3 < this._len; ) {
      var cmd = data[i3++];
      var isFirst = i3 === 1;
      if (isFirst) {
        xi = data[i3];
        yi = data[i3 + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i3++];
          yi = y0 = data[i3++];
          min22[0] = x0;
          min22[1] = y0;
          max22[0] = x0;
          max22[1] = y0;
          break;
        case CMD.L:
          fromLine(xi, yi, data[i3], data[i3 + 1], min22, max22);
          xi = data[i3++];
          yi = data[i3++];
          break;
        case CMD.C:
          fromCubic(xi, yi, data[i3++], data[i3++], data[i3++], data[i3++], data[i3], data[i3 + 1], min22, max22);
          xi = data[i3++];
          yi = data[i3++];
          break;
        case CMD.Q:
          fromQuadratic(xi, yi, data[i3++], data[i3++], data[i3], data[i3 + 1], min22, max22);
          xi = data[i3++];
          yi = data[i3++];
          break;
        case CMD.A:
          var cx = data[i3++];
          var cy = data[i3++];
          var rx = data[i3++];
          var ry = data[i3++];
          var startAngle = data[i3++];
          var endAngle = data[i3++] + startAngle;
          i3 += 1;
          var anticlockwise = !data[i3++];
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min22, max22);
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R:
          x0 = xi = data[i3++];
          y0 = yi = data[i3++];
          var width = data[i3++];
          var height = data[i3++];
          fromLine(x0, y0, x0 + width, y0 + height, min22, max22);
          break;
        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      }
      min(min2, min2, min22);
      max(max2, max2, max22);
    }
    if (i3 === 0) {
      min2[0] = min2[1] = max2[0] = max2[1] = 0;
    }
    return new BoundingRect_default(min2[0], min2[1], max2[0] - min2[0], max2[1] - min2[1]);
  };
  PathProxy2.prototype._calculateLength = function() {
    var data = this.data;
    var len2 = this._len;
    var ux = this._ux;
    var uy = this._uy;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    var pathSegLen = this._pathSegLen;
    var pathTotalLen = 0;
    var segCount = 0;
    for (var i3 = 0;i3 < len2; ) {
      var cmd = data[i3++];
      var isFirst = i3 === 1;
      if (isFirst) {
        xi = data[i3];
        yi = data[i3 + 1];
        x0 = xi;
        y0 = yi;
      }
      var l3 = -1;
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i3++];
          yi = y0 = data[i3++];
          break;
        case CMD.L: {
          var x22 = data[i3++];
          var y22 = data[i3++];
          var dx = x22 - xi;
          var dy = y22 - yi;
          if (mathAbs(dx) > ux || mathAbs(dy) > uy || i3 === len2 - 1) {
            l3 = Math.sqrt(dx * dx + dy * dy);
            xi = x22;
            yi = y22;
          }
          break;
        }
        case CMD.C: {
          var x1 = data[i3++];
          var y1 = data[i3++];
          var x22 = data[i3++];
          var y22 = data[i3++];
          var x3 = data[i3++];
          var y3 = data[i3++];
          l3 = cubicLength(xi, yi, x1, y1, x22, y22, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD.Q: {
          var x1 = data[i3++];
          var y1 = data[i3++];
          var x22 = data[i3++];
          var y22 = data[i3++];
          l3 = quadraticLength(xi, yi, x1, y1, x22, y22, 10);
          xi = x22;
          yi = y22;
          break;
        }
        case CMD.A:
          var cx = data[i3++];
          var cy = data[i3++];
          var rx = data[i3++];
          var ry = data[i3++];
          var startAngle = data[i3++];
          var delta = data[i3++];
          var endAngle = delta + startAngle;
          i3 += 1;
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          l3 = mathMax3(rx, ry) * mathMin3(PI22, Math.abs(delta));
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R: {
          x0 = xi = data[i3++];
          y0 = yi = data[i3++];
          var width = data[i3++];
          var height = data[i3++];
          l3 = width * 2 + height * 2;
          break;
        }
        case CMD.Z: {
          var dx = x0 - xi;
          var dy = y0 - yi;
          l3 = Math.sqrt(dx * dx + dy * dy);
          xi = x0;
          yi = y0;
          break;
        }
      }
      if (l3 >= 0) {
        pathSegLen[segCount++] = l3;
        pathTotalLen += l3;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  };
  PathProxy2.prototype.rebuildPath = function(ctx, percent) {
    var d3 = this.data;
    var ux = this._ux;
    var uy = this._uy;
    var len2 = this._len;
    var x0;
    var y0;
    var xi;
    var yi;
    var x3;
    var y3;
    var drawPart = percent < 1;
    var pathSegLen;
    var pathTotalLen;
    var accumLength = 0;
    var segCount = 0;
    var displayedLength;
    var pendingPtDist = 0;
    var pendingPtX;
    var pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (var i3 = 0;i3 < len2; ) {
        var cmd = d3[i3++];
        var isFirst = i3 === 1;
        if (isFirst) {
          xi = d3[i3];
          yi = d3[i3 + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD.M:
            x0 = xi = d3[i3++];
            y0 = yi = d3[i3++];
            ctx.moveTo(xi, yi);
            break;
          case CMD.L: {
            x3 = d3[i3++];
            y3 = d3[i3++];
            var dx = mathAbs(x3 - xi);
            var dy = mathAbs(y3 - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l3 = pathSegLen[segCount++];
                if (accumLength + l3 > displayedLength) {
                  var t4 = (displayedLength - accumLength) / l3;
                  ctx.lineTo(xi * (1 - t4) + x3 * t4, yi * (1 - t4) + y3 * t4);
                  break lo;
                }
                accumLength += l3;
              }
              ctx.lineTo(x3, y3);
              xi = x3;
              yi = y3;
              pendingPtDist = 0;
            } else {
              var d22 = dx * dx + dy * dy;
              if (d22 > pendingPtDist) {
                pendingPtX = x3;
                pendingPtY = y3;
                pendingPtDist = d22;
              }
            }
            break;
          }
          case CMD.C: {
            var x1 = d3[i3++];
            var y1 = d3[i3++];
            var x22 = d3[i3++];
            var y22 = d3[i3++];
            var x32 = d3[i3++];
            var y32 = d3[i3++];
            if (drawPart) {
              var l3 = pathSegLen[segCount++];
              if (accumLength + l3 > displayedLength) {
                var t4 = (displayedLength - accumLength) / l3;
                cubicSubdivide(xi, x1, x22, x32, t4, tmpOutX);
                cubicSubdivide(yi, y1, y22, y32, t4, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l3;
            }
            ctx.bezierCurveTo(x1, y1, x22, y22, x32, y32);
            xi = x32;
            yi = y32;
            break;
          }
          case CMD.Q: {
            var x1 = d3[i3++];
            var y1 = d3[i3++];
            var x22 = d3[i3++];
            var y22 = d3[i3++];
            if (drawPart) {
              var l3 = pathSegLen[segCount++];
              if (accumLength + l3 > displayedLength) {
                var t4 = (displayedLength - accumLength) / l3;
                quadraticSubdivide(xi, x1, x22, t4, tmpOutX);
                quadraticSubdivide(yi, y1, y22, t4, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l3;
            }
            ctx.quadraticCurveTo(x1, y1, x22, y22);
            xi = x22;
            yi = y22;
            break;
          }
          case CMD.A:
            var cx = d3[i3++];
            var cy = d3[i3++];
            var rx = d3[i3++];
            var ry = d3[i3++];
            var startAngle = d3[i3++];
            var delta = d3[i3++];
            var psi = d3[i3++];
            var anticlockwise = !d3[i3++];
            var r3 = rx > ry ? rx : ry;
            var isEllipse = mathAbs(rx - ry) > 0.001;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l3 = pathSegLen[segCount++];
              if (accumLength + l3 > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l3;
                breakBuild = true;
              }
              accumLength += l3;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r3, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos2(startAngle) * rx + cx;
              y0 = mathSin2(startAngle) * ry + cy;
            }
            xi = mathCos2(endAngle) * rx + cx;
            yi = mathSin2(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = d3[i3];
            y0 = yi = d3[i3 + 1];
            x3 = d3[i3++];
            y3 = d3[i3++];
            var width = d3[i3++];
            var height = d3[i3++];
            if (drawPart) {
              var l3 = pathSegLen[segCount++];
              if (accumLength + l3 > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x3, y3);
                ctx.lineTo(x3 + mathMin3(d_1, width), y3);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x3 + width, y3 + mathMin3(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x3 + mathMax3(width - d_1, 0), y3 + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x3, y3 + mathMax3(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l3;
            }
            ctx.rect(x3, y3, width, height);
            break;
          case CMD.Z:
            if (drawPart) {
              var l3 = pathSegLen[segCount++];
              if (accumLength + l3 > displayedLength) {
                var t4 = (displayedLength - accumLength) / l3;
                ctx.lineTo(xi * (1 - t4) + x0 * t4, yi * (1 - t4) + y0 * t4);
                break lo;
              }
              accumLength += l3;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
  };
  PathProxy2.prototype.clone = function() {
    var newProxy = new PathProxy2;
    var data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  };
  PathProxy2.CMD = CMD;
  PathProxy2.initDefaultProps = function() {
    var proto = PathProxy2.prototype;
    proto._saveData = true;
    proto._ux = 0;
    proto._uy = 0;
    proto._pendingPtDist = 0;
    proto._version = 0;
  }();
  return PathProxy2;
}();
var PathProxy_default = PathProxy;

// node_modules/zrender/lib/contain/line.js
function containStroke(x0, y0, x1, y1, lineWidth, x3, y3) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  var _a = 0;
  var _b = x0;
  if (y3 > y0 + _l && y3 > y1 + _l || y3 < y0 - _l && y3 < y1 - _l || x3 > x0 + _l && x3 > x1 + _l || x3 < x0 - _l && x3 < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x3 - x0) <= _l / 2;
  }
  var tmp = _a * x3 - y3 + _b;
  var _s = tmp * tmp / (_a * _a + 1);
  return _s <= _l / 2 * _l / 2;
}

// node_modules/zrender/lib/contain/cubic.js
function containStroke2(x0, y0, x1, y1, x22, y22, x3, y3, lineWidth, x4, y4) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y4 > y0 + _l && y4 > y1 + _l && y4 > y22 + _l && y4 > y3 + _l || y4 < y0 - _l && y4 < y1 - _l && y4 < y22 - _l && y4 < y3 - _l || x4 > x0 + _l && x4 > x1 + _l && x4 > x22 + _l && x4 > x3 + _l || x4 < x0 - _l && x4 < x1 - _l && x4 < x22 - _l && x4 < x3 - _l) {
    return false;
  }
  var d3 = cubicProjectPoint(x0, y0, x1, y1, x22, y22, x3, y3, x4, y4, null);
  return d3 <= _l / 2;
}

// node_modules/zrender/lib/contain/quadratic.js
function containStroke3(x0, y0, x1, y1, x22, y22, lineWidth, x3, y3) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y3 > y0 + _l && y3 > y1 + _l && y3 > y22 + _l || y3 < y0 - _l && y3 < y1 - _l && y3 < y22 - _l || x3 > x0 + _l && x3 > x1 + _l && x3 > x22 + _l || x3 < x0 - _l && x3 < x1 - _l && x3 < x22 - _l) {
    return false;
  }
  var d3 = quadraticProjectPoint(x0, y0, x1, y1, x22, y22, x3, y3, null);
  return d3 <= _l / 2;
}

// node_modules/zrender/lib/contain/util.js
var PI23 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI23;
  if (angle < 0) {
    angle += PI23;
  }
  return angle;
}

// node_modules/zrender/lib/contain/arc.js
var PI24 = Math.PI * 2;
function containStroke4(cx, cy, r3, startAngle, endAngle, anticlockwise, lineWidth, x3, y3) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  x3 -= cx;
  y3 -= cy;
  var d3 = Math.sqrt(x3 * x3 + y3 * y3);
  if (d3 - _l > r3 || d3 + _l < r3) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI24 < 0.0001) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI24;
  }
  var angle = Math.atan2(y3, x3);
  if (angle < 0) {
    angle += PI24;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI24 >= startAngle && angle + PI24 <= endAngle;
}

// node_modules/zrender/lib/contain/windingLine.js
function windingLine(x0, y0, x1, y1, x3, y3) {
  if (y3 > y0 && y3 > y1 || y3 < y0 && y3 < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  var t4 = (y3 - y0) / (y1 - y0);
  var dir = y1 < y0 ? 1 : -1;
  if (t4 === 1 || t4 === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }
  var x_ = t4 * (x1 - x0) + x0;
  return x_ === x3 ? Infinity : x_ > x3 ? dir : 0;
}

// node_modules/zrender/lib/contain/path.js
var CMD2 = PathProxy_default.CMD;
var PI25 = Math.PI * 2;
var EPSILON3 = 0.0001;
function isAroundEqual(a3, b) {
  return Math.abs(a3 - b) < EPSILON3;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x22, y22, x3, y3, x4, y4) {
  if (y4 > y0 && y4 > y1 && y4 > y22 && y4 > y3 || y4 < y0 && y4 < y1 && y4 < y22 && y4 < y3) {
    return 0;
  }
  var nRoots = cubicRootAt(y0, y1, y22, y3, y4, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w3 = 0;
    var nExtrema = -1;
    var y0_ = undefined;
    var y1_ = undefined;
    for (var i3 = 0;i3 < nRoots; i3++) {
      var t4 = roots[i3];
      var unit = t4 === 0 || t4 === 1 ? 0.5 : 1;
      var x_ = cubicAt(x0, x1, x22, x3, t4);
      if (x_ < x4) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y22, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y22, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y22, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t4 < extrema[0]) {
          w3 += y0_ < y0 ? unit : -unit;
        } else if (t4 < extrema[1]) {
          w3 += y1_ < y0_ ? unit : -unit;
        } else {
          w3 += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t4 < extrema[0]) {
          w3 += y0_ < y0 ? unit : -unit;
        } else {
          w3 += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w3;
  }
}
function windingQuadratic(x0, y0, x1, y1, x22, y22, x3, y3) {
  if (y3 > y0 && y3 > y1 && y3 > y22 || y3 < y0 && y3 < y1 && y3 < y22) {
    return 0;
  }
  var nRoots = quadraticRootAt(y0, y1, y22, y3, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t4 = quadraticExtremum(y0, y1, y22);
    if (t4 >= 0 && t4 <= 1) {
      var w3 = 0;
      var y_ = quadraticAt(y0, y1, y22, t4);
      for (var i3 = 0;i3 < nRoots; i3++) {
        var unit = roots[i3] === 0 || roots[i3] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x22, roots[i3]);
        if (x_ < x3) {
          continue;
        }
        if (roots[i3] < t4) {
          w3 += y_ < y0 ? unit : -unit;
        } else {
          w3 += y22 < y_ ? unit : -unit;
        }
      }
      return w3;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = quadraticAt(x0, x1, x22, roots[0]);
      if (x_ < x3) {
        return 0;
      }
      return y22 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r3, startAngle, endAngle, anticlockwise, x3, y3) {
  y3 -= cy;
  if (y3 > r3 || y3 < -r3) {
    return 0;
  }
  var tmp = Math.sqrt(r3 * r3 - y3 * y3);
  roots[0] = -tmp;
  roots[1] = tmp;
  var dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 0.0001) {
    return 0;
  }
  if (dTheta >= PI25 - 0.0001) {
    startAngle = 0;
    endAngle = PI25;
    var dir = anticlockwise ? 1 : -1;
    if (x3 >= roots[0] + cx && x3 <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    var tmp_1 = startAngle;
    startAngle = endAngle;
    endAngle = tmp_1;
  }
  if (startAngle < 0) {
    startAngle += PI25;
    endAngle += PI25;
  }
  var w3 = 0;
  for (var i3 = 0;i3 < 2; i3++) {
    var x_ = roots[i3];
    if (x_ + cx > x3) {
      var angle = Math.atan2(y3, x_);
      var dir = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI25 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI25 >= startAngle && angle + PI25 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }
        w3 += dir;
      }
    }
  }
  return w3;
}
function containPath(path, lineWidth, isStroke, x3, y3) {
  var data = path.data;
  var len2 = path.len();
  var w3 = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  for (var i3 = 0;i3 < len2; ) {
    var cmd = data[i3++];
    var isFirst = i3 === 1;
    if (cmd === CMD2.M && i3 > 1) {
      if (!isStroke) {
        w3 += windingLine(xi, yi, x0, y0, x3, y3);
      }
    }
    if (isFirst) {
      xi = data[i3];
      yi = data[i3 + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD2.M:
        x0 = data[i3++];
        y0 = data[i3++];
        xi = x0;
        yi = y0;
        break;
      case CMD2.L:
        if (isStroke) {
          if (containStroke(xi, yi, data[i3], data[i3 + 1], lineWidth, x3, y3)) {
            return true;
          }
        } else {
          w3 += windingLine(xi, yi, data[i3], data[i3 + 1], x3, y3) || 0;
        }
        xi = data[i3++];
        yi = data[i3++];
        break;
      case CMD2.C:
        if (isStroke) {
          if (containStroke2(xi, yi, data[i3++], data[i3++], data[i3++], data[i3++], data[i3], data[i3 + 1], lineWidth, x3, y3)) {
            return true;
          }
        } else {
          w3 += windingCubic(xi, yi, data[i3++], data[i3++], data[i3++], data[i3++], data[i3], data[i3 + 1], x3, y3) || 0;
        }
        xi = data[i3++];
        yi = data[i3++];
        break;
      case CMD2.Q:
        if (isStroke) {
          if (containStroke3(xi, yi, data[i3++], data[i3++], data[i3], data[i3 + 1], lineWidth, x3, y3)) {
            return true;
          }
        } else {
          w3 += windingQuadratic(xi, yi, data[i3++], data[i3++], data[i3], data[i3 + 1], x3, y3) || 0;
        }
        xi = data[i3++];
        yi = data[i3++];
        break;
      case CMD2.A:
        var cx = data[i3++];
        var cy = data[i3++];
        var rx = data[i3++];
        var ry = data[i3++];
        var theta = data[i3++];
        var dTheta = data[i3++];
        i3 += 1;
        var anticlockwise = !!(1 - data[i3++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w3 += windingLine(xi, yi, x1, y1, x3, y3);
        } else {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x3 - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke4(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y3)) {
            return true;
          }
        } else {
          w3 += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y3);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD2.R:
        x0 = xi = data[i3++];
        y0 = yi = data[i3++];
        var width = data[i3++];
        var height = data[i3++];
        x1 = x0 + width;
        y1 = y0 + height;
        if (isStroke) {
          if (containStroke(x0, y0, x1, y0, lineWidth, x3, y3) || containStroke(x1, y0, x1, y1, lineWidth, x3, y3) || containStroke(x1, y1, x0, y1, lineWidth, x3, y3) || containStroke(x0, y1, x0, y0, lineWidth, x3, y3)) {
            return true;
          }
        } else {
          w3 += windingLine(x1, y0, x1, y1, x3, y3);
          w3 += windingLine(x0, y1, x0, y0, x3, y3);
        }
        break;
      case CMD2.Z:
        if (isStroke) {
          if (containStroke(xi, yi, x0, y0, lineWidth, x3, y3)) {
            return true;
          }
        } else {
          w3 += windingLine(xi, yi, x0, y0, x3, y3);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual(yi, y0)) {
    w3 += windingLine(xi, yi, x0, y0, x3, y3) || 0;
  }
  return w3 !== 0;
}
function contain(pathProxy, x3, y3) {
  return containPath(pathProxy, 0, false, x3, y3);
}
function containStroke5(pathProxy, lineWidth, x3, y3) {
  return containPath(pathProxy, lineWidth, true, x3, y3);
}

// node_modules/zrender/lib/graphic/Path.js
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path = function(_super) {
  __extends2(Path2, _super);
  function Path2(opts) {
    return _super.call(this, opts) || this;
  }
  Path2.prototype.update = function() {
    var _this = this;
    _super.prototype.update.call(this);
    var style = this.style;
    if (style.decal) {
      var decalEl = this._decalEl = this._decalEl || new Path2;
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = function(ctx) {
          _this.buildPath(ctx, _this.shape);
        };
      }
      decalEl.silent = true;
      var decalElStyle = decalEl.style;
      for (var key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (var i3 = 0;i3 < pathCopyParams.length; ++i3) {
        decalEl[pathCopyParams[i3]] = this[pathCopyParams[i3]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  };
  Path2.prototype.getDecalElement = function() {
    return this._decalEl;
  };
  Path2.prototype._init = function(props) {
    var keysArr = keys(props);
    this.shape = this.getDefaultShape();
    var defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (var i3 = 0;i3 < keysArr.length; i3++) {
      var key = keysArr[i3];
      var value2 = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value2);
        } else {
          extend(this.style, value2);
        }
      } else if (key === "shape") {
        extend(this.shape, value2);
      } else {
        _super.prototype.attrKV.call(this, key, value2);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Path2.prototype.getDefaultStyle = function() {
    return null;
  };
  Path2.prototype.getDefaultShape = function() {
    return {};
  };
  Path2.prototype.canBeInsideText = function() {
    return this.hasFill();
  };
  Path2.prototype.getInsideTextFill = function() {
    var pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString(pathFill)) {
        var fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  };
  Path2.prototype.getInsideTextStroke = function(textFill) {
    var pathFill = this.style.fill;
    if (isString(pathFill)) {
      var zr = this.__zr;
      var isDarkMode = !!(zr && zr.isDarkMode());
      var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode === isDarkLabel) {
        return pathFill;
      }
    }
  };
  Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {};
  Path2.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  };
  Path2.prototype.getUpdatedPathProxy = function(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  };
  Path2.prototype.createPathProxy = function() {
    this.path = new PathProxy_default(false);
  };
  Path2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  };
  Path2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  Path2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      var path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        var w3 = style.lineWidth;
        if (!this.hasFill()) {
          var strokeContainThreshold = this.strokeContainThreshold;
          w3 = Math.max(w3, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 0.0000000001) {
          rectStroke.width += w3 / lineScale;
          rectStroke.height += w3 / lineScale;
          rectStroke.x -= w3 / lineScale / 2;
          rectStroke.y -= w3 / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  };
  Path2.prototype.contain = function(x3, y3) {
    var localPos = this.transformCoordToLocal(x3, y3);
    var rect = this.getBoundingRect();
    var style = this.style;
    x3 = localPos[0];
    y3 = localPos[1];
    if (rect.contain(x3, y3)) {
      var pathProxy = this.path;
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 0.0000000001) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke5(pathProxy, lineWidth / lineScale, x3, y3)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain(pathProxy, x3, y3);
      }
    }
    return false;
  };
  Path2.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  };
  Path2.prototype.dirty = function() {
    this.dirtyStyle();
    this.dirtyShape();
  };
  Path2.prototype.animateShape = function(loop) {
    return this.animate("shape", loop);
  };
  Path2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  };
  Path2.prototype.attrKV = function(key, value2) {
    if (key === "shape") {
      this.setShape(value2);
    } else {
      _super.prototype.attrKV.call(this, key, value2);
    }
  };
  Path2.prototype.setShape = function(keyOrObj, value2) {
    var shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value2;
    } else {
      extend(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  };
  Path2.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  };
  Path2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  };
  Path2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend({}, this.shape);
    }
  };
  Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend({}, normalState.shape);
          extend(targetShape, state.shape);
        }
      } else {
        targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
        extend(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend({}, this.shape);
        var targetShapePrimaryProps = {};
        var shapeKeys = keys(targetShape);
        for (var i3 = 0;i3 < shapeKeys.length; i3++) {
          var key = shapeKeys[i3];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  };
  Path2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedShape;
    for (var i3 = 0;i3 < states.length; i3++) {
      var state = states[i3];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  };
  Path2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  };
  Path2.prototype.isZeroArea = function() {
    return false;
  };
  Path2.extend = function(defaultProps) {
    var Sub = function(_super2) {
      __extends2(Sub2, _super2);
      function Sub2(opts) {
        var _this = _super2.call(this, opts) || this;
        defaultProps.init && defaultProps.init.call(_this, opts);
        return _this;
      }
      Sub2.prototype.getDefaultStyle = function() {
        return clone(defaultProps.style);
      };
      Sub2.prototype.getDefaultShape = function() {
        return clone(defaultProps.shape);
      };
      return Sub2;
    }(Path2);
    for (var key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub.prototype[key] = defaultProps[key];
      }
    }
    return Sub;
  };
  Path2.initDefaultProps = function() {
    var pathProto = Path2.prototype;
    pathProto.type = "path";
    pathProto.strokeContainThreshold = 5;
    pathProto.segmentIgnoreThreshold = 0;
    pathProto.subPixelOptimize = false;
    pathProto.autoBatch = false;
    pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }();
  return Path2;
}(Displayable_default);
var Path_default = Path;

// node_modules/zrender/lib/graphic/TSpan.js
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
  __extends2(TSpan2, _super);
  function TSpan2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TSpan2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  };
  TSpan2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  TSpan2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  };
  TSpan2.prototype.setBoundingRect = function(rect) {
    this._rect = rect;
  };
  TSpan2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      var text = style.text;
      text != null ? text += "" : text = "";
      var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        var w3 = style.lineWidth;
        rect.x -= w3 / 2;
        rect.y -= w3 / 2;
        rect.width += w3;
        rect.height += w3;
      }
      this._rect = rect;
    }
    return this._rect;
  };
  TSpan2.initDefaultProps = function() {
    var tspanProto = TSpan2.prototype;
    tspanProto.dirtyRectTolerance = 10;
  }();
  return TSpan2;
}(Displayable_default);
TSpan.prototype.type = "tspan";
var TSpan_default = TSpan;

// node_modules/zrender/lib/graphic/Image.js
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = function(_super) {
  __extends2(ZRImage2, _super);
  function ZRImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZRImage2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  };
  ZRImage2.prototype._getSize = function(dim) {
    var style = this.style;
    var size = style[dim];
    if (size != null) {
      return size;
    }
    var imageSource = isImageLike(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    var otherDim = dim === "width" ? "height" : "width";
    var otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  };
  ZRImage2.prototype.getWidth = function() {
    return this._getSize("width");
  };
  ZRImage2.prototype.getHeight = function() {
    return this._getSize("height");
  };
  ZRImage2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  };
  ZRImage2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect_default(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  };
  return ZRImage2;
}(Displayable_default);
ZRImage.prototype.type = "image";
var Image_default = ZRImage;

// node_modules/zrender/lib/graphic/helper/roundRect.js
function buildPath(ctx, shape) {
  var x3 = shape.x;
  var y3 = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r3 = shape.r;
  var r1;
  var r22;
  var r32;
  var r4;
  if (width < 0) {
    x3 = x3 + width;
    width = -width;
  }
  if (height < 0) {
    y3 = y3 + height;
    height = -height;
  }
  if (typeof r3 === "number") {
    r1 = r22 = r32 = r4 = r3;
  } else if (r3 instanceof Array) {
    if (r3.length === 1) {
      r1 = r22 = r32 = r4 = r3[0];
    } else if (r3.length === 2) {
      r1 = r32 = r3[0];
      r22 = r4 = r3[1];
    } else if (r3.length === 3) {
      r1 = r3[0];
      r22 = r4 = r3[1];
      r32 = r3[2];
    } else {
      r1 = r3[0];
      r22 = r3[1];
      r32 = r3[2];
      r4 = r3[3];
    }
  } else {
    r1 = r22 = r32 = r4 = 0;
  }
  var total;
  if (r1 + r22 > width) {
    total = r1 + r22;
    r1 *= width / total;
    r22 *= width / total;
  }
  if (r32 + r4 > width) {
    total = r32 + r4;
    r32 *= width / total;
    r4 *= width / total;
  }
  if (r22 + r32 > height) {
    total = r22 + r32;
    r22 *= height / total;
    r32 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x3 + r1, y3);
  ctx.lineTo(x3 + width - r22, y3);
  r22 !== 0 && ctx.arc(x3 + width - r22, y3 + r22, r22, -Math.PI / 2, 0);
  ctx.lineTo(x3 + width, y3 + height - r32);
  r32 !== 0 && ctx.arc(x3 + width - r32, y3 + height - r32, r32, 0, Math.PI / 2);
  ctx.lineTo(x3 + r4, y3 + height);
  r4 !== 0 && ctx.arc(x3 + r4, y3 + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x3, y3 + r1);
  r1 !== 0 && ctx.arc(x3 + r1, y3 + r1, r1, Math.PI, Math.PI * 1.5);
}

// node_modules/zrender/lib/graphic/helper/subPixelOptimize.js
var round = Math.round;
function subPixelOptimizeLine(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x1 = inputShape.x1;
  var x22 = inputShape.x2;
  var y1 = inputShape.y1;
  var y22 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x22;
  outputShape.y1 = y1;
  outputShape.y2 = y22;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round(x1 * 2) === round(x22 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
  }
  if (round(y1 * 2) === round(y22 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize(originX, lineWidth, true);
  outputShape.y = subPixelOptimize(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize(position, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position;
  }
  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

// node_modules/zrender/lib/graphic/shape/Rect.js
var RectShape = function() {
  function RectShape2() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
  return RectShape2;
}();
var subPixelOptimizeOutputShape = {};
var Rect = function(_super) {
  __extends2(Rect2, _super);
  function Rect2(opts) {
    return _super.call(this, opts) || this;
  }
  Rect2.prototype.getDefaultShape = function() {
    return new RectShape;
  };
  Rect2.prototype.buildPath = function(ctx, shape) {
    var x3;
    var y3;
    var width;
    var height;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
      x3 = optimizedShape.x;
      y3 = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x3 = shape.x;
      y3 = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x3, y3, width, height);
    } else {
      buildPath(ctx, shape);
    }
  };
  Rect2.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  };
  return Rect2;
}(Path_default);
Rect.prototype.type = "rect";
var Rect_default = Rect;

// node_modules/zrender/lib/graphic/Text.js
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = function(_super) {
  __extends2(ZRText2, _super);
  function ZRText2(opts) {
    var _this = _super.call(this) || this;
    _this.type = "text";
    _this._children = [];
    _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    _this.attr(opts);
    return _this;
  }
  ZRText2.prototype.childrenRef = function() {
    return this._children;
  };
  ZRText2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (var i3 = 0;i3 < this._children.length; i3++) {
      var child = this._children[i3];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  };
  ZRText2.prototype.updateTransform = function() {
    var innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      _super.prototype.updateTransform.call(this);
    }
  };
  ZRText2.prototype.getLocalTransform = function(m4) {
    var innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m4) : _super.prototype.getLocalTransform.call(this, m4);
  };
  ZRText2.prototype.getComputedTransform = function() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return _super.prototype.getComputedTransform.call(this);
  };
  ZRText2.prototype._updateSubTexts = function() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  };
  ZRText2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i3 = 0;i3 < this._children.length; i3++) {
      this._children[i3].__zr = zr;
    }
  };
  ZRText2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i3 = 0;i3 < this._children.length; i3++) {
      this._children[i3].__zr = null;
    }
  };
  ZRText2.prototype.getBoundingRect = function() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
      var children = this._children;
      var tmpMat = [];
      var rect = null;
      for (var i3 = 0;i3 < children.length; i3++) {
        var child = children[i3];
        var childRect = child.getBoundingRect();
        var transform = child.getLocalTransform(tmpMat);
        if (transform) {
          tmpRect2.copy(childRect);
          tmpRect2.applyTransform(transform);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect2;
    }
    return this._rect;
  };
  ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  };
  ZRText2.prototype.setTextContent = function(textContent) {
    if (true) {
      throw new Error("Can't attach text on another text");
    }
  };
  ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    var sourceRich = sourceStyle.rich;
    var targetRich = targetStyle.rich || sourceRich && {};
    extend(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  };
  ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
    var richNames = keys(sourceRich);
    for (var i3 = 0;i3 < richNames.length; i3++) {
      var richName = richNames[i3];
      targetRich[richName] = targetRich[richName] || {};
      extend(targetRich[richName], sourceRich[richName]);
    }
  };
  ZRText2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  };
  ZRText2.prototype._getOrCreateChild = function(Ctor) {
    var child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor;
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  };
  ZRText2.prototype._updatePlainTexts = function() {
    var style = this.style;
    var textFont = style.font || DEFAULT_FONT;
    var textPadding = style.padding;
    var text = getStyleText(style);
    var contentBlock = parsePlainText(text, style);
    var needDrawBg = needDrawBackground(style);
    var bgColorDrawn = !!style.backgroundColor;
    var outerHeight = contentBlock.outerHeight;
    var outerWidth = contentBlock.outerWidth;
    var contentWidth = contentBlock.contentWidth;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var defaultStyle = this._defaultStyle;
    this.isTruncated = !!contentBlock.isTruncated;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.align || defaultStyle.align || "left";
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    var textX = baseX;
    var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    var defaultLineWidth = 0;
    var useDefaultFill = false;
    var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow = style.textShadowBlur > 0;
    var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    var calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (var i3 = 0;i3 < textLines.length; i3++) {
      var el = this._getOrCreateChild(TSpan_default);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i3];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, contentWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  };
  ZRText2.prototype._updateRichTexts = function() {
    var style = this.style;
    var text = getStyleText(style);
    var contentBlock = parseRichText(text, style);
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.padding;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var defaultStyle = this._defaultStyle;
    var textAlign = style.align || defaultStyle.align;
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    this.isTruncated = !!contentBlock.isTruncated;
    var boxX = adjustTextX(baseX, outerWidth, textAlign);
    var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    var bgColorDrawn = !!style.backgroundColor;
    for (var i3 = 0;i3 < contentBlock.lines.length; i3++) {
      var line = contentBlock.lines[i3];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var remainedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token = undefined;
      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  };
  ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x3, textAlign, parentBgColorDrawn) {
    var tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    var verticalAlign = token.verticalAlign;
    var y3 = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y3 = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y3 = lineTop + lineHeight - token.height / 2;
    }
    var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x3 - token.width : textAlign === "center" ? x3 - token.width / 2 : x3, y3 - token.height / 2, token.width, token.height);
    var bgColorDrawn = !!tokenStyle.backgroundColor;
    var textPadding = token.textPadding;
    if (textPadding) {
      x3 = getTextXForPadding(x3, textAlign, textPadding);
      y3 -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    var el = this._getOrCreateChild(TSpan_default);
    var subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    var defaultStyle = this._defaultStyle;
    var useDefaultFill = false;
    var defaultLineWidth = 0;
    var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : ("fill" in style) ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : ("stroke" in style) ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x3;
    subElStyle.y = y3;
    if (hasShadow) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    var textWidth = token.contentWidth;
    var textHeight = token.contentHeight;
    el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  };
  ZRText2.prototype._renderBackground = function(style, topStyle, x3, y3, width, height) {
    var textBackgroundColor = style.backgroundColor;
    var textBorderWidth = style.borderWidth;
    var textBorderColor = style.borderColor;
    var isImageBg = textBackgroundColor && textBackgroundColor.image;
    var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    var textBorderRadius = style.borderRadius;
    var self2 = this;
    var rectEl;
    var imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect_default);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      var rectShape = rectEl.shape;
      rectShape.x = x3;
      rectShape.y = y3;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      var rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(Image_default);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      var imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x3;
      imgStyle.y = y3;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      var rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    var commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  };
  ZRText2.makeFont = function(style) {
    var font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim(font) || style.textFont || style.font;
  };
  return ZRText2;
}(Displayable_default);
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (var i3 = 0;i3 < FONT_PARTS.length; i3++) {
    var fontProp = FONT_PARTS[i3];
    var val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    var textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    var textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x3, textAlign, textPadding) {
  return textAlign === "right" ? x3 - textPadding[1] : textAlign === "center" ? x3 + textPadding[3] / 2 - textPadding[1] / 2 : x3 + textPadding[3];
}
function getStyleText(style) {
  var text = style.text;
  text != null && (text += "");
  return text;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var Text_default = ZRText;

// node_modules/echarts/lib/util/number.js
var RADIAN_EPSILON = 0.0001;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap(val, domain, range, clamp) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range[0];
  var r1 = range[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
function parsePercent2(percent, all) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round2(x3, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x3 = (+x3).toFixed(precision);
  return returnStr ? x3 : +x3;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 0.00000000000001) {
    var e3 = 1;
    for (var i3 = 0;i3 < 15; i3++, e3 *= 10) {
      if (Math.round(val * e3) / e3 === val) {
        return i3;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  var str = val.toString().toLowerCase();
  var eIndex = str.indexOf("e");
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf(".");
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentSeats(valueList, precision) {
  var sum = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum === 0) {
    return [];
  }
  var digits = Math.pow(10, precision);
  var votesPerQuota = map(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  var currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  var remainder = map(votesPerQuota, function(votes, idx) {
    return votes - seats[idx];
  });
  while (currentSum < targetSeats) {
    var max3 = Number.NEGATIVE_INFINITY;
    var maxId = null;
    for (var i3 = 0, len2 = remainder.length;i3 < len2; ++i3) {
      if (remainder[i3] > max3) {
        max3 = remainder[i3];
        maxId = i3;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return map(seats, function(seat) {
    return seat / digits;
  });
}
function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  var sum = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round2(sum, maxPrecision);
}
function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value2) {
  if (value2 instanceof Date) {
    return value2;
  } else if (isString(value2)) {
    var match = TIME_REG.exec(value2);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      var hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value2 == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value2));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  var exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round3) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f3 = val / exp10;
  var nf;
  if (round3) {
    if (f3 < 1.5) {
      nf = 1;
    } else if (f3 < 2.5) {
      nf = 2;
    } else if (f3 < 4) {
      nf = 3;
    } else if (f3 < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f3 < 1) {
      nf = 1;
    } else if (f3 < 2) {
      nf = 2;
    } else if (f3 < 3) {
      nf = 3;
    } else if (f3 < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function numericToNumber(val) {
  var valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a3, b) {
  if (b === 0) {
    return a3;
  }
  return getGreatestCommonDividor(b, a3 % b);
}
function getLeastCommonMultiple(a3, b) {
  if (a3 == null) {
    return b;
  }
  if (b == null) {
    return a3;
  }
  return a3 * b / getGreatestCommonDividor(a3, b);
}

// node_modules/echarts/lib/util/log.js
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }
      storedLogs[str] = true;
    }
    console[type](ECHARTS_PREFIX + str);
  }
}
function log(str, onlyOnce) {
  outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
  outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
  outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
  if (true) {
    outputLog("warn", "DEPRECATED: " + str, true);
  }
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
  if (true) {
    deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated, use " + newOpt + " instead."));
  }
}
function makePrintable() {
  var hintInfo = [];
  for (var _i = 0;_i < arguments.length; _i++) {
    hintInfo[_i] = arguments[_i];
  }
  var msg = "";
  if (true) {
    var makePrintableStringIfPossible_1 = function(val) {
      return val === undefined ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
    };
    msg = map(hintInfo, function(arg) {
      if (isString(arg)) {
        return arg;
      } else {
        var printableStr = makePrintableStringIfPossible_1(arg);
        if (printableStr != null) {
          return printableStr;
        } else if (typeof JSON !== "undefined" && JSON.stringify) {
          try {
            return JSON.stringify(arg, function(n3, val) {
              var printableStr2 = makePrintableStringIfPossible_1(val);
              return printableStr2 == null ? val : printableStr2;
            });
          } catch (err) {
            return "?";
          }
        } else {
          return "?";
        }
      }
    }).join(" ");
  }
  return msg;
}
function throwError(msg) {
  throw new Error(msg);
}

// node_modules/echarts/lib/util/model.js
function interpolateNumber2(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\x00";
var INTERNAL_COMPONENT_ID_PREFIX = "\x00_ec_\x00";
function normalizeToArray(value2) {
  return value2 instanceof Array ? value2 : value2 == null ? [] : [value2];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (var i3 = 0, len2 = subOpts.length;i3 < len2; i3++) {
      var subOptName = subOpts[i3];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(dataItem) {
  return isObject2(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject2(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === "normalMerge";
  var isReplaceMergeMode = mode === "replaceMerge";
  var isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap();
  each(newCmptOptions, function(cmptOption, index) {
    if (!isObject2(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }
    if (true) {
      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
        warnInvalidateIdOrName(cmptOption.id);
      }
      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
        warnInvalidateIdOrName(cmptOption.name);
      }
    }
  });
  var result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  var result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (var index = 0;index < existings.length; index++) {
    var existing = existings[index];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (var i3 = 0;i3 < result.length; i3++) {
      var existing = result[i3].existing;
      if (!result[i3].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i3].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    var resultItem;
    var nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  var idMap = createHashMap();
  each(mapResult, function(item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each(mapResult, function(item) {
    var opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each(mapResult, function(item, index) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;
    if (!isObject2(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\x00" + keyInfo.name + "\x00" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr], null);
  var key2 = convertOptionIdName(obj2[attr], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  if (true) {
    if (val == null) {
      throw new Error;
    }
  }
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
  if (true) {
    warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
  }
}
function isValidIdOrName(idOrName) {
  return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
  var name = componentModel.name;
  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each(mappingResult, function(item) {
    var newOption = item.newOption;
    if (isObject2(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray(payload.dataIndex) ? map(payload.dataIndex, function(value2) {
      return data.indexOfRawIndex(value2);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray(payload.name) ? map(payload.name, function(value2) {
      return data.indexOfName(value2);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  var key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder(ecModel, finderInput, opt) {
  var _a = preParseFinder(finderInput, opt), mainTypeSpecified = _a.mainTypeSpecified, queryOptionMap = _a.queryOptionMap, others = _a.others;
  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;
  if (isString(finderInput)) {
    var obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each(finder, function(value2, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value2;
      return;
    }
    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value2;
  });
  return {
    mainTypeSpecified,
    queryOptionMap,
    others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    var firstCmpt = undefined;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value2) {
  dom.setAttribute ? dom.setAttribute(key, value2) : dom[key] = value2;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env_default.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber(targetValue)) {
    var value2 = interpolateNumber2(sourceValue || 0, targetValue, percent);
    return round2(value2, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (var i3 = 0;i3 < length_1; ++i3) {
      var info = data.getDimensionInfo(i3);
      if (info && info.type === "ordinal") {
        interpolated[i3] = (percent < 1 && leftArr ? leftArr : rightArr)[i3];
      } else {
        var leftVal = leftArr && leftArr[i3] ? leftArr[i3] : 0;
        var rightVal = rightArr[i3];
        var value2 = interpolateNumber2(leftVal, rightVal, percent);
        interpolated[i3] = round2(value2, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}

// node_modules/echarts/lib/util/innerStore.js
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
  if (el) {
    var ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    ecData.ssrType = "chart";
    if (el.type === "group") {
      el.traverse(function(child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
        childECData.ssrType = "chart";
      });
    }
  }
};

// node_modules/echarts/lib/util/states.js
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
  var style = el.style;
  var fromState = {};
  for (var i3 = 0;i3 < props.length; i3++) {
    var propName = props[i3];
    var val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (var i3 = 0;i3 < el.animators.length; i3++) {
    var animator = el.animators[i3];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
  var cloned = false;
  if (el instanceof Path_default) {
    var store = getSavedStates(el);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend({}, state);
      }
      var z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend({}, state);
      var z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  var hasBlur = indexOf(el.currentStates, stateName) >= 0;
  var currentOpacity = el.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend({}, state);
    blurStyle = extend({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  var textContent = el.getTextContent();
  var textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e3) {
  !shouldSilent(el, e3) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e3) {
  !shouldSilent(el, e3) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e3) {
  return el.__highDownSilentOnTouch && e3.zrByTouch;
}
function allLeaveBlur(api) {
  var model = api.getModel();
  var leaveBlurredSeries = [];
  var allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    var isSeries = componentType === "series";
    var view = isSeries ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
    !isSeries && allComponentViews.push(view);
    if (componentStates.isBlured) {
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each(allComponentViews, function(view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (var i3 = 0;i3 < dataIndices.length; i3++) {
      var itemEl = data.getItemGraphicEl(dataIndices[i3]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  var blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      var view = api.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        if (child.__highByOuter && sameSeries && focus === "self") {
          return;
        }
        singleEnterBlur(child);
      });
      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject2(focus)) {
        var dataTypes = keys(focus);
        for (var d3 = 0;d3 < dataTypes.length; d3++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d3]), focus[dataTypes[d3]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data = seriesModel.getData(payload.dataType);
  if (!data) {
    if (true) {
      error("Unknown dataType " + payload.dataType);
    }
    return;
  }
  var dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    var count = data.count();
    var current = 0;
    while (!el && current < count) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    var ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    var focus_1 = seriesModel.get(["emphasis", "focus"]);
    var blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
  var ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
    return ret;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }
  var dispatchers = view.findHighDownDispatchers(name);
  var focusSelf;
  for (var i3 = 0;i3 < dispatchers.length; i3++) {
    if (!isHighDownDispatcher(dispatchers[i3])) {
      error("param should be highDownDispatcher");
    }
    if (getECData(dispatchers[i3]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {
    focusSelf,
    dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e3, api) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  var ecData = getECData(dispatcher);
  var _a = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a.dispatchers, focusSelf = _a.focusSelf;
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    each(dispatchers, function(dispatcher2) {
      return enterEmphasisWhenMouseOver(dispatcher2, e3);
    });
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    enterEmphasisWhenMouseOver(dispatcher, e3);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e3, api) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
  if (dispatchers) {
    each(dispatchers, function(dispatcher2) {
      return leaveEmphasisWhenMouseOut(dispatcher2, e3);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e3);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  var dataType = payload.dataType;
  var data = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data, payload);
  if (!isArray(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each(allData, function(_a) {
    var { data, type } = _a;
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret = [];
  ecModel.eachSeries(function(seriesModel) {
    var allData = seriesModel.getAllData();
    each(allData, function(_a) {
      var { data, type } = _a;
      var dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  var ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (var i3 = 0;i3 < OTHER_STATES.length; i3++) {
    var stateName = OTHER_STATES[i3];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  var store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  var selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}

// node_modules/echarts/lib/util/graphic.js
var exports_graphic = {};
__export(exports_graphic, {
  updateProps: () => updateProps,
  traverseElements: () => traverseElements,
  transformDirection: () => transformDirection,
  subPixelOptimizeRect: () => subPixelOptimizeRect2,
  subPixelOptimizeLine: () => subPixelOptimizeLine2,
  subPixelOptimize: () => subPixelOptimize2,
  setTooltipConfig: () => setTooltipConfig,
  resizePath: () => resizePath,
  removeElementWithFadeOut: () => removeElementWithFadeOut,
  removeElement: () => removeElement,
  registerShape: () => registerShape,
  mergePath: () => mergePath2,
  makePath: () => makePath,
  makeImage: () => makeImage,
  linePolygonIntersect: () => linePolygonIntersect,
  lineLineIntersect: () => lineLineIntersect,
  isElementRemoved: () => isElementRemoved,
  initProps: () => initProps,
  groupTransition: () => groupTransition,
  getTransform: () => getTransform,
  getShapeClass: () => getShapeClass,
  extendShape: () => extendShape,
  extendPath: () => extendPath,
  createIcon: () => createIcon,
  clipRectByRect: () => clipRectByRect,
  clipPointsByRect: () => clipPointsByRect,
  applyTransform: () => applyTransform2,
  Text: () => Text_default,
  Sector: () => Sector_default,
  Ring: () => Ring_default,
  Rect: () => Rect_default,
  RadialGradient: () => RadialGradient_default,
  Polyline: () => Polyline_default,
  Polygon: () => Polygon_default,
  Point: () => Point_default,
  Path: () => Path_default,
  OrientedBoundingRect: () => OrientedBoundingRect_default,
  LinearGradient: () => LinearGradient_default,
  Line: () => Line_default,
  IncrementalDisplayable: () => IncrementalDisplayable_default,
  Image: () => Image_default,
  Group: () => Group_default,
  Ellipse: () => Ellipse_default,
  CompoundPath: () => CompoundPath_default,
  Circle: () => Circle_default,
  BoundingRect: () => BoundingRect_default,
  BezierCurve: () => BezierCurve_default,
  Arc: () => Arc_default
});

// node_modules/zrender/lib/tool/transformPath.js
var CMD3 = PathProxy_default.CMD;
var points = [[], [], []];
var mathSqrt2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m4) {
  if (!m4) {
    return;
  }
  var data = path.data;
  var len2 = path.len();
  var cmd;
  var nPoint;
  var i3;
  var j3;
  var k3;
  var p3;
  var M2 = CMD3.M;
  var C3 = CMD3.C;
  var L2 = CMD3.L;
  var R = CMD3.R;
  var A3 = CMD3.A;
  var Q2 = CMD3.Q;
  for (i3 = 0, j3 = 0;i3 < len2; ) {
    cmd = data[i3++];
    j3 = i3;
    nPoint = 0;
    switch (cmd) {
      case M2:
        nPoint = 1;
        break;
      case L2:
        nPoint = 1;
        break;
      case C3:
        nPoint = 3;
        break;
      case Q2:
        nPoint = 2;
        break;
      case A3:
        var x3 = m4[4];
        var y3 = m4[5];
        var sx = mathSqrt2(m4[0] * m4[0] + m4[1] * m4[1]);
        var sy = mathSqrt2(m4[2] * m4[2] + m4[3] * m4[3]);
        var angle = mathAtan2(-m4[1] / sy, m4[0] / sx);
        data[i3] *= sx;
        data[i3++] += x3;
        data[i3] *= sy;
        data[i3++] += y3;
        data[i3++] *= sx;
        data[i3++] *= sy;
        data[i3++] += angle;
        data[i3++] += angle;
        i3 += 2;
        j3 = i3;
        break;
      case R:
        p3[0] = data[i3++];
        p3[1] = data[i3++];
        applyTransform(p3, p3, m4);
        data[j3++] = p3[0];
        data[j3++] = p3[1];
        p3[0] += data[i3++];
        p3[1] += data[i3++];
        applyTransform(p3, p3, m4);
        data[j3++] = p3[0];
        data[j3++] = p3[1];
    }
    for (k3 = 0;k3 < nPoint; k3++) {
      var p_1 = points[k3];
      p_1[0] = data[i3++];
      p_1[1] = data[i3++];
      applyTransform(p_1, p_1, m4);
      data[j3++] = p_1[0];
      data[j3++] = p_1[1];
    }
  }
  path.increaseVersion();
}

// node_modules/zrender/lib/tool/path.js
var mathSqrt3 = Math.sqrt;
var mathSin3 = Math.sin;
var mathCos3 = Math.cos;
var PI3 = Math.PI;
function vMag(v3) {
  return Math.sqrt(v3[0] * v3[0] + v3[1] * v3[1]);
}
function vRatio(u3, v3) {
  return (u3[0] * v3[0] + u3[1] * v3[1]) / (vMag(u3) * vMag(v3));
}
function vAngle(u3, v3) {
  return (u3[0] * v3[1] < u3[1] * v3[0] ? -1 : 1) * Math.acos(vRatio(u3, v3));
}
function processArc(x1, y1, x22, y22, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI3 / 180);
  var xp = mathCos3(psi) * (x1 - x22) / 2 + mathSin3(psi) * (y1 - y22) / 2;
  var yp = -1 * mathSin3(psi) * (x1 - x22) / 2 + mathCos3(psi) * (y1 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt3(lambda);
    ry *= mathSqrt3(lambda);
  }
  var f3 = (fa === fs ? -1 : 1) * mathSqrt3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f3 * rx * yp / ry;
  var cyp = f3 * -ry * xp / rx;
  var cx = (x1 + x22) / 2 + mathCos3(psi) * cxp - mathSin3(psi) * cyp;
  var cy = (y1 + y22) / 2 + mathSin3(psi) * cxp + mathCos3(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u3 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v3 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u3, v3);
  if (vRatio(u3, v3) <= -1) {
    dTheta = PI3;
  }
  if (vRatio(u3, v3) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    var n3 = Math.round(dTheta / PI3 * 1e6) / 1e6;
    dTheta = PI3 * 2 + n3 % 2 * PI3;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  var path = new PathProxy_default;
  if (!data) {
    return path;
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var CMD4 = PathProxy_default.CMD;
  var cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (var l3 = 0;l3 < cmdList.length; l3++) {
    var cmdText = cmdList[l3];
    var cmdStr = cmdText.charAt(0);
    var cmd = undefined;
    var p3 = cmdText.match(numberReg) || [];
    var pLen = p3.length;
    for (var i3 = 0;i3 < pLen; i3++) {
      p3[i3] = parseFloat(p3[i3]);
    }
    var off = 0;
    while (off < pLen) {
      var ctlPtx = undefined;
      var ctlPty = undefined;
      var rx = undefined;
      var ry = undefined;
      var psi = undefined;
      var fa = undefined;
      var fs = undefined;
      var x1 = cpx;
      var y1 = cpy;
      var len2 = undefined;
      var pathData = undefined;
      switch (cmdStr) {
        case "l":
          cpx += p3[off++];
          cpy += p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p3[off++];
          cpy = p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p3[off++];
          cpy += p3[off++];
          cmd = CMD4.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p3[off++];
          cpy = p3[off++];
          cmd = CMD4.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p3[off++];
          cmd = CMD4.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD4.C;
          path.addData(cmd, p3[off++], p3[off++], p3[off++], p3[off++], p3[off++], p3[off++]);
          cpx = p3[off - 2];
          cpy = p3[off - 1];
          break;
        case "c":
          cmd = CMD4.C;
          path.addData(cmd, p3[off++] + cpx, p3[off++] + cpy, p3[off++] + cpx, p3[off++] + cpy, p3[off++] + cpx, p3[off++] + cpy);
          cpx += p3[off - 2];
          cpy += p3[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD4.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD4.C;
          x1 = p3[off++];
          y1 = p3[off++];
          cpx = p3[off++];
          cpy = p3[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD4.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD4.C;
          x1 = cpx + p3[off++];
          y1 = cpy + p3[off++];
          cpx += p3[off++];
          cpy += p3[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p3[off++];
          y1 = p3[off++];
          cpx = p3[off++];
          cpy = p3[off++];
          cmd = CMD4.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p3[off++] + cpx;
          y1 = p3[off++] + cpy;
          cpx += p3[off++];
          cpy += p3[off++];
          cmd = CMD4.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD4.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p3[off++];
          cpy = p3[off++];
          cmd = CMD4.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD4.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p3[off++];
          cpy += p3[off++];
          cmd = CMD4.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p3[off++];
          ry = p3[off++];
          psi = p3[off++];
          fa = p3[off++];
          fs = p3[off++];
          x1 = cpx, y1 = cpy;
          cpx = p3[off++];
          cpy = p3[off++];
          cmd = CMD4.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p3[off++];
          ry = p3[off++];
          psi = p3[off++];
          fa = p3[off++];
          fs = p3[off++];
          x1 = cpx, y1 = cpy;
          cpx += p3[off++];
          cpy += p3[off++];
          cmd = CMD4.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD4.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = function(_super) {
  __extends2(SVGPath2, _super);
  function SVGPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGPath2.prototype.applyTransform = function(m4) {};
  return SVGPath2;
}(Path_default);
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  var innerOpts = extend({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m4) {
    transformPath(pathProxy, m4);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  var innerOpts = createPathOptions(str, defaultOpts);
  var Sub = function(_super) {
    __extends2(Sub2, _super);
    function Sub2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.applyTransform = innerOpts.applyTransform;
      _this.buildPath = innerOpts.buildPath;
      return _this;
    }
    return Sub2;
  }(SVGPath);
  return Sub;
}
function mergePath(pathEls, opts) {
  var pathList = [];
  var len2 = pathEls.length;
  for (var i3 = 0;i3 < len2; i3++) {
    var pathEl = pathEls[i3];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  var pathBundle = new Path_default(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}

// node_modules/zrender/lib/graphic/Group.js
var Group = function(_super) {
  __extends2(Group2, _super);
  function Group2(opts) {
    var _this = _super.call(this) || this;
    _this.isGroup = true;
    _this._children = [];
    _this.attr(opts);
    return _this;
  }
  Group2.prototype.childrenRef = function() {
    return this._children;
  };
  Group2.prototype.children = function() {
    return this._children.slice();
  };
  Group2.prototype.childAt = function(idx) {
    return this._children[idx];
  };
  Group2.prototype.childOfName = function(name) {
    var children = this._children;
    for (var i3 = 0;i3 < children.length; i3++) {
      if (children[i3].name === name) {
        return children[i3];
      }
    }
  };
  Group2.prototype.childCount = function() {
    return this._children.length;
  };
  Group2.prototype.add = function(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
      if (true) {
        if (child.__hostTarget) {
          throw "This elemenet has been used as an attachment";
        }
      }
    }
    return this;
  };
  Group2.prototype.addBefore = function(child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.replace = function(oldChild, newChild) {
    var idx = indexOf(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  };
  Group2.prototype.replaceAt = function(child, index) {
    var children = this._children;
    var old = children[index];
    if (child && child !== this && child.parent !== this && child !== old) {
      children[index] = child;
      old.parent = null;
      var zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  };
  Group2.prototype._doAdd = function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  };
  Group2.prototype.remove = function(child) {
    var zr = this.__zr;
    var children = this._children;
    var idx = indexOf(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  };
  Group2.prototype.removeAll = function() {
    var children = this._children;
    var zr = this.__zr;
    for (var i3 = 0;i3 < children.length; i3++) {
      var child = children[i3];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  };
  Group2.prototype.eachChild = function(cb, context) {
    var children = this._children;
    for (var i3 = 0;i3 < children.length; i3++) {
      var child = children[i3];
      cb.call(context, child, i3);
    }
    return this;
  };
  Group2.prototype.traverse = function(cb, context) {
    for (var i3 = 0;i3 < this._children.length; i3++) {
      var child = this._children[i3];
      var stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  };
  Group2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i3 = 0;i3 < this._children.length; i3++) {
      var child = this._children[i3];
      child.addSelfToZr(zr);
    }
  };
  Group2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i3 = 0;i3 < this._children.length; i3++) {
      var child = this._children[i3];
      child.removeSelfFromZr(zr);
    }
  };
  Group2.prototype.getBoundingRect = function(includeChildren) {
    var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];
    var rect = null;
    for (var i3 = 0;i3 < children.length; i3++) {
      var child = children[i3];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat);
      if (transform) {
        BoundingRect_default.applyTransform(tmpRect2, childRect, transform);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  };
  return Group2;
}(Element_default);
Group.prototype.type = "group";
var Group_default = Group;

// node_modules/zrender/lib/graphic/shape/Circle.js
var CircleShape = function() {
  function CircleShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
  return CircleShape2;
}();
var Circle = function(_super) {
  __extends2(Circle2, _super);
  function Circle2(opts) {
    return _super.call(this, opts) || this;
  }
  Circle2.prototype.getDefaultShape = function() {
    return new CircleShape;
  };
  Circle2.prototype.buildPath = function(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  };
  return Circle2;
}(Path_default);
Circle.prototype.type = "circle";
var Circle_default = Circle;

// node_modules/zrender/lib/graphic/shape/Ellipse.js
var EllipseShape = function() {
  function EllipseShape2() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
  return EllipseShape2;
}();
var Ellipse = function(_super) {
  __extends2(Ellipse2, _super);
  function Ellipse2(opts) {
    return _super.call(this, opts) || this;
  }
  Ellipse2.prototype.getDefaultShape = function() {
    return new EllipseShape;
  };
  Ellipse2.prototype.buildPath = function(ctx, shape) {
    var k3 = 0.5522848;
    var x3 = shape.cx;
    var y3 = shape.cy;
    var a3 = shape.rx;
    var b = shape.ry;
    var ox = a3 * k3;
    var oy = b * k3;
    ctx.moveTo(x3 - a3, y3);
    ctx.bezierCurveTo(x3 - a3, y3 - oy, x3 - ox, y3 - b, x3, y3 - b);
    ctx.bezierCurveTo(x3 + ox, y3 - b, x3 + a3, y3 - oy, x3 + a3, y3);
    ctx.bezierCurveTo(x3 + a3, y3 + oy, x3 + ox, y3 + b, x3, y3 + b);
    ctx.bezierCurveTo(x3 - ox, y3 + b, x3 - a3, y3 + oy, x3 - a3, y3);
    ctx.closePath();
  };
  return Ellipse2;
}(Path_default);
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse;

// node_modules/zrender/lib/graphic/helper/roundSector.js
var PI5 = Math.PI;
var PI26 = PI5 * 2;
var mathSin4 = Math.sin;
var mathCos4 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs2 = Math.abs;
var mathSqrt4 = Math.sqrt;
var mathMax4 = Math.max;
var mathMin4 = Math.min;
var e3 = 0.0001;
function intersect(x0, y0, x1, y1, x22, y22, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x22;
  var dy32 = y3 - y22;
  var t4 = dy32 * dx10 - dx32 * dy10;
  if (t4 * t4 < e3) {
    return;
  }
  t4 = (dx32 * (y0 - y22) - dy32 * (x0 - x22)) / t4;
  return [x0 + t4 * dx10, y0 + t4 * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt4(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d22 = dx * dx + dy * dy;
  var r3 = radius - cr;
  var s3 = x11 * y10 - x10 * y11;
  var d3 = (dy < 0 ? -1 : 1) * mathSqrt4(mathMax4(0, r3 * r3 * d22 - s3 * s3));
  var cx0 = (s3 * dy - dx * d3) / d22;
  var cy0 = (-s3 * dx - dy * d3) / d22;
  var cx1 = (s3 * dy + dx * d3) / d22;
  var cy1 = (-s3 * dx + dy * d3) / d22;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r3 - 1),
    y1: cy0 * (radius / r3 - 1)
  };
}
function normalizeCornerRadius(cr) {
  var arr;
  if (isArray(cr)) {
    var len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath2(ctx, shape) {
  var _a;
  var radius = mathMax4(shape.r, 0);
  var innerRadius = mathMax4(shape.r0 || 0, 0);
  var hasRadius = radius > 0;
  var hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    var tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  var { startAngle, endAngle } = shape;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  var { cx, cy } = shape;
  var clockwise = !!shape.clockwise;
  var arc = mathAbs2(endAngle - startAngle);
  var mod = arc > PI26 && arc % PI26;
  mod > e3 && (arc = mod);
  if (!(radius > e3)) {
    ctx.moveTo(cx, cy);
  } else if (arc > PI26 - e3) {
    ctx.moveTo(cx + radius * mathCos4(startAngle), cy + radius * mathSin4(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e3) {
      ctx.moveTo(cx + innerRadius * mathCos4(endAngle), cy + innerRadius * mathSin4(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    var icrStart = undefined;
    var icrEnd = undefined;
    var ocrStart = undefined;
    var ocrEnd = undefined;
    var ocrs = undefined;
    var ocre = undefined;
    var icrs = undefined;
    var icre = undefined;
    var ocrMax = undefined;
    var icrMax = undefined;
    var limitedOcrMax = undefined;
    var limitedIcrMax = undefined;
    var xre = undefined;
    var yre = undefined;
    var xirs = undefined;
    var yirs = undefined;
    var xrs = radius * mathCos4(startAngle);
    var yrs = radius * mathSin4(startAngle);
    var xire = innerRadius * mathCos4(endAngle);
    var yire = innerRadius * mathSin4(endAngle);
    var hasArc = arc > e3;
    if (hasArc) {
      var cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        _a = normalizeCornerRadius(cornerRadius), icrStart = _a[0], icrEnd = _a[1], ocrStart = _a[2], ocrEnd = _a[3];
      }
      var halfRd = mathAbs2(radius - innerRadius) / 2;
      ocrs = mathMin4(halfRd, ocrStart);
      ocre = mathMin4(halfRd, ocrEnd);
      icrs = mathMin4(halfRd, icrStart);
      icre = mathMin4(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax4(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax4(icrs, icre);
      if (ocrMax > e3 || icrMax > e3) {
        xre = radius * mathCos4(endAngle);
        yre = radius * mathSin4(endAngle);
        xirs = innerRadius * mathCos4(startAngle);
        yirs = innerRadius * mathSin4(startAngle);
        if (arc < PI5) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a3 = 1 / mathSin4(mathACos((x0 * x1 + y0 * y1) / (mathSqrt4(x0 * x0 + y0 * y0) * mathSqrt4(x1 * x1 + y1 * y1))) / 2);
            var b = mathSqrt4(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOcrMax = mathMin4(ocrMax, (radius - b) / (a3 + 1));
            limitedIcrMax = mathMin4(icrMax, (innerRadius - b) / (a3 - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e3) {
      var crStart = mathMin4(ocrStart, limitedOcrMax);
      var crEnd = mathMin4(ocrEnd, limitedOcrMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e3) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e3) {
      var crStart = mathMin4(icrStart, limitedIcrMax);
      var crEnd = mathMin4(icrEnd, limitedIcrMax);
      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}

// node_modules/zrender/lib/graphic/shape/Sector.js
var SectorShape = function() {
  function SectorShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
  return SectorShape2;
}();
var Sector = function(_super) {
  __extends2(Sector2, _super);
  function Sector2(opts) {
    return _super.call(this, opts) || this;
  }
  Sector2.prototype.getDefaultShape = function() {
    return new SectorShape;
  };
  Sector2.prototype.buildPath = function(ctx, shape) {
    buildPath2(ctx, shape);
  };
  Sector2.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  };
  return Sector2;
}(Path_default);
Sector.prototype.type = "sector";
var Sector_default = Sector;

// node_modules/zrender/lib/graphic/shape/Ring.js
var RingShape = function() {
  function RingShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
  return RingShape2;
}();
var Ring = function(_super) {
  __extends2(Ring2, _super);
  function Ring2(opts) {
    return _super.call(this, opts) || this;
  }
  Ring2.prototype.getDefaultShape = function() {
    return new RingShape;
  };
  Ring2.prototype.buildPath = function(ctx, shape) {
    var x3 = shape.cx;
    var y3 = shape.cy;
    var PI27 = Math.PI * 2;
    ctx.moveTo(x3 + shape.r, y3);
    ctx.arc(x3, y3, shape.r, 0, PI27, false);
    ctx.moveTo(x3 + shape.r0, y3);
    ctx.arc(x3, y3, shape.r0, 0, PI27, true);
  };
  return Ring2;
}(Path_default);
Ring.prototype.type = "ring";
var Ring_default = Ring;

// node_modules/zrender/lib/graphic/helper/smoothBezier.js
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v3 = [];
  var v1 = [];
  var v22 = [];
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (var i3 = 0, len2 = points2.length;i3 < len2; i3++) {
      min(min3, min3, points2[i3]);
      max(max3, max3, points2[i3]);
    }
    min(min3, min3, constraint[0]);
    max(max3, max3, constraint[1]);
  }
  for (var i3 = 0, len2 = points2.length;i3 < len2; i3++) {
    var point = points2[i3];
    if (isLoop) {
      prevPoint = points2[i3 ? i3 - 1 : len2 - 1];
      nextPoint = points2[(i3 + 1) % len2];
    } else {
      if (i3 === 0 || i3 === len2 - 1) {
        cps.push(clone2(points2[i3]));
        continue;
      } else {
        prevPoint = points2[i3 - 1];
        nextPoint = points2[i3 + 1];
      }
    }
    sub(v3, nextPoint, prevPoint);
    scale2(v3, v3, smooth);
    var d0 = distance(point, prevPoint);
    var d1 = distance(point, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    scale2(v1, v3, -d0);
    scale2(v22, v3, d1);
    var cp0 = add([], point, v1);
    var cp1 = add([], point, v22);
    if (constraint) {
      max(cp0, cp0, min3);
      min(cp0, cp0, max3);
      max(cp1, cp1, min3);
      min(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}

// node_modules/zrender/lib/graphic/helper/poly.js
function buildPath3(ctx, shape, closePath) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (points2 && points2.length >= 2) {
    if (smooth) {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len2 = points2.length;
      for (var i3 = 0;i3 < (closePath ? len2 : len2 - 1); i3++) {
        var cp1 = controlPoints[i3 * 2];
        var cp2 = controlPoints[i3 * 2 + 1];
        var p3 = points2[(i3 + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]);
      }
    } else {
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i3 = 1, l3 = points2.length;i3 < l3; i3++) {
        ctx.lineTo(points2[i3][0], points2[i3][1]);
      }
    }
    closePath && ctx.closePath();
  }
}

// node_modules/zrender/lib/graphic/shape/Polygon.js
var PolygonShape = function() {
  function PolygonShape2() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolygonShape2;
}();
var Polygon = function(_super) {
  __extends2(Polygon2, _super);
  function Polygon2(opts) {
    return _super.call(this, opts) || this;
  }
  Polygon2.prototype.getDefaultShape = function() {
    return new PolygonShape;
  };
  Polygon2.prototype.buildPath = function(ctx, shape) {
    buildPath3(ctx, shape, true);
  };
  return Polygon2;
}(Path_default);
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon;

// node_modules/zrender/lib/graphic/shape/Polyline.js
var PolylineShape = function() {
  function PolylineShape2() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolylineShape2;
}();
var Polyline = function(_super) {
  __extends2(Polyline2, _super);
  function Polyline2(opts) {
    return _super.call(this, opts) || this;
  }
  Polyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Polyline2.prototype.getDefaultShape = function() {
    return new PolylineShape;
  };
  Polyline2.prototype.buildPath = function(ctx, shape) {
    buildPath3(ctx, shape, false);
  };
  return Polyline2;
}(Path_default);
Polyline.prototype.type = "polyline";
var Polyline_default = Polyline;

// node_modules/zrender/lib/graphic/shape/Line.js
var subPixelOptimizeOutputShape2 = {};
var LineShape = function() {
  function LineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return LineShape2;
}();
var Line = function(_super) {
  __extends2(Line2, _super);
  function Line2(opts) {
    return _super.call(this, opts) || this;
  }
  Line2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Line2.prototype.getDefaultShape = function() {
    return new LineShape;
  };
  Line2.prototype.buildPath = function(ctx, shape) {
    var x1;
    var y1;
    var x22;
    var y22;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape2, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x22 = optimizedShape.x2;
      y22 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x22 = shape.x2;
      y22 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x22 = x1 * (1 - percent) + x22 * percent;
      y22 = y1 * (1 - percent) + y22 * percent;
    }
    ctx.lineTo(x22, y22);
  };
  Line2.prototype.pointAt = function(p3) {
    var shape = this.shape;
    return [
      shape.x1 * (1 - p3) + shape.x2 * p3,
      shape.y1 * (1 - p3) + shape.y2 * p3
    ];
  };
  return Line2;
}(Path_default);
Line.prototype.type = "line";
var Line_default = Line;

// node_modules/zrender/lib/graphic/shape/BezierCurve.js
var out = [];
var BezierCurveShape = function() {
  function BezierCurveShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
  return BezierCurveShape2;
}();
function someVectorAt(shape, t4, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t4),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t4)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t4),
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t4)
    ];
  }
}
var BezierCurve = function(_super) {
  __extends2(BezierCurve2, _super);
  function BezierCurve2(opts) {
    return _super.call(this, opts) || this;
  }
  BezierCurve2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  BezierCurve2.prototype.getDefaultShape = function() {
    return new BezierCurveShape;
  };
  BezierCurve2.prototype.buildPath = function(ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x22 = shape.x2;
    var y22 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x22, percent, out);
        cpx1 = out[1];
        x22 = out[2];
        quadraticSubdivide(y1, cpy1, y22, percent, out);
        cpy1 = out[1];
        y22 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x22, y22);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x22, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x22 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y22, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y22 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x22, y22);
    }
  };
  BezierCurve2.prototype.pointAt = function(t4) {
    return someVectorAt(this.shape, t4, false);
  };
  BezierCurve2.prototype.tangentAt = function(t4) {
    var p3 = someVectorAt(this.shape, t4, true);
    return normalize(p3, p3);
  };
  return BezierCurve2;
}(Path_default);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve;

// node_modules/zrender/lib/graphic/shape/Arc.js
var ArcShape = function() {
  function ArcShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return ArcShape2;
}();
var Arc = function(_super) {
  __extends2(Arc2, _super);
  function Arc2(opts) {
    return _super.call(this, opts) || this;
  }
  Arc2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Arc2.prototype.getDefaultShape = function() {
    return new ArcShape;
  };
  Arc2.prototype.buildPath = function(ctx, shape) {
    var x3 = shape.cx;
    var y3 = shape.cy;
    var r3 = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r3 + x3, unitY * r3 + y3);
    ctx.arc(x3, y3, r3, startAngle, endAngle, !clockwise);
  };
  return Arc2;
}(Path_default);
Arc.prototype.type = "arc";
var Arc_default = Arc;

// node_modules/zrender/lib/graphic/CompoundPath.js
var CompoundPath = function(_super) {
  __extends2(CompoundPath2, _super);
  function CompoundPath2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "compound";
    return _this;
  }
  CompoundPath2.prototype._updatePathDirty = function() {
    var paths = this.shape.paths;
    var dirtyPath = this.shapeChanged();
    for (var i3 = 0;i3 < paths.length; i3++) {
      dirtyPath = dirtyPath || paths[i3].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  };
  CompoundPath2.prototype.beforeBrush = function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale3 = this.getGlobalScale();
    for (var i3 = 0;i3 < paths.length; i3++) {
      if (!paths[i3].path) {
        paths[i3].createPathProxy();
      }
      paths[i3].path.setScale(scale3[0], scale3[1], paths[i3].segmentIgnoreThreshold);
    }
  };
  CompoundPath2.prototype.buildPath = function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i3 = 0;i3 < paths.length; i3++) {
      paths[i3].buildPath(ctx, paths[i3].shape, true);
    }
  };
  CompoundPath2.prototype.afterBrush = function() {
    var paths = this.shape.paths || [];
    for (var i3 = 0;i3 < paths.length; i3++) {
      paths[i3].pathUpdated();
    }
  };
  CompoundPath2.prototype.getBoundingRect = function() {
    this._updatePathDirty.call(this);
    return Path_default.prototype.getBoundingRect.call(this);
  };
  return CompoundPath2;
}(Path_default);
var CompoundPath_default = CompoundPath;

// node_modules/zrender/lib/graphic/Gradient.js
var Gradient = function() {
  function Gradient2(colorStops) {
    this.colorStops = colorStops || [];
  }
  Gradient2.prototype.addColorStop = function(offset, color) {
    this.colorStops.push({
      offset,
      color
    });
  };
  return Gradient2;
}();
var Gradient_default = Gradient;

// node_modules/zrender/lib/graphic/LinearGradient.js
var LinearGradient = function(_super) {
  __extends2(LinearGradient2, _super);
  function LinearGradient2(x3, y3, x22, y22, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x3 == null ? 0 : x3;
    _this.y = y3 == null ? 0 : y3;
    _this.x2 = x22 == null ? 1 : x22;
    _this.y2 = y22 == null ? 0 : y22;
    _this.type = "linear";
    _this.global = globalCoord || false;
    return _this;
  }
  return LinearGradient2;
}(Gradient_default);
var LinearGradient_default = LinearGradient;

// node_modules/zrender/lib/graphic/RadialGradient.js
var RadialGradient = function(_super) {
  __extends2(RadialGradient2, _super);
  function RadialGradient2(x3, y3, r3, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x3 == null ? 0.5 : x3;
    _this.y = y3 == null ? 0.5 : y3;
    _this.r = r3 == null ? 0.5 : r3;
    _this.type = "radial";
    _this.global = globalCoord || false;
    return _this;
  }
  return RadialGradient2;
}(Gradient_default);
var RadialGradient_default = RadialGradient;

// node_modules/zrender/lib/core/OrientedBoundingRect.js
var extent = [0, 0];
var extent2 = [0, 0];
var minTv2 = new Point_default;
var maxTv2 = new Point_default;
var OrientedBoundingRect = function() {
  function OrientedBoundingRect2(rect, transform) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (var i3 = 0;i3 < 4; i3++) {
      this._corners[i3] = new Point_default;
    }
    for (var i3 = 0;i3 < 2; i3++) {
      this._axes[i3] = new Point_default;
    }
    if (rect) {
      this.fromBoundingRect(rect, transform);
    }
  }
  OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform) {
    var corners = this._corners;
    var axes = this._axes;
    var x3 = rect.x;
    var y3 = rect.y;
    var x22 = x3 + rect.width;
    var y22 = y3 + rect.height;
    corners[0].set(x3, y3);
    corners[1].set(x22, y3);
    corners[2].set(x22, y22);
    corners[3].set(x3, y22);
    if (transform) {
      for (var i3 = 0;i3 < 4; i3++) {
        corners[i3].transform(transform);
      }
    }
    Point_default.sub(axes[0], corners[1], corners[0]);
    Point_default.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (var i3 = 0;i3 < 2; i3++) {
      this._origin[i3] = axes[i3].dot(corners[0]);
    }
  };
  OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
    var overlapped = true;
    var noMtv = !mtv;
    minTv2.set(Infinity, Infinity);
    maxTv2.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv2, maxTv2, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv2, maxTv2, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point_default.copy(mtv, overlapped ? minTv2 : maxTv2);
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv3, maxTv3, noMtv, inverse) {
    var overlapped = true;
    for (var i3 = 0;i3 < 2; i3++) {
      var axis = this._axes[i3];
      this._getProjMinMaxOnAxis(i3, self2._corners, extent);
      this._getProjMinMaxOnAxis(i3, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv3.len()) {
          if (dist0 < dist1) {
            Point_default.scale(maxTv3, axis, -dist0 * inverse);
          } else {
            Point_default.scale(maxTv3, axis, dist1 * inverse);
          }
        }
      } else if (minTv3) {
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv3.len()) {
          if (dist0 < dist1) {
            Point_default.scale(minTv3, axis, dist0 * inverse);
          } else {
            Point_default.scale(minTv3, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
    var axis = this._axes[dim];
    var origin = this._origin;
    var proj = corners[0].dot(axis) + origin[dim];
    var min3 = proj;
    var max3 = proj;
    for (var i3 = 1;i3 < corners.length; i3++) {
      var proj_1 = corners[i3].dot(axis) + origin[dim];
      min3 = Math.min(proj_1, min3);
      max3 = Math.max(proj_1, max3);
    }
    out2[0] = min3;
    out2[1] = max3;
  };
  return OrientedBoundingRect2;
}();
var OrientedBoundingRect_default = OrientedBoundingRect;

// node_modules/zrender/lib/graphic/IncrementalDisplayable.js
var m4 = [];
var IncrementalDisplayable = function(_super) {
  __extends2(IncrementalDisplayable2, _super);
  function IncrementalDisplayable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.notClear = true;
    _this.incremental = true;
    _this._displayables = [];
    _this._temporaryDisplayables = [];
    _this._cursor = 0;
    return _this;
  }
  IncrementalDisplayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  IncrementalDisplayable2.prototype.useStyle = function() {
    this.style = {};
  };
  IncrementalDisplayable2.prototype.getCursor = function() {
    return this._cursor;
  };
  IncrementalDisplayable2.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  };
  IncrementalDisplayable2.prototype.clearDisplaybles = function() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  };
  IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  };
  IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  };
  IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (var i3 = 0;i3 < displayables.length; i3++) {
      this.addDisplayable(displayables[i3], notPersistent);
    }
  };
  IncrementalDisplayable2.prototype.getDisplayables = function() {
    return this._displayables;
  };
  IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  };
  IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
    for (var i3 = this._cursor;i3 < this._displayables.length; i3++) {
      cb && cb(this._displayables[i3]);
    }
    for (var i3 = 0;i3 < this._temporaryDisplayables.length; i3++) {
      cb && cb(this._temporaryDisplayables[i3]);
    }
  };
  IncrementalDisplayable2.prototype.update = function() {
    this.updateTransform();
    for (var i3 = this._cursor;i3 < this._displayables.length; i3++) {
      var displayable = this._displayables[i3];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (var i3 = 0;i3 < this._temporaryDisplayables.length; i3++) {
      var displayable = this._temporaryDisplayables[i3];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };
  IncrementalDisplayable2.prototype.getBoundingRect = function() {
    if (!this._rect) {
      var rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
      for (var i3 = 0;i3 < this._displayables.length; i3++) {
        var displayable = this._displayables[i3];
        var childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m4));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  };
  IncrementalDisplayable2.prototype.contain = function(x3, y3) {
    var localPos = this.transformCoordToLocal(x3, y3);
    var rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (var i3 = 0;i3 < this._displayables.length; i3++) {
        var displayable = this._displayables[i3];
        if (displayable.contain(x3, y3)) {
          return true;
        }
      }
    }
    return false;
  };
  return IncrementalDisplayable2;
}(Displayable_default);
var IncrementalDisplayable_default = IncrementalDisplayable;

// node_modules/echarts/lib/animation/basicTransition.js
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  var animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === "update";
  if (animationEnabled) {
    var duration = undefined;
    var easing = undefined;
    var delay = undefined;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction(duration)) {
      duration = duration(dataIndex);
    }
    var config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;
  if (isFunction(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject2(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  var isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (var i3 = 0;i3 < el.animators.length; i3++) {
    var animator = el.animators[i3];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}

// node_modules/echarts/lib/util/graphic.js
var mathMax5 = Math.max;
var mathMin5 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path_default.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
function makePath(pathData, opts, rect, layout) {
  var path = createFromString(pathData, opts);
  if (rect) {
    if (layout === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout) {
  var zrImg = new Image_default({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath2 = mergePath;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  var pathRect = path.getBoundingRect();
  var m5 = pathRect.calculateTransform(rect);
  path.applyTransform(m5);
}
function subPixelOptimizeLine2(shape, lineWidth) {
  subPixelOptimizeLine(shape, shape, {
    lineWidth
  });
  return shape;
}
function subPixelOptimizeRect2(param) {
  subPixelOptimizeRect(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize2 = subPixelOptimize;
function getTransform(target, ancestor) {
  var mat = identity([]);
  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform2(target, transform, invert2) {
  if (transform && !isArrayLike(transform)) {
    transform = Transformable_default.getLocalTransform(transform);
  }
  if (invert2) {
    transform = invert([], transform);
  }
  return applyTransform([], target, transform);
}
function transformDirection(direction, transform, invert2) {
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform2(vertex, transform, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g3) {
    var elMap = {};
    g3.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    var obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath(el)) {
      obj.shape = extend({}, el.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      var oldEl = elMap1[el.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return map(points2, function(point) {
    var x3 = point[0];
    x3 = mathMax5(x3, rect.x);
    x3 = mathMin5(x3, rect.x + rect.width);
    var y3 = point[1];
    y3 = mathMax5(y3, rect.y);
    y3 = mathMin5(y3, rect.y + rect.height);
    return [x3, y3];
  });
}
function clipRectByRect(targetRect, rect) {
  var x3 = mathMax5(targetRect.x, rect.x);
  var x22 = mathMin5(targetRect.x + targetRect.width, rect.x + rect.width);
  var y3 = mathMax5(targetRect.y, rect.y);
  var y22 = mathMin5(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x22 >= x3 && y22 >= y3) {
    return {
      x: x3,
      y: y3,
      width: x22 - x3,
      height: y22 - y3
    };
  }
}
function createIcon(iconStr, opt, rect) {
  var innerOpts = extend({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i3 = 0, p22 = points2[points2.length - 1];i3 < points2.length; i3++) {
    var p3 = points2[i3];
    if (lineLineIntersect(a1x, a1y, a2x, a2y, p3[0], p3[1], p22[0], p22[1])) {
      return true;
    }
    p22 = p3;
  }
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q2 = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q2 < 0 || q2 > 1) {
    return false;
  }
  var p3 = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p3 < 0 || p3 > 1) {
    return false;
  }
  return true;
}
function crossProduct2d(x1, y1, x22, y22) {
  return x1 * y22 - x22 * y1;
}
function nearZero(val) {
  return val <= 0.000001 && val >= -0.000001;
}
function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each(keys(formatterParamsExtra), function(key) {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      encodeHTMLContent: true,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  var stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray(els)) {
      for (var i3 = 0;i3 < els.length; i3++) {
        traverseElement(els[i3], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle_default);
registerShape("ellipse", Ellipse_default);
registerShape("sector", Sector_default);
registerShape("ring", Ring_default);
registerShape("polygon", Polygon_default);
registerShape("polyline", Polyline_default);
registerShape("rect", Rect_default);
registerShape("line", Line_default);
registerShape("bezierCurve", BezierCurve_default);
registerShape("arc", Arc_default);

// node_modules/echarts/lib/label/labelStyle.js
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
    var stateName = SPECIAL_STATES[i3];
    var text = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }
  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  var statesText = {
    normal: baseText
  };
  for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
    var stateName = SPECIAL_STATES[i3];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof Text_default;
  var needsCreateText = false;
  for (var i3 = 0;i3 < DISPLAY_STATES.length; i3++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i3]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new Text_default;
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow("show");
    var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
      var stateName = SPECIAL_STATES[i3];
      var stateModel = labelStatesModels[stateName];
      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
    var stateName = SPECIAL_STATES[i3];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow("rotate");
  var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        var richTextStyle = textStyleModel.getModel(["rich", name_1]);
        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  var overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  var margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys(rich);
      for (var i3 = 0;i3 < richKeys.length; i3++) {
        var richKey = richKeys[i3];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"];
var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow("color");
  var strokeColor = textStyleModel.getShallow("textBorderColor");
  var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (true) {
      if (fillColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (true) {
      if (strokeColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (var i3 = 0;i3 < TEXT_PROPS_WITH_GLOBAL.length; i3++) {
    var key = TEXT_PROPS_WITH_GLOBAL[i3];
    var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  for (var i3 = 0;i3 < TEXT_PROPS_SELF.length; i3++) {
    var key = TEXT_PROPS_SELF[i3];
    var val = textStyleModel.getShallow(key);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (var i3 = 0;i3 < TEXT_PROPS_BOX.length; i3++) {
      var key = TEXT_PROPS_BOX[i3];
      var val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    var borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.backgroundColor === "auto") {
          deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
        }
      }
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.borderColor === "auto") {
          deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
        }
      }
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value2, getDefaultText) {
  if (!label) {
    return;
  }
  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value2;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
  var labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  var targetValue = labelInnerStore.value;
  function during(percent) {
    var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    var labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}

// node_modules/echarts/lib/model/mixin/textStyle.js
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
var tmpText = new Text_default;
var TextStyleMixin = function() {
  function TextStyleMixin2() {}
  TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  TextStyleMixin2.prototype.getFont = function() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  };
  TextStyleMixin2.prototype.getTextRect = function(text) {
    var style = {
      text,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (var i3 = 0;i3 < textStyleParams.length; i3++) {
      style[textStyleParams[i3]] = this.getShallow(textStyleParams[i3]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };
  return TextStyleMixin2;
}();
var textStyle_default = TextStyleMixin;

// node_modules/echarts/lib/model/mixin/lineStyle.js
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
  function LineStyleMixin2() {}
  LineStyleMixin2.prototype.getLineStyle = function(excludes) {
    return getLineStyle(this, excludes);
  };
  return LineStyleMixin2;
}();

// node_modules/echarts/lib/model/mixin/itemStyle.js
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
  function ItemStyleMixin2() {}
  ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  };
  return ItemStyleMixin2;
}();

// node_modules/echarts/lib/model/Model.js
var Model = function() {
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype.init = function(option, parentModel, ecModel) {
    var rest = [];
    for (var _i = 3;_i < arguments.length; _i++) {
      rest[_i - 3] = arguments[_i];
    }
  };
  Model2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
  };
  Model2.prototype.get = function(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };
  Model2.prototype.getShallow = function(key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    if (val == null && !ignoreParent) {
      var parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key);
      }
    }
    return val;
  };
  Model2.prototype.getModel = function(path, parentModel) {
    var hasPath = path != null;
    var pathFinal = hasPath ? this.parsePath(path) : null;
    var obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model2(obj, parentModel, this.ecModel);
  };
  Model2.prototype.isEmpty = function() {
    return this.option == null;
  };
  Model2.prototype.restoreData = function() {};
  Model2.prototype.clone = function() {
    var Ctor = this.constructor;
    return new Ctor(clone(this.option));
  };
  Model2.prototype.parsePath = function(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  };
  Model2.prototype.resolveParentPath = function(path) {
    return path;
  };
  Model2.prototype.isAnimationEnabled = function() {
    if (!env_default.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };
  Model2.prototype._doGet = function(pathArr, parentModel) {
    var obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (var i3 = 0;i3 < pathArr.length; i3++) {
      if (!pathArr[i3]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i3]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  };
  return Model2;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin2(Model, LineStyleMixin);
mixin2(Model, ItemStyleMixin);
mixin2(Model, AreaStyleMixin);
mixin2(Model, textStyle_default);
var Model_default = Model;

// node_modules/echarts/lib/data/DataDiffer.js
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = function() {
  function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  DataDiffer2.prototype.add = function(func) {
    this._add = func;
    return this;
  };
  DataDiffer2.prototype.update = function(func) {
    this._update = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToOne = function(func) {
    this._updateManyToOne = func;
    return this;
  };
  DataDiffer2.prototype.updateOneToMany = function(func) {
    this._updateOneToMany = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToMany = function(func) {
    this._updateManyToMany = func;
    return this;
  };
  DataDiffer2.prototype.remove = function(func) {
    this._remove = func;
    return this;
  };
  DataDiffer2.prototype.execute = function() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  };
  DataDiffer2.prototype._executeOneToOne = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i3 = 0;i3 < oldArr.length; i3++) {
      var oldKey = oldDataKeyArr[i3];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        var newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i3);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i3);
      } else {
        this._remove && this._remove(i3);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._executeMultiple = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i3 = 0;i3 < oldDataKeyArr.length; i3++) {
      var oldKey = oldDataKeyArr[i3];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0;i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
    for (var i3 = 0;i3 < newDataKeyArr.length; i3++) {
      var newKey = newDataKeyArr[i3];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (var j3 = 0;j3 < idxMapValLen; j3++) {
          this._add && this._add(newIdxMapVal[j3]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  };
  DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;
    for (var i3 = 0;i3 < arr.length; i3++) {
      var key = "_ec_" + this[keyGetterName](arr[i3], i3);
      if (!cbModeMultiple) {
        keyArr[i3] = key;
      }
      if (!map2) {
        continue;
      }
      var idxMapVal = map2[key];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map2[key] = i3;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map2[key] = [idxMapVal, i3];
      } else {
        idxMapVal.push(i3);
      }
    }
  };
  return DataDiffer2;
}();
var DataDiffer_default = DataDiffer;

// node_modules/echarts/lib/util/types.js
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";

// node_modules/echarts/lib/data/helper/sourceHelper.js
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  var encode2 = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode2;
  }
  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key = datasetModel.uid + "_" + source.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject2(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode2[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  });
  each(coordDimensions, function(coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      var start2 = datasetRecord.valueWayDim;
      pushDim(encode2[coordDimName], start2, count);
      pushDim(encodeSeriesName, start2, count);
      datasetRecord.valueWayDim += count;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode2[coordDimName], 0, count);
      pushDim(encodeItemName, 0, count);
    } else {
      var start2 = datasetRecord.categoryWayDim;
      pushDim(encode2[coordDimName], start2, count);
      pushDim(encodeSeriesName, start2, count);
      datasetRecord.categoryWayDim += count;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i3 = 0;i3 < idxCount; i3++) {
      dimIdxArr.push(idxFrom + i3);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode2.itemName = encodeItemName);
  encodeSeriesName.length && (encode2.seriesName = encodeSeriesName);
  return encode2;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  var encode2 = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode2;
  }
  var sourceFormat = source.sourceFormat;
  var dimensionsDefine = source.dimensionsDefine;
  var potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each(dimensionsDefine, function(dim, idx) {
      if ((isObject2(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  var idxResult = function() {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = [];
    for (var i3 = 0, len2 = Math.min(5, dimCount);i3 < len2; i3++) {
      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i3);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i3 !== potentialNameDimIndex) {
        idxRes0.v = i3;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i3;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i3 !== potentialNameDimIndex) {
          idxRes1.v = i3;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i3;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode2.value = [idxResult.v];
    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode2.itemName = [nameDimIndex];
    encode2.seriesName = [nameDimIndex];
  }
  return encode2;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  var thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result;
  var maxLoop = 5;
  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  }
  var dimName;
  var dimType;
  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];
    if (isObject2(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample = dataArrayRows[dimIndex];
      for (var i3 = 0;i3 < (sample || []).length && i3 < maxLoop; i3++) {
        if ((result = detectValue(sample[startIndex + i3])) != null) {
          return result;
        }
      }
    } else {
      for (var i3 = 0;i3 < dataArrayRows.length && i3 < maxLoop; i3++) {
        var row = dataArrayRows[startIndex + i3];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (var i3 = 0;i3 < dataObjectRows.length && i3 < maxLoop; i3++) {
      var item = dataObjectRows[i3];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    var sample = dataKeyedColumns[dimName];
    if (!sample || isTypedArray(sample)) {
      return BE_ORDINAL.Not;
    }
    for (var i3 = 0;i3 < sample.length && i3 < maxLoop; i3++) {
      if ((result = detectValue(sample[i3])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data;
    for (var i3 = 0;i3 < dataOriginal.length && i3 < maxLoop; i3++) {
      var item = dataOriginal[i3];
      var val = getDataItemValue(item);
      if (!isArray(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val2) {
    var beStr = isString(val2);
    if (val2 != null && Number.isFinite(Number(val2)) && val2 !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val2 !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}

// node_modules/echarts/lib/data/Source.js
var SourceImpl = function() {
  function SourceImpl2(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (var i3 = 0;i3 < dimensionsDefine.length; i3++) {
        var dim = dimensionsDefine[i3];
        if (dim.type == null) {
          if (guessOrdinal(this, i3) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
  return SourceImpl2;
}();
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (var i3 = 0, len2 = data.length;i3 < len2; i3++) {
      var item = data[i3];
      if (item == null) {
        continue;
      } else if (isArray(item) || isTypedArray(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject2(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject2(data)) {
    for (var key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index) {
        dimensionsDefine[index] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each(data, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    if (true) {
      assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
    }
  }
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {}
  if (obj) {
    return keys(obj);
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  var nameMap = createHashMap();
  return map(dimensionsDefine, function(rawItem, index) {
    rawItem = isObject2(rawItem) ? rawItem : {
      name: rawItem
    };
    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    var exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i3 = 0;i3 < data.length && i3 < maxLoop; i3++) {
      cb(data[i3] ? data[i3][0] : null, i3);
    }
  } else {
    var value0 = data[0] || [];
    for (var i3 = 0;i3 < value0.length && i3 < maxLoop; i3++) {
      cb(value0[i3], i3);
    }
  }
}
function shouldRetrieveDataByName(source) {
  var sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

// node_modules/echarts/lib/data/helper/dataProvider.js
var _a;
var _b;
var _c;
var providerMethods;
var mountMethods;
var DefaultDataProvider = function() {
  function DefaultDataProvider2(sourceParam, dimSize) {
    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    var data = this._data = source.data;
    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (true) {
        if (dimSize == null) {
          throw new Error("Typed array data must specify dimension size");
        }
      }
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    mountMethods(this, data, source);
  }
  DefaultDataProvider2.prototype.getSource = function() {
    return this._source;
  };
  DefaultDataProvider2.prototype.count = function() {
    return 0;
  };
  DefaultDataProvider2.prototype.getItem = function(idx, out2) {
    return;
  };
  DefaultDataProvider2.prototype.appendData = function(newData) {};
  DefaultDataProvider2.prototype.clean = function() {};
  DefaultDataProvider2.protoInitialize = function() {
    var proto = DefaultDataProvider2.prototype;
    proto.pure = false;
    proto.persistent = true;
  }();
  DefaultDataProvider2.internalField = function() {
    var _a2;
    mountMethods = function(provider, data, source) {
      var sourceFormat = source.sourceFormat;
      var seriesLayoutBy = source.seriesLayoutBy;
      var startIndex = source.startIndex;
      var dimsDef = source.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      if (true) {
        assert(methods, "Invalide sourceFormat: " + sourceFormat);
      }
      extend(provider, methods);
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);
      }
    };
    var getItemForTypedArray = function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var data = this._data;
      var dimSize = this._dimSize;
      var offset = dimSize * idx;
      for (var i3 = 0;i3 < dimSize; i3++) {
        out2[i3] = data[offset + i3];
      }
      return out2;
    };
    var fillStorageForTypedArray = function(start2, end2, storage, extent3) {
      var data = this._data;
      var dimSize = this._dimSize;
      for (var dim = 0;dim < dimSize; dim++) {
        var dimExtent = extent3[dim];
        var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count = end2 - start2;
        var arr = storage[dim];
        for (var i3 = 0;i3 < count; i3++) {
          var val = data[i3 * dimSize + dim];
          arr[start2 + i3] = val;
          val < min3 && (min3 = val);
          val > max3 && (max3 = val);
        }
        dimExtent[0] = min3;
        dimExtent[1] = max3;
      }
    };
    var countForTypedArray = function() {
      return this._data ? this._data.length / this._dimSize : 0;
    };
    providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function(newData) {
        var data = this._data;
        each(newData, function(newCol, key) {
          var oldCol = data[key] || (data[key] = []);
          for (var i3 = 0;i3 < (newCol || []).length; i3++) {
            oldCol.push(newCol[i3]);
          }
        });
      }
    }, _a2[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        if (true) {
          assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
        }
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }, _a2);
    function appendDataSimply(newData) {
      for (var i3 = 0;i3 < newData.length; i3++) {
        this._data.push(newData[i3]);
      }
    }
  }();
  return DefaultDataProvider2;
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
  idx += startIndex;
  var item = out2 || [];
  var data = rawData;
  for (var i3 = 0;i3 < data.length; i3++) {
    var row = data[i3];
    item[i3] = row ? row[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
  var item = out2 || [];
  for (var i3 = 0;i3 < dimsDef.length; i3++) {
    var dimName = dimsDef[i3].name;
    if (true) {
      if (dimName == null) {
        throw new Error;
      }
    }
    var col = rawData[dimName];
    item[i3] = col ? col[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
  var row = rawData[0];
  return row ? Math.max(0, row.length - startIndex) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;
  if (true) {
    if (dimName == null) {
      throw new Error;
    }
  }
  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
  return dataItem[property];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
  var value2 = getDataItemValue(dataItem);
  return !(value2 instanceof Array) ? value2 : value2[dimIndex];
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];
  if (true) {
    assert(method, 'Do not support get value on "' + sourceFormat + '".');
  }
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var store = data.getStore();
  var sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    var dimIndex = data.getDimensionIndex(dim);
    var property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    var result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}

// node_modules/echarts/lib/data/helper/dimensionHelper.js
var DimensionUserOuput = function() {
  function DimensionUserOuput2(encode2, dimRequest) {
    this._encode = encode2;
    this._schema = dimRequest;
  }
  DimensionUserOuput2.prototype.get = function() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  DimensionUserOuput2.prototype._getFullDimensionNames = function() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  };
  return DimensionUserOuput2;
}();
function summarizeDimensions(data, schema) {
  var summary = {};
  var encode2 = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;
    if (coordDim) {
      if (true) {
        assert(VISUAL_DIMENSIONS.get(coordDim) == null);
      }
      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode2, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v3, otherDim) {
      var encodeArr = getOrCreateEncodeArr(encode2, otherDim);
      var dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v3, coordDim) {
    var dimArr = encode2[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function(dimName) {
    return data.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode2.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  var encodeTooltip = encode2.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode2.defaultedLabel = defaultedLabel;
  encode2.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode2, dim) {
  if (!encode2.hasOwnProperty(dim)) {
    encode2[dim] = [];
  }
  return encode2[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}

// node_modules/echarts/lib/data/SeriesDimensionDefine.js
var SeriesDimensionDefine = function() {
  function SeriesDimensionDefine2(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend(this, opt);
    }
  }
  return SeriesDimensionDefine2;
}();
var SeriesDimensionDefine_default = SeriesDimensionDefine;

// node_modules/echarts/lib/data/helper/dataValueHelper.js
function parseDataValue(value2, opt) {
  var dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value2;
  }
  if (dimType === "time" && !isNumber(value2) && value2 != null && value2 !== "-") {
    value2 = +parseDate(value2);
  }
  return value2 == null || value2 === "" ? NaN : Number(value2);
}
var valueParserMap = createHashMap({
  number: function(val) {
    return parseFloat(val);
  },
  time: function(val) {
    return +parseDate(val);
  },
  trim: function(val) {
    return isString(val) ? trim(val) : val;
  }
});
var ORDER_COMPARISON_OP_MAP = {
  lt: function(lval, rval) {
    return lval < rval;
  },
  lte: function(lval, rval) {
    return lval <= rval;
  },
  gt: function(lval, rval) {
    return lval > rval;
  },
  gte: function(lval, rval) {
    return lval >= rval;
  }
};
var FilterOrderComparator = function() {
  function FilterOrderComparator2(op, rval) {
    if (!isNumber(rval)) {
      var errMsg = "";
      if (true) {
        errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
      }
      throwError(errMsg);
    }
    this._opFn = ORDER_COMPARISON_OP_MAP[op];
    this._rvalFloat = numericToNumber(rval);
  }
  FilterOrderComparator2.prototype.evaluate = function(lval) {
    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
  };
  return FilterOrderComparator2;
}();
var SortOrderComparator = function() {
  function SortOrderComparator2(order, incomparable) {
    var isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  SortOrderComparator2.prototype.evaluate = function(lval, rval) {
    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString(lval);
      var rvalIsStr = isString(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };
  return SortOrderComparator2;
}();
var FilterEqualityComparator = function() {
  function FilterEqualityComparator2(isEq, rval) {
    this._rval = rval;
    this._isEQ = isEq;
    this._rvalTypeof = typeof rval;
    this._rvalFloat = numericToNumber(rval);
  }
  FilterEqualityComparator2.prototype.evaluate = function(lval) {
    var eqResult = lval === this._rval;
    if (!eqResult) {
      var lvalTypeof = typeof lval;
      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
        eqResult = numericToNumber(lval) === this._rvalFloat;
      }
    }
    return this._isEQ ? eqResult : !eqResult;
  };
  return FilterEqualityComparator2;
}();

// node_modules/echarts/lib/data/DataStore.js
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  float: CtorFloat64Array,
  int: CtorInt32Array,
  ordinal: Array,
  number: Array,
  time: CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append) {
  var DataCtor = dataCtors[dimType || "float"];
  if (append) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      var newStore = new DataCtor(end2);
      for (var j3 = 0;j3 < oldLen; j3++) {
        newStore[j3] = oldStore[j3];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore = function() {
  function DataStore2() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
    if (true) {
      assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
    }
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    var willRetrieveDataByName = shouldRetrieveDataByName(source);
    this._dimensions = map(inputDimensions, function(dim) {
      if (true) {
        if (willRetrieveDataByName) {
          assert(dim.property != null);
        }
      }
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  };
  DataStore2.prototype.getProvider = function() {
    return this._provider;
  };
  DataStore2.prototype.getSource = function() {
    return this._provider.getSource();
  };
  DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {
      type
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };
  DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
    var chunk = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset = dim.ordinalOffset || 0;
    var len2 = chunk.length;
    if (offset === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    var dimRawExtent = rawExtents[dimIdx];
    for (var i3 = offset;i3 < len2; i3++) {
      var val = chunk[i3] = ordinalMeta.parseAndCollect(chunk[i3]);
      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  };
  DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };
  DataStore2.prototype.getDimensionProperty = function(dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  DataStore2.prototype.appendData = function(data) {
    if (true) {
      assert(!this._indices, "appendData can only be called on raw data.");
    }
    var provider = this._provider;
    var start2 = this.count();
    provider.appendData(data);
    var end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  };
  DataStore2.prototype.appendValues = function(values, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start2 = this.count();
    var end2 = start2 + Math.max(values.length, minFillLen || 0);
    for (var i3 = 0;i3 < dimLen; i3++) {
      var dim = dimensions[i3];
      prepareStore(chunks, i3, dim.type, end2, true);
    }
    var emptyDataItem = [];
    for (var idx = start2;idx < end2; idx++) {
      var sourceIdx = idx - start2;
      for (var dimIdx = 0;dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        var dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {
      start: start2,
      end: end2
    };
  };
  DataStore2.prototype._initDataFromProvider = function(start2, end2, append) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map(dimensions, function(dim2) {
      return dim2.property;
    });
    for (var i3 = 0;i3 < dimLen; i3++) {
      var dim = dimensions[i3];
      if (!rawExtent[i3]) {
        rawExtent[i3] = getInitialExtent();
      }
      prepareStore(chunks, i3, dim.type, end2, append);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      var dataItem = [];
      for (var idx = start2;idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (var dimIdx = 0;dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx];
          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  };
  DataStore2.prototype.count = function() {
    return this._count;
  };
  DataStore2.prototype.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };
  DataStore2.prototype.getValues = function(dimensions, idx) {
    var values = [];
    var dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (var i3 = 0;i3 < this._dimensions.length; i3++) {
        dimArr.push(i3);
      }
    } else {
      dimArr = dimensions;
    }
    for (var i3 = 0, len2 = dimArr.length;i3 < len2; i3++) {
      values.push(this.get(dimArr[i3], idx));
    }
    return values;
  };
  DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  DataStore2.prototype.getSum = function(dim) {
    var dimData = this._chunks[dim];
    var sum = 0;
    if (dimData) {
      for (var i3 = 0, len2 = this.count();i3 < len2; i3++) {
        var value2 = this.get(dim, i3);
        if (!isNaN(value2)) {
          sum += value2;
        }
      }
    }
    return sum;
  };
  DataStore2.prototype.getMedian = function(dim) {
    var dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    var sortedDimDataArray = dimDataArray.sort(function(a3, b) {
      return a3 - b;
    });
    var len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  };
  DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left = 0;
    var right = this._count - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  DataStore2.prototype.indicesOfNearest = function(dim, value2, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i3 = 0, len2 = this.count();i3 < len2; i3++) {
      var dataIndex = this.getRawIndex(i3);
      var diff = value2 - dimData[dataIndex];
      var dist2 = Math.abs(diff);
      if (dist2 <= maxDistance) {
        if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i3;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  DataStore2.prototype.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i3 = 0;i3 < thisCount; i3++) {
          newIndices[i3] = indices[i3];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (var i3 = 0;i3 < newIndices.length; i3++) {
        newIndices[i3] = i3;
      }
    }
    return newIndices;
  };
  DataStore2.prototype.filter = function(dims, cb) {
    if (!this._count) {
      return this;
    }
    var newStore = this.clone();
    var count = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count);
    var value2 = [];
    var dimSize = dims.length;
    var offset = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;
    for (var i3 = 0;i3 < count; i3++) {
      var keep = undefined;
      var rawIdx = newStore.getRawIndex(i3);
      if (dimSize === 0) {
        keep = cb(i3);
      } else if (dimSize === 1) {
        var val = chunks[dim0][rawIdx];
        keep = cb(val, i3);
      } else {
        var k3 = 0;
        for (;k3 < dimSize; k3++) {
          value2[k3] = chunks[dims[k3]][rawIdx];
        }
        value2[k3] = i3;
        keep = cb.apply(null, value2);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.selectRange = function(range) {
    var newStore = this.clone();
    var len2 = newStore._count;
    if (!len2) {
      return this;
    }
    var dims = keys(range);
    var dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dims[0];
    var min3 = range[dim0][0];
    var max3 = range[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;
    if (!newStore._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];
        for (var i3 = 0;i3 < len2; i3++) {
          var val = dimStorage[i3];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min23 = range[dims[1]][0];
        var max23 = range[dims[1]][1];
        for (var i3 = 0;i3 < len2; i3++) {
          var val = dimStorage[i3];
          var val2 = dimStorage2[i3];
          if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min23 && val2 <= max23 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i3 = 0;i3 < originalCount; i3++) {
          var rawIndex = newStore.getRawIndex(i3);
          var val = storeArr[dims[0]][rawIndex];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i3 = 0;i3 < originalCount; i3++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i3);
          for (var k3 = 0;k3 < dimSize; k3++) {
            var dimk = dims[k3];
            var val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i3);
          }
        }
      }
    }
    if (offset < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.map = function(dims, cb) {
    var target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  };
  DataStore2.prototype.modify = function(dims, cb) {
    this._updateDims(this, dims, cb);
  };
  DataStore2.prototype._updateDims = function(target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values = [];
    var rawExtent = target._rawExtent;
    for (var i3 = 0;i3 < dims.length; i3++) {
      rawExtent[dims[i3]] = getInitialExtent();
    }
    for (var dataIndex = 0;dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);
      for (var k3 = 0;k3 < dimSize; k3++) {
        values[k3] = targetChunks[dims[k3]][rawIndex];
      }
      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i3 = 0;i3 < retValue.length; i3++) {
          var dim = dims[i3];
          var val = retValue[i3];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  };
  DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (var i3 = 1;i3 < len2 - 1; i3 += frameSize) {
      var nextFrameStart = Math.min(i3 + frameSize, len2 - 1);
      var nextFrameEnd = Math.min(i3 + frameSize * 2, len2);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;
      for (var idx = nextFrameStart;idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y3 = dimStore[rawIndex];
        if (isNaN(y3)) {
          continue;
        }
        avgY += y3;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i3;
      var frameEnd = Math.min(i3 + frameSize, len2);
      var pointAX = i3 - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      var firstNaNIndex = -1;
      var countNaN = 0;
      for (var idx = frameStart;idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y3 = dimStore[rawIndex];
        if (isNaN(y3)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area = Math.abs((pointAX - avgX) * (y3 - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  DataStore2.prototype.minmaxDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize) * 2);
    var offset = 0;
    for (var i3 = 0;i3 < len2; i3 += frameSize) {
      var minIndex = i3;
      var minValue = dimStore[this.getRawIndex(minIndex)];
      var maxIndex = i3;
      var maxValue = dimStore[this.getRawIndex(maxIndex)];
      var thisFrameSize = frameSize;
      if (i3 + frameSize > len2) {
        thisFrameSize = len2 - i3;
      }
      for (var k3 = 0;k3 < thisFrameSize; k3++) {
        var rawIndex = this.getRawIndex(i3 + k3);
        var value2 = dimStore[rawIndex];
        if (value2 < minValue) {
          minValue = value2;
          minIndex = i3 + k3;
        }
        if (value2 > maxValue) {
          maxValue = value2;
          maxIndex = i3 + k3;
        }
      }
      var rawMinIndex = this.getRawIndex(minIndex);
      var rawMaxIndex = this.getRawIndex(maxIndex);
      if (minIndex < maxIndex) {
        newIndices[offset++] = rawMinIndex;
        newIndices[offset++] = rawMaxIndex;
      } else {
        newIndices[offset++] = rawMaxIndex;
        newIndices[offset++] = rawMinIndex;
      }
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len2 = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    var offset = 0;
    for (var i3 = 0;i3 < len2; i3 += frameSize) {
      if (frameSize > len2 - i3) {
        frameSize = len2 - i3;
        frameValues.length = frameSize;
      }
      for (var k3 = 0;k3 < frameSize; k3++) {
        var dataIdx = this.getRawIndex(i3 + k3);
        frameValues[k3] = dimStore[dataIdx];
      }
      var value2 = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i3 + sampleIndex(frameValues, value2) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value2;
      if (value2 < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value2;
      }
      if (value2 > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value2;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.each = function(dims, cb) {
    if (!this._count) {
      return;
    }
    var dimSize = dims.length;
    var chunks = this._chunks;
    for (var i3 = 0, len2 = this.count();i3 < len2; i3++) {
      var rawIdx = this.getRawIndex(i3);
      switch (dimSize) {
        case 0:
          cb(i3);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i3);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i3);
          break;
        default:
          var k3 = 0;
          var value2 = [];
          for (;k3 < dimSize; k3++) {
            value2[k3] = chunks[dims[k3]][rawIdx];
          }
          value2[k3] = i3;
          cb.apply(null, value2);
      }
    }
  };
  DataStore2.prototype.getDataExtent = function(dim) {
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min3 = dimExtent[0];
    var max3 = dimExtent[1];
    for (var i3 = 0;i3 < currEnd; i3++) {
      var rawIdx = this.getRawIndex(i3);
      var value2 = dimData[rawIdx];
      value2 < min3 && (min3 = value2);
      value2 > max3 && (max3 = value2);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  DataStore2.prototype.getRawDataItem = function(idx) {
    var rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      var val = [];
      var chunks = this._chunks;
      for (var i3 = 0;i3 < chunks.length; i3++) {
        val.push(chunks[i3][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
    var target = new DataStore2;
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (var i3 = 0;i3 < chunks.length; i3++) {
        target._chunks[i3] = !clonedDimsMap[i3] ? chunks[i3] : cloneChunk(chunks[i3]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype._copyCommonProps = function(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone(this._extent);
    target._rawExtent = clone(this._rawExtent);
  };
  DataStore2.prototype._cloneIndices = function() {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = undefined;
      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (var i3 = 0;i3 < thisCount; i3++) {
          indices[i3] = this._indices[i3];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  };
  DataStore2.prototype._getRawIdxIdentity = function(idx) {
    return idx;
  };
  DataStore2.prototype._getRawIdx = function(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  };
  DataStore2.prototype._updateGetRawIdx = function() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };
  DataStore2.internalField = function() {
    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }
    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, property, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, property, dataIndex, dimIndex) {
        var value2 = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value2 instanceof Array ? value2[dimIndex] : value2, this._dimensions[dimIndex]);
      },
      typedArray: function(dataItem, property, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();
  return DataStore2;
}();
var DataStore_default = DataStore;

// node_modules/echarts/lib/data/helper/SeriesDataSchema.js
var inner = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = function() {
  function SeriesDataSchema2(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  SeriesDataSchema2.prototype.isDimensionOmitted = function() {
    return this._dimOmitted;
  };
  SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };
  SeriesDataSchema2.prototype.makeStoreSchema = function() {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    var dimHash = "";
    var dims = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0;fullDimIdx < dimCount; fullDimIdx++) {
      var property = undefined;
      var type = undefined;
      var ordinalMeta = undefined;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({
        property,
        type,
        ordinalMeta
      });
      if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    var source = this.source;
    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
    return {
      dimensions: dims,
      hash
    };
  };
  SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
    var result = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0;fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = undefined;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }
      result.push(name_1);
    }
    return result;
  };
  SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  };
  return SeriesDataSchema2;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();
  for (var i3 = 0;i3 < (dimsDef || []).length; i3++) {
    var dimDefItemRaw = dimsDef[i3];
    var userDimName = isObject2(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i3);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  var innerSource = inner(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}

// node_modules/echarts/lib/data/SeriesData.js
var isObject3 = isObject2;
var map2 = map;
var CtorInt32Array2 = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\x00\x00";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
  function SeriesData2(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
    var dimensions;
    var assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};
    for (var i3 = 0;i3 < dimensions.length; i3++) {
      var dimInfoInput = dimensions[i3];
      var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i3;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i3;
      }
      if (true) {
        assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i3;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each(dimensionNames, function(dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  SeriesData2.prototype.getDimension = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    var dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    var sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  SeriesData2.prototype.getDimensionIndex = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    var dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  SeriesData2.prototype._recognizeDimIndex = function(dim) {
    if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };
  SeriesData2.prototype._getStoreDimIndex = function(dim) {
    var dimIdx = this.getDimensionIndex(dim);
    if (true) {
      if (dimIdx == null) {
        throw new Error("Unknown dimension " + dim);
      }
    }
    return dimIdx;
  };
  SeriesData2.prototype.getDimensionInfo = function(dim) {
    return this._getDimInfo(this.getDimension(dim));
  };
  SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function(dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;
    } : function(dimName) {
      return dimensionInfos[dimName];
    };
  };
  SeriesData2.prototype.getDimensionsOnCoord = function() {
    return this._dimSummary.dataDimsOnCoord.slice();
  };
  SeriesData2.prototype.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };
  SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };
  SeriesData2.prototype.getStore = function() {
    return this._store;
  };
  SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
    var _this = this;
    var store;
    if (data instanceof DataStore_default) {
      store = data;
    }
    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore_default;
      var dimensionInfos = map2(dimensions, function(dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  SeriesData2.prototype.appendData = function(data) {
    var range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  };
  SeriesData2.prototype.appendValues = function(values, names) {
    var _a2 = this._store.appendValues(values, names && names.length), start2 = _a2.start, end2 = _a2.end;
    var shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (var idx = start2;idx < end2; idx++) {
        var sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };
  SeriesData2.prototype._updateOrdinalMeta = function() {
    var store = this._store;
    var dimensions = this.dimensions;
    for (var i3 = 0;i3 < dimensions.length; i3++) {
      var dimInfo = this._dimInfos[dimensions[i3]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };
  SeriesData2.prototype._shouldMakeIdFromName = function() {
    var provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };
  SeriesData2.prototype._doInit = function(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    var store = this._store;
    var provider = store.getProvider();
    this._updateOrdinalMeta();
    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];
      for (var idx = start2;idx < end2; idx++) {
        var dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          var itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          var itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (var idx = start2;idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  };
  SeriesData2.prototype.getApproximateExtent = function(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  };
  SeriesData2.prototype.getCalculationInfo = function(key) {
    return this._calculationInfo[key];
  };
  SeriesData2.prototype.setCalculationInfo = function(key, value2) {
    isObject3(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value2;
  };
  SeriesData2.prototype.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    var name = this._nameList[rawIndex];
    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name == null) {
      name = "";
    }
    return name;
  };
  SeriesData2.prototype._getCategory = function(dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);
    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  };
  SeriesData2.prototype.getId = function(idx) {
    return getId(this, this.getRawIndex(idx));
  };
  SeriesData2.prototype.count = function() {
    return this._store.count();
  };
  SeriesData2.prototype.get = function(dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };
  SeriesData2.prototype.getIndices = function() {
    return this._store.getIndices();
  };
  SeriesData2.prototype.getDataExtent = function(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getSum = function(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getMedian = function(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getValues = function(dimensions, idx) {
    var _this = this;
    var store = this._store;
    return isArray(dimensions) ? store.getValues(map2(dimensions, function(dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  SeriesData2.prototype.hasValue = function(idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (var i3 = 0, len2 = dataDimIndicesOnCoord.length;i3 < len2; i3++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i3], idx))) {
        return false;
      }
    }
    return true;
  };
  SeriesData2.prototype.indexOfName = function(name) {
    for (var i3 = 0, len2 = this._store.count();i3 < len2; i3++) {
      if (this.getName(i3) === name) {
        return i3;
      }
    }
    return -1;
  };
  SeriesData2.prototype.getRawIndex = function(idx) {
    return this._store.getRawIndex(idx);
  };
  SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  SeriesData2.prototype.rawIndexOf = function(dim, value2) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    if (true) {
      if (!invertedIndices) {
        throw new Error("Do not supported yet");
      }
    }
    var rawIndex = invertedIndices && invertedIndices[value2];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  SeriesData2.prototype.indicesOfNearest = function(dim, value2, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value2, maxDistance);
  };
  SeriesData2.prototype.each = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  };
  SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return this;
  };
  SeriesData2.prototype.selectRange = function(range) {
    var _this = this;
    var innerRange = {};
    var dims = keys(range);
    var dimIndices = [];
    each(dims, function(dim) {
      var dimIdx = _this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
      dimIndices.push(dimIdx);
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    var result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };
  SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return list;
  };
  SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
    var _this = this;
    var fCtx = ctx || ctxCompat || this;
    if (true) {
      each(normalizeDimensions(dims), function(dim) {
        var dimInfo = _this.getDimensionInfo(dim);
        if (!dimInfo.isCalculationCoord) {
          console.error("Danger: only stack dimension can be modified");
        }
      });
    }
    var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  };
  SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  };
  SeriesData2.prototype.minmaxDownSample = function(valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };
  SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };
  SeriesData2.prototype.getRawDataItem = function(idx) {
    return this._store.getRawDataItem(idx);
  };
  SeriesData2.prototype.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model_default(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  SeriesData2.prototype.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  };
  SeriesData2.prototype.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  SeriesData2.prototype.setVisual = function(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject3(kvObj)) {
      extend(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  };
  SeriesData2.prototype.getItemVisual = function(idx, key) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null) {
      return this.getVisual(key);
    }
    return val;
  };
  SeriesData2.prototype.hasItemVisual = function() {
    return this._itemVisuals.length > 0;
  };
  SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    var val = itemVisual[key];
    if (val == null) {
      val = this.getVisual(key);
      if (isArray(val)) {
        val = val.slice();
      } else if (isObject3(val)) {
        val = extend({}, val);
      }
      itemVisual[key] = val;
    }
    return val;
  };
  SeriesData2.prototype.setItemVisual = function(idx, key, value2) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject3(key)) {
      extend(itemVisual, key);
    } else {
      itemVisual[key] = value2;
    }
  };
  SeriesData2.prototype.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  SeriesData2.prototype.setLayout = function(key, val) {
    isObject3(key) ? extend(this._layout, key) : this._layout[key] = val;
  };
  SeriesData2.prototype.getLayout = function(key) {
    return this._layout[key];
  };
  SeriesData2.prototype.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  SeriesData2.prototype.setItemLayout = function(idx, layout, merge2) {
    this._itemLayouts[idx] = merge2 ? extend(this._itemLayouts[idx] || {}, layout) : layout;
  };
  SeriesData2.prototype.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  };
  SeriesData2.prototype.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
    each(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  SeriesData2.prototype.cloneShallow = function(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map2(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  };
  SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (!isFunction(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  };
  SeriesData2.internalField = function() {
    prepareInvertedIndex = function(data) {
      var invertedIndicesMap = data._invertedIndicesMap;
      each(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = data._dimInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data._store;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array2(ordinalMeta.categories.length);
          for (var i3 = 0;i3 < invertedIndices.length; i3++) {
            invertedIndices[i3] = INDEX_NOT_FOUND;
          }
          for (var i3 = 0;i3 < store.count(); i3++) {
            invertedIndices[store.get(dimInfo.storeDimIndex, i3)] = i3;
          }
        }
      });
    };
    getIdNameFromStore = function(data, dimIdx, idx) {
      return convertOptionIdName(data._getCategory(dimIdx, idx), null);
    };
    getId = function(data, rawIndex) {
      var id = data._idList[rawIndex];
      if (id == null && data._idDimIdx != null) {
        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    };
    normalizeDimensions = function(dimensions) {
      if (!isArray(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }
      return dimensions;
    };
    cloneListForMapAndSample = function(original) {
      var list = new SeriesData2(original._schema ? original._schema : map2(original.dimensions, original._getDimInfo, original), original.hostModel);
      transferProperties(list, original);
      return list;
    };
    transferProperties = function(target, source) {
      each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      each(CLONE_PROPERTIES, function(propName) {
        target[propName] = clone(source[propName]);
      });
      target._calculationInfo = extend({}, source._calculationInfo);
    };
    makeIdFromName = function(data, idx) {
      var nameList = data._nameList;
      var idList = data._idList;
      var nameDimIdx = data._nameDimIdx;
      var idDimIdx = data._idDimIdx;
      var name = nameList[idx];
      var id = idList[idx];
      if (name == null && nameDimIdx != null) {
        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
      }
      if (id == null && idDimIdx != null) {
        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
      }
      if (id == null && name != null) {
        var nameRepeatCount = data._nameRepeatCount;
        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
        id = name;
        if (nmCnt > 1) {
          id += "__ec__" + nmCnt;
        }
        idList[idx] = id;
      }
    };
  }();
  return SeriesData2;
}();
var SeriesData_default = SeriesData;

// node_modules/echarts/lib/data/helper/createDimensions.js
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array(dimCount);
  for (var i3 = 0;i3 < indicesMap.length; i3++) {
    indicesMap[i3] = -1;
  }
  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];
    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject2(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem2 = new SeriesDimensionDefine_default;
      var userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem2.name = resultItem2.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem2.storeDimIndex = dimIdx;
      resultList.push(resultItem2);
      return resultItem2;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (var i3 = 0;i3 < dimCount; i3++) {
      getResultItem(i3);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim2) {
    var dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim2, false);
      return;
    }
    var validDataDims = encodeDefMap.set(coordDim2, []);
    each(dataDims, function(resultDimIdxOrName, idx) {
      var resultDimIdx2 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
        validDataDims[idx] = resultDimIdx2;
        applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
      }
    });
  });
  var availDimIdx = 0;
  each(sysDims, function(sysDimItemRaw) {
    var coordDim2;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;
    if (isString(sysDimItemRaw)) {
      coordDim2 = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim2 = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    var dataDims = encodeDefMap.get(coordDim2);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (var i4 = 0;i4 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i4++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each(dataDims, function(resultDimIdx2, coordDimIndex) {
      var resultItem2 = getResultItem(resultDimIdx2);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem2.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
      if (resultItem2.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject2(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
        resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem2, coordDim2, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
      resultItem2.otherDims[coordDim2] = coordDimIndex;
    } else {
      resultItem2.coordDim = coordDim2;
      resultItem2.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim2, true);
    }
  }
  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem2) {
    if (resultItem2.name == null) {
      resultItem2.name = resultItem2.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0;resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each(resultList, function(resultItem2) {
      ifNoNameFillWithCoordName(resultItem2);
    });
    resultList.sort(function(item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  var duplicationMap = createHashMap();
  for (var i3 = 0;i3 < result.length; i3++) {
    var dim = result[i3];
    var dimOriginalName = dim.name;
    var count = duplicationMap.get(dimOriginalName) || 0;
    if (count > 0) {
      dim.name = dimOriginalName + (count - 1);
    }
    count++;
    duplicationMap.set(dimOriginalName, count);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each(sysDims, function(sysDimItem) {
    var sysDimItemDimsDef;
    if (isObject2(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name, map3, fromZero) {
  if (fromZero || map3.hasKey(name)) {
    var i3 = 0;
    while (map3.hasKey(name + i3)) {
      i3++;
    }
    name += i3;
  }
  map3.set(name, true);
  return name;
}

// node_modules/echarts/lib/core/CoordinateSystem.js
var coordinateSystemCreators = {};
var CoordinateSystemManager = function() {
  function CoordinateSystemManager2() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager2.prototype.create = function(ecModel, api) {
    var coordinateSystems = [];
    each(coordinateSystemCreators, function(creator, type) {
      var list = creator.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  };
  CoordinateSystemManager2.prototype.update = function(ecModel, api) {
    each(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };
  CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
    return this._coordinateSystems.slice();
  };
  CoordinateSystemManager2.register = function(type, creator) {
    coordinateSystemCreators[type] = creator;
  };
  CoordinateSystemManager2.get = function(type) {
    return coordinateSystemCreators[type];
  };
  return CoordinateSystemManager2;
}();
var CoordinateSystem_default = CoordinateSystemManager;

// node_modules/echarts/lib/model/referHelper.js
var CoordSysInfo = function() {
  function CoordSysInfo2(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
  return CoordSysInfo2;
}();
function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var result = new CoordSysInfo(coordSysName);
  var fetch2 = fetchers[coordSysName];
  if (fetch2) {
    fetch2(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!xAxisModel) {
        throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
      }
      if (!yAxisModel) {
        throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
      }
    }
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!singleAxisModel) {
        throw new Error("singleAxis should be specified.");
      }
    }
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    var angleAxisModel = polarModel.findAxisModel("angleAxis");
    if (true) {
      if (!angleAxisModel) {
        throw new Error("angleAxis option not found");
      }
      if (!radiusAxisModel) {
        throw new Error("radiusAxis option not found");
      }
    }
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}

// node_modules/echarts/lib/data/helper/dataStackHelper.js
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  var mayStack = !!(seriesModel && seriesModel.get("stack"));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each(dimensionDefineList, function(dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\x00ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\x00ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}

// node_modules/echarts/lib/chart/helper/createSeriesData.js
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var registeredCoordSys = CoordinateSystem_default.get(coordSysName);
  var coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map(coordSysInfo.coordSysDims, function(dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        var axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each(dimInfoList, function(dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source;
  var isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema,
    store
  });
  var data = new SeriesData_default(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return !isArray(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  var i3 = 0;
  while (i3 < arr.length && arr[i3] == null) {
    i3++;
  }
  return arr[i3];
}
var createSeriesData_default = createSeriesData;

// node_modules/echarts/lib/util/component.js
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    var type = option.type;
    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each(targetNameList, function(name) {
      targetNameSet[name] = true;
    });
    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each(targetNameSet, function() {
      var errMsg = "";
      if (true) {
        errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
      }
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each(fullNameList, function(name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }
      each(availableDeps, function(dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }
    return graph[name];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each(originalDeps, function(dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge(merge({}, superOption, true), subOption, true);
}

// node_modules/zrender/lib/core/fourPointsTransform.js
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum = 0;
  for (var j3 = 0, colLocalIdx = 0;j3 < fullRank; j3++) {
    var colTag = 1 << j3;
    if (!(colTag & colMask)) {
      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j3] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum;
  return sum;
}
function buildTransformer(src, dest) {
  var mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  var vh = [];
  for (var i3 = 0;i3 < 8; i3++) {
    for (var j3 = 0;j3 < 8; j3++) {
      vh[j3] == null && (vh[j3] = 0);
      vh[j3] += ((i3 + j3) % 2 ? -1 : 1) * determinant(mA, 7, i3 === 0 ? 1 : 0, 1 << i3, 1 << j3, detCache) / det * dest[i3];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}

// node_modules/zrender/lib/core/dom.js
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut[0], _calcOut[1]);
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env_default.domSupported && !isCanvasEl(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i3 = 0;i3 < 4; i3++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i3 % 2;
    var idxTB = (i3 >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var srcCoords = [];
  var destCoords = [];
  var oldCoordTheSame = true;
  for (var i3 = 0;i3 < 4; i3++) {
    var rect = markers[i3].getBoundingClientRect();
    var ii = 2 * i3;
    var x3 = rect.left;
    var y3 = rect.top;
    srcCoords.push(x3, y3);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x3 === oldSrcCoords[ii] && y3 === oldSrcCoords[ii + 1];
    destCoords.push(markers[i3].offsetLeft, markers[i3].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c3) {
    return replaceMap[c3];
  });
}

// node_modules/echarts/lib/i18n/langEN.js
var langEN_default = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};

// node_modules/echarts/lib/i18n/langZH.js
var langZH_default = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};

// node_modules/echarts/lib/core/locale.js
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model_default(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString(locale)) {
    var localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone(localeObj);
    } else {
      return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default);
registerLocale(LOCALE_ZH, langZH_default);

// node_modules/echarts/lib/util/time.js
var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(time, template, isUTC, lang) {
  var date = parseDate(time);
  var y3 = date[fullYearGetterName(isUTC)]();
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var q2 = Math.floor((M2 - 1) / 3) + 1;
  var d3 = date[dateGetterName(isUTC)]();
  var e4 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  var H = date[hoursGetterName(isUTC)]();
  var h3 = (H - 1) % 12 + 1;
  var m5 = date[minutesGetterName(isUTC)]();
  var s3 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var a3 = H >= 12 ? "pm" : "am";
  var A3 = a3.toUpperCase();
  var localeModel = lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel("time");
  var month = timeModel.get("month");
  var monthAbbr = timeModel.get("monthAbbr");
  var dayOfWeek = timeModel.get("dayOfWeek");
  var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{a}/g, a3 + "").replace(/{A}/g, A3 + "").replace(/{yyyy}/g, y3 + "").replace(/{yy}/g, pad(y3 % 100 + "", 2)).replace(/{Q}/g, q2 + "").replace(/{MMMM}/g, month[M2 - 1]).replace(/{MMM}/g, monthAbbr[M2 - 1]).replace(/{MM}/g, pad(M2, 2)).replace(/{M}/g, M2 + "").replace(/{dd}/g, pad(d3, 2)).replace(/{d}/g, d3 + "").replace(/{eeee}/g, dayOfWeek[e4]).replace(/{ee}/g, dayOfWeekAbbr[e4]).replace(/{e}/g, e4 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h3 + "", 2)).replace(/{h}/g, h3 + "").replace(/{mm}/g, pad(m5, 2)).replace(/{m}/g, m5 + "").replace(/{ss}/g, pad(s3, 2)).replace(/{s}/g, s3 + "").replace(/{SSS}/g, pad(S2, 3)).replace(/{S}/g, S2 + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  var template = null;
  if (isString(formatter)) {
    template = formatter;
  } else if (isFunction(formatter)) {
    template = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults2 = extend({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (var i3 = 0;i3 < primaryTimeUnits.length; ++i3) {
        defaults2[primaryTimeUnits[i3]] = "{primary|" + defaults2[primaryTimeUnits[i3]] + "}";
      }
    }
    var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults2) : defaults2;
    var unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      var targetId = timeUnits.indexOf(unit);
      for (var i3 = targetId - 1;i3 >= 0; --i3) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }
      template = template || defaults2.none;
    }
    if (isArray(template)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }
  return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value2, isUTC) {
  var date = parseDate(value2);
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var d3 = date[dateGetterName(isUTC)]();
  var h3 = date[hoursGetterName(isUTC)]();
  var m5 = date[minutesGetterName(isUTC)]();
  var s3 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var isSecond = S2 === 0;
  var isMinute = isSecond && s3 === 0;
  var isHour = isMinute && m5 === 0;
  var isDay = isHour && h3 === 0;
  var isMonth = isDay && d3 === 1;
  var isYear = isMonth && M2 === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value2, unit, isUTC) {
  var date = isNumber(value2) ? parseDate(value2) : value2;
  unit = unit || getUnitFromValue(value2, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}

// node_modules/echarts/lib/util/format.js
function addCommas(x3) {
  if (!isNumeric(x3)) {
    return isString(x3) ? x3 : "-";
  }
  var parts2 = (x3 + "").split(".");
  return parts2[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts2.length > 1 ? "." + parts2[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray2 = normalizeCssArray;
function makeValueReadable(value2, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  var isTypeTime = valueType === "time";
  var isValueDate = value2 instanceof Date;
  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate(value2) : value2;
    if (!isNaN(+date)) {
      return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value2) ? stringToUserReadable(value2) : isNumber(value2) ? isNumberUserReadable(value2) ? value2 + "" : "-" : "-";
  }
  var numericResult = numericToNumber(value2);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value2) ? stringToUserReadable(value2) : typeof value2 === "boolean" ? value2 + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode2) {
  if (!isArray(paramsList)) {
    paramsList = [paramsList];
  }
  var seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  var $vars = paramsList[0].$vars || [];
  for (var i3 = 0;i3 < $vars.length; i3++) {
    var alias = TPL_VAR_ALIAS[i3];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (var seriesIdx = 0;seriesIdx < seriesLen; seriesIdx++) {
    for (var k3 = 0;k3 < $vars.length; k3++) {
      var val = paramsList[seriesIdx][$vars[k3]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k3], seriesIdx), encode2 ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  var color = opt.color;
  var type = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || "html";
  if (!color) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + "border-radius:4px;width:4px;height:4px;background-color:" + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;' + "border-radius:10px;width:10px;height:10px;background-color:" + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
  } else {
    var markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color
      }
    };
  }
}
function convertToColorString(color, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString(color) ? color : isObject2(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link, target) {
  if (target === "_blank" || target === "blank") {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link;
  } else {
    window.open(link, target);
  }
}

// node_modules/echarts/lib/util/layout.js
var each2 = each;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x3 = 0;
  var y3 = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x3 + moveX;
      if (nextX > maxWidth || child.newline) {
        x3 = 0;
        nextX = moveX;
        y3 += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y3 + moveY;
      if (nextY > maxHeight || child.newline) {
        x3 += currentLineMaxSize + gap;
        y3 = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x3;
    child.y = y3;
    child.markRedraw();
    orient === "horizontal" ? x3 = nextX + gap : y3 = nextY + gap;
  });
}
var box = boxLayout;
var vbox = curry(boxLayout, "vertical");
var hbox = curry(boxLayout, "horizontal");
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray2(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent2(positionInfo.left, containerWidth);
  var top = parsePercent2(positionInfo.top, containerHeight);
  var right = parsePercent2(positionInfo.right, containerWidth);
  var bottom = parsePercent2(positionInfo.bottom, containerHeight);
  var width = parsePercent2(positionInfo.width, containerWidth);
  var height = parsePercent2(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  var rect = new BoundingRect_default(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject2(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge2(HV_NAMES[0], 0);
  var vResult = merge2(HV_NAMES[1], 1);
  copy2(HV_NAMES[0], targetOption, hResult);
  copy2(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each2(names, function(name) {
      merged[name] = targetOption[name];
    });
    each2(names, function(name) {
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i3 = 0;i3 < names.length; i3++) {
        var name_1 = names[i3];
        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
          newParams[name_1] = targetOption[name_1];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }
  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== "auto";
  }
  function copy2(names, target, source) {
    each2(names, function(name) {
      target[name] = source[name];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each2(LOCATION_PARAMS, function(name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

// node_modules/echarts/lib/model/Component.js
var inner2 = makeInner();
var ComponentModel = function(_super) {
  __extends(ComponentModel2, _super);
  function ComponentModel2(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;
    _this.uid = getUID("ec_cpt_model");
    return _this;
  }
  ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge(option, themeModel.get(this.mainType));
    merge(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  ComponentModel2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {};
  ComponentModel2.prototype.getDefaultOption = function() {
    var ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    var fields = inner2(this);
    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor;
      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      var defaultOption = {};
      for (var i3 = optList.length - 1;i3 >= 0; i3--) {
        defaultOption = merge(defaultOption, optList[i3], true);
      }
      fields.defaultOption = defaultOption;
    }
    return fields.defaultOption;
  };
  ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
    var indexKey = mainType + "Index";
    var idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };
  ComponentModel2.prototype.getBoxLayoutParams = function() {
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  };
  ComponentModel2.prototype.getZLevelKey = function() {
    return "";
  };
  ComponentModel2.prototype.setZLevel = function(zlevel) {
    this.option.zlevel = zlevel;
  };
  ComponentModel2.protoInitialize = function() {
    var proto = ComponentModel2.prototype;
    proto.type = "component";
    proto.id = "";
    proto.name = "";
    proto.mainType = "";
    proto.subType = "";
    proto.componentIndex = 0;
  }();
  return ComponentModel2;
}(Model_default);
mountExtend(ComponentModel, Model_default);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  each(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var Component_default = ComponentModel;

// node_modules/echarts/lib/model/mixin/palette.js
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
  function PaletteMixin2() {}
  PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get("color", true));
    var layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  };
  PaletteMixin2.prototype.clearColorPalette = function() {
    clearPalette(this, innerColor);
  };
  return PaletteMixin2;
}();
function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length;
  for (var i3 = 0;i3 < paletteNum; i3++) {
    if (palettes[i3].length > requestColorNum) {
      return palettes[i3];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner3, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner3(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }
  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  var pickedPaletteItem = palette[paletteIdx];
  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner3) {
  inner3(that).paletteIdx = 0;
  inner3(that).paletteNameMap = {};
}

// node_modules/echarts/lib/model/mixin/dataFormat.js
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
  function DataFormatMixin2() {}
  DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var style = data.getItemVisual(dataIndex, "style");
    var color = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries = mainType === "series";
    var userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries ? this.id : null,
      seriesName: isSeries ? this.name : null,
      name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  };
  DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    var data = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      var itemModel = data.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      var str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        var len2 = dimStr.length;
        var dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
          if (true) {
            if (isNaN(dimLoose)) {
              error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
            }
          }
        }
        var val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray(extendParams.interpolatedValue)) {
          var dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  };
  DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return;
  };
  return DataFormatMixin2;
}();
function normalizeTooltipFormatResult(result) {
  var markupText;
  var markupFragment;
  if (isObject2(result)) {
    if (result.type) {
      markupFragment = result;
    } else {
      if (true) {
        console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
      }
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}

// node_modules/echarts/lib/core/task.js
function createTask(define2) {
  return new Task(define2);
}
var Task = function() {
  function Task2(define2) {
    define2 = define2 || {};
    this._reset = define2.reset;
    this._plan = define2.plan;
    this._count = define2.count;
    this._onDirty = define2.onDirty;
    this._dirty = true;
  }
  Task2.prototype.perform = function(performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    var planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    var forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;
    if (upTask) {
      if (true) {
        assert(upTask._outputDueEnd != null);
      }
      this._dueEnd = upTask._outputDueEnd;
    } else {
      if (true) {
        assert(!this._progress || this._count);
      }
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      var start2 = this._dueIndex;
      var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        var progress = this._progress;
        if (isArray(progress)) {
          for (var i3 = 0;i3 < progress.length; i3++) {
            this._doProgress(progress[i3], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      if (true) {
        assert(outputDueEnd >= this._outputDueEnd);
      }
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  };
  Task2.prototype.dirty = function() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };
  Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  };
  Task2.prototype._doReset = function(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };
  Task2.prototype.unfinished = function() {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  Task2.prototype.pipe = function(downTask) {
    if (true) {
      assert(downTask && !downTask._disposed && downTask !== this);
    }
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };
  Task2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };
  Task2.prototype.getUpstream = function() {
    return this._upstream;
  };
  Task2.prototype.getDownstream = function() {
    return this._downstream;
  };
  Task2.prototype.setOutputEnd = function(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  };
  return Task2;
}();
var iterator = function() {
  var end2;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function(s3, e4, sStep, sCount) {
      current = s3;
      end2 = e4;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();

// node_modules/echarts/lib/data/helper/transform.js
var ExternalSource = function() {
  function ExternalSource2() {}
  ExternalSource2.prototype.getRawData = function() {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.cloneRawData = function() {
    return;
  };
  ExternalSource2.prototype.getDimensionInfo = function(dim) {
    return;
  };
  ExternalSource2.prototype.cloneAllDimensionInfo = function() {
    return;
  };
  ExternalSource2.prototype.count = function() {
    return;
  };
  ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
    return;
  };
  ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
    return;
  };
  ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };
  return ExternalSource2;
}();
function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource;
  var data = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    if (true) {
      errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
    }
    throwError(errMsg);
  }
  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each(dimsDef, function(dimDef, idx) {
      var name = dimDef.name;
      var dimDefExt = {
        index: idx,
        name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name != null) {
        var errMsg_1 = "";
        if (hasOwn(dimsByName, name)) {
          if (true) {
            errMsg_1 = 'dimension name "' + name + '" duplicated.';
          }
          throwError(errMsg_1);
        }
        dimsByName[name] = dimDefExt;
      }
    });
  } else {
    for (var i3 = 0;i3 < internalSource.dimensionsDetectedCount; i3++) {
      dimensions.push({
        index: i3
      });
    }
  }
  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    var dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    if (true) {
      errMsg = "`getRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    if (true) {
      errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];
    for (var i3 = 0, len2 = data.length;i3 < len2; i3++) {
      result.push(data[i3].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];
    for (var i3 = 0, len2 = data.length;i3 < len2; i3++) {
      result.push(extend({}, data[i3]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone(externalTransform);
  var type = externalTransform.type;
  var errMsg = "";
  if (!type) {
    if (true) {
      errMsg = "Must have a `type` when `registerTransform`.";
    }
    throwError(errMsg);
  }
  var typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    if (true) {
      errMsg = 'Name must include namespace like "ns:regression".';
    }
    throwError(errMsg);
  }
  var isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = "";
  if (!pipeLen) {
    if (true) {
      errMsg = "If `transform` declared, it should at least contain one transform.";
    }
    throwError(errMsg);
  }
  for (var i3 = 0, len2 = pipeLen;i3 < len2; i3++) {
    var transOption = pipedTransOption[i3];
    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i3);
    if (i3 !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  var errMsg = "";
  if (!upSourceList.length) {
    if (true) {
      errMsg = "Must have at least one upstream dataset.";
    }
    throwError(errMsg);
  }
  if (!isObject2(transOption)) {
    if (true) {
      errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
    }
    throwError(errMsg);
  }
  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    if (true) {
      errMsg = 'Can not find transform on type "' + transType + '".';
    }
    throwError(errMsg);
  }
  var extUpSourceList = map(upSourceList, function(upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone(transOption.config)
  }));
  if (true) {
    if (transOption.print) {
      var printStrArr = map(resultList, function(extSource) {
        var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
        return ["=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===", "- transform result data:", makePrintable(extSource.data), "- transform result dimensions:", makePrintable(extSource.dimensions)].join(`
`);
      }).join(`
`);
      log(printStrArr);
    }
  }
  return map(resultList, function(result, resultIndex) {
    var errMsg2 = "";
    if (!isObject2(result)) {
      if (true) {
        errMsg2 = "A transform should not return some empty results.";
      }
      throwError(errMsg2);
    }
    if (!result.data) {
      if (true) {
        errMsg2 = "Transform result data should be not be null or undefined";
      }
      throwError(errMsg2);
    }
    var sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      if (true) {
        errMsg2 = "Transform result data should be array rows or object rows.";
      }
      throwError(errMsg2);
    }
    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      var startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

// node_modules/echarts/lib/data/helper/sourceManager.js
var SourceManager = function() {
  function SourceManager2(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  SourceManager2.prototype.dirty = function() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  };
  SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 90000000000) {
      this._versionSignBase = 0;
    }
  };
  SourceManager2.prototype._getVersionSign = function() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  };
  SourceManager2.prototype.prepareSource = function() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  };
  SourceManager2.prototype._createSource = function() {
    this._setLocalSource([], []);
    var sourceHost = this._sourceHost;
    var upSourceMgrList = this._getUpstreamSourceManagers();
    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;
    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data = undefined;
      var sourceFormat = undefined;
      var upSource = undefined;
      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost;
      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        var sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    if (true) {
      assert(resultSourceList && upstreamSignList);
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  };
  SourceManager2.prototype._applyTransform = function(upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get("transform", true);
    var fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (true) {
      assert(fromTransformResult != null || transformOption != null);
    }
    if (fromTransformResult != null) {
      var errMsg = "";
      if (upMgrList.length !== 1) {
        if (true) {
          errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
        }
        doThrow(errMsg);
      }
    }
    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each(upMgrList, function(upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg2 = "";
      if (fromTransformResult != null && !upSource) {
        if (true) {
          errMsg2 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
        }
        doThrow(errMsg2);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {
      sourceList,
      upstreamSignList
    };
  };
  SourceManager2.prototype._isDirty = function() {
    if (this._dirty) {
      return true;
    }
    var upSourceMgrList = this._getUpstreamSourceManagers();
    for (var i3 = 0;i3 < upSourceMgrList.length; i3++) {
      var upSrcMgr = upSourceMgrList[i3];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i3] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  SourceManager2.prototype.getSource = function(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source = this._sourceList[sourceIndex];
    if (!source) {
      var upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  };
  SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
    if (true) {
      assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
    }
    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };
  SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    var cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore_default;
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  };
  SourceManager2.prototype._getUpstreamSourceManagers = function() {
    var sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
        return datasetModel2.getSourceManager();
      });
    }
  };
  SourceManager2.prototype._getSourceMetaRawOption = function() {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      var model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {
      seriesLayoutBy,
      sourceHeader,
      dimensions
    };
  };
  return SourceManager2;
}();
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}

// node_modules/echarts/lib/component/tooltip/tooltipMarkup.js
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(textStyle) {
  var lineHeight = textStyle.lineHeight;
  if (lineHeight == null) {
    return TOOLTIP_LINE_HEIGHT_CSS;
  } else {
    return "line-height:" + encodeHTML(lineHeight + "") + "px";
  }
}
function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || "#6e7079";
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || "400";
  var valueFontColor = textStyle.color || "#464646";
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
      valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", `
`, `

`, `


`];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each(frag.blocks, function(subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment));
  var subMarkupTextList = [];
  var subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function(a3, b) {
        return comparator_1.evaluate(a3.sortParam, b.sortParam);
      });
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each(subBlocks, function(subBlock, idx) {
    var valueFormatter = fragment.valueFormatter;
    var subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), {
      valueFormatter
    }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
  var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML(toolTipTextStyle, '<div style="' + nameStyle + ";" + tooltipLineHeight + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment.noName;
  var noValue = fragment.noValue;
  var noMarker = !fragment.markerType;
  var name = fragment.name;
  var useUTC = ctx.useUTC;
  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value2) {
    value2 = isArray(value2) ? value2 : [value2];
    return map(value2, function(val, idx) {
      return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };
  if (noName && noValue) {
    return;
  }
  var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
  var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
  var valueTypeOption = fragment.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
  var valueAlignRight = !noMarker || !noName;
  var valueCloseToMarker = !noMarker && noName;
  var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  var builder = getBuilder(fragment);
  var ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(textStyle, encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  var tooltipLineHeight = getTooltipLineHeight(textStyle);
  return '<div style="' + marginCSS + ";" + tooltipLineHeight + ';">' + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
  var marginCss = leftHasMarker ? "margin-left:2px" : "";
  return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  var paddingStr = valueCloseToMarker ? "10px" : "20px";
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
  valueList = isArray(valueList) ? valueList : [valueList];
  return '<span style="' + alignCSS + ";" + style + '">' + map(valueList, function(value2) {
    return encodeHTML(value2);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  var styles = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({
    padding: [0, 0, 0, paddingLeft],
    align: "right"
  });
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, "style");
  var color = style[series.visualDrawType];
  return convertToColorString(color);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = function() {
  function TooltipMarkupStyleCreator2() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  };
  TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
    var markerId = renderMode === "richText" ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString(marker)) {
      return marker;
    } else {
      if (true) {
        assert(markerId);
      }
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
    var finalStl = {};
    if (isArray(styles)) {
      each(styles, function(stl) {
        return extend(finalStl, stl);
      });
    } else {
      extend(finalStl, styles);
    }
    var styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text + "}";
  };
  return TooltipMarkupStyleCreator2;
}();

// node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js
function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data = series.getData();
  var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  var tooltipDimLen = tooltipDims.length;
  var value2 = series.getRawValue(dataIndex);
  var isValueArr = isArray(value2);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value2, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value2[0] : value2;
  }
  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || "";
  var itemName = data.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor,
      name: inlineName,
      noName: !trim(inlineName),
      value: inlineValue,
      valueType: inlineValueType,
      dataIndex
    })].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value2, series, dataIndex, tooltipDims, colorStr) {
  var data = series.getData();
  var isValueMultipleLine = reduce(value2, function(isValueMultipleLine2, val, idx) {
    var dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each(value2, setEachItem);
  function setEachItem(val, dim) {
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {
    inlineValues,
    inlineValueTypes,
    blocks
  };
}

// node_modules/echarts/lib/model/Series.js
var inner3 = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
  __extends(SeriesModel2, _super);
  function SeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectedDataIndicesMap = {};
    return _this;
  }
  SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner3(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    if (true) {
      assert(data, "getInitialData returned invalid data.");
    }
    inner3(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (Component_default.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge(option, ecModel.getTheme().get(this.subType));
    merge(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
    newSeriesOption = merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    var sourceManager = inner3(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner3(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.fillDataTextStyle = function(data) {
    if (data && !isTypedArray(data)) {
      var props = ["show"];
      for (var i3 = 0;i3 < data.length; i3++) {
        if (data[i3] && data[i3].label) {
          defaultEmphasis(data[i3], "label", props);
        }
      }
    }
  };
  SeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return;
  };
  SeriesModel2.prototype.appendData = function(params) {
    var data = this.getRawData();
    data.appendData(params.data);
  };
  SeriesModel2.prototype.getData = function(dataType) {
    var task = getCurrentTask(this);
    if (task) {
      var data = task.context.data;
      return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
    } else {
      return inner3(this).data;
    }
  };
  SeriesModel2.prototype.getAllData = function() {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };
  SeriesModel2.prototype.setData = function(data) {
    var task = getCurrentTask(this);
    if (task) {
      var context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner3(this).data = data;
  };
  SeriesModel2.prototype.getEncode = function() {
    var encode2 = this.get("encode", true);
    if (encode2) {
      return createHashMap(encode2);
    }
  };
  SeriesModel2.prototype.getSourceManager = function() {
    return inner3(this).sourceManager;
  };
  SeriesModel2.prototype.getSource = function() {
    return this.getSourceManager().getSource();
  };
  SeriesModel2.prototype.getRawData = function() {
    return inner3(this).dataBeforeProcessed;
  };
  SeriesModel2.prototype.getColorBy = function() {
    var colorBy = this.get("colorBy");
    return colorBy || "series";
  };
  SeriesModel2.prototype.isColorBySeries = function() {
    return this.getColorBy() === "series";
  };
  SeriesModel2.prototype.getBaseAxis = function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  };
  SeriesModel2.prototype.isAnimationEnabled = function() {
    var ecModel = this.ecModel;
    if (env_default.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  };
  SeriesModel2.prototype.restoreData = function() {
    this.dataTask.dirty();
  };
  SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
    if (!color) {
      color = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }
    return color;
  };
  SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  SeriesModel2.prototype.getProgressive = function() {
    return this.get("progressive");
  };
  SeriesModel2.prototype.getProgressiveThreshold = function() {
    return this.get("progressiveThreshold");
  };
  SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };
  SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    var selectedMode = this.option.selectedMode;
    var data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (var i3 = 0;i3 < innerDataIndices.length; i3++) {
      var dataIndex = innerDataIndices[i3];
      var nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };
  SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
    var tmpArr = [];
    for (var i3 = 0;i3 < innerDataIndices.length; i3++) {
      tmpArr[0] = innerDataIndices[i3];
      this.isSelected(innerDataIndices[i3], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);
    }
  };
  SeriesModel2.prototype.getSelectedDataIndices = function() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys(selectedDataIndicesMap);
    var dataIndices = [];
    for (var i3 = 0;i3 < nameOrIds.length; i3++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i3]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  };
  SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    var data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  };
  SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    var universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  };
  SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
    var _a2, _b2;
    var option = this.option;
    var selectedMode = option.selectedMode;
    var len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject2(option.selectedMap)) {
        option.selectedMap = {};
      }
      var selectedMap = option.selectedMap;
      for (var i3 = 0;i3 < len2; i3++) {
        var dataIndex = innerDataIndices[i3];
        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len2 - 1];
      var nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
      this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
    }
  };
  SeriesModel2.prototype._initSelectedMapFromData = function(data) {
    if (this.option.selectedMap) {
      return;
    }
    var dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        var rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  };
  SeriesModel2.registerClass = function(clz) {
    return Component_default.registerClass(clz);
  };
  SeriesModel2.protoInitialize = function() {
    var proto = SeriesModel2.prototype;
    proto.type = "series.__base__";
    proto.seriesIndex = 0;
    proto.ignoreStyleOnData = false;
    proto.hasSymbolVisual = false;
    proto.defaultSymbol = "circle";
    proto.visualStyleAccessPath = "itemStyle";
    proto.visualDrawType = "fill";
  }();
  return SeriesModel2;
}(Component_default);
mixin2(SeriesModel, DataFormatMixin);
mixin2(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, Component_default);
function autoSeriesName(seriesModel) {
  var name = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}
function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimensionsAll("seriesName");
  var nameArr = [];
  each(dataDims, function(dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task = pipeline.currentTask;
    if (task) {
      var agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var Series_default = SeriesModel;

// node_modules/echarts/lib/util/symbol.js
var Triangle = Path_default.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path_default.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path_default.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var x3 = shape.x;
    var y3 = shape.y;
    var w3 = shape.width / 5 * 3;
    var h3 = Math.max(w3, shape.height);
    var r3 = w3 / 2;
    var dy = r3 * r3 / (h3 - r3);
    var cy = y3 - h3 + r3 + dy;
    var angle = Math.asin(dy / r3);
    var dx = Math.cos(angle) * r3;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r3 * 0.6;
    var cpLen2 = r3 * 0.7;
    path.moveTo(x3 - dx, cy + dy);
    path.arc(x3, cy, r3, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x3 + dx - tanX * cpLen, cy + dy + tanY * cpLen, x3, y3 - cpLen2, x3, y3);
    path.bezierCurveTo(x3, y3 - cpLen2, x3 - dx + tanX * cpLen, cy + dy + tanY * cpLen, x3 - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path_default.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x3 = shape.x;
    var y3 = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x3, y3);
    ctx.lineTo(x3 + dx, y3 + height);
    ctx.lineTo(x3, y3 + height / 4 * 3);
    ctx.lineTo(x3 - dx, y3 + height);
    ctx.lineTo(x3, y3);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line_default,
  rect: Rect_default,
  roundRect: Rect_default,
  square: Rect_default,
  circle: Circle_default,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x3, y3, w3, h3, shape) {
    shape.x1 = x3;
    shape.y1 = y3 + h3 / 2;
    shape.x2 = x3 + w3;
    shape.y2 = y3 + h3 / 2;
  },
  rect: function(x3, y3, w3, h3, shape) {
    shape.x = x3;
    shape.y = y3;
    shape.width = w3;
    shape.height = h3;
  },
  roundRect: function(x3, y3, w3, h3, shape) {
    shape.x = x3;
    shape.y = y3;
    shape.width = w3;
    shape.height = h3;
    shape.r = Math.min(w3, h3) / 4;
  },
  square: function(x3, y3, w3, h3, shape) {
    var size = Math.min(w3, h3);
    shape.x = x3;
    shape.y = y3;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x3, y3, w3, h3, shape) {
    shape.cx = x3 + w3 / 2;
    shape.cy = y3 + h3 / 2;
    shape.r = Math.min(w3, h3) / 2;
  },
  diamond: function(x3, y3, w3, h3, shape) {
    shape.cx = x3 + w3 / 2;
    shape.cy = y3 + h3 / 2;
    shape.width = w3;
    shape.height = h3;
  },
  pin: function(x3, y3, w3, h3, shape) {
    shape.x = x3 + w3 / 2;
    shape.y = y3 + h3 / 2;
    shape.width = w3;
    shape.height = h3;
  },
  arrow: function(x3, y3, w3, h3, shape) {
    shape.x = x3 + w3 / 2;
    shape.y = y3 + h3 / 2;
    shape.width = w3;
    shape.height = h3;
  },
  triangle: function(x3, y3, w3, h3, shape) {
    shape.cx = x3 + w3 / 2;
    shape.cy = y3 + h3 / 2;
    shape.width = w3;
    shape.height = h3;
  }
};
var symbolBuildProxies = {};
each(symbolCtors, function(Ctor, name) {
  symbolBuildProxies[name] = new Ctor;
});
var SymbolClz = Path_default.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(out2, config, rect) {
    var res = calculateTextPosition(out2, config, rect);
    var shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath: function(ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    if (symbolType !== "none") {
      var proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color, innerColor2) {
  if (this.type !== "image") {
    var symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color;
    } else {
      symbolStyle.fill = color;
    }
    this.markRedraw();
  }
}
function createSymbol(symbolType, x3, y3, w3, h3, color, keepAspect) {
  var isEmpty = symbolType.indexOf("empty") === 0;
  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  var symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x3, y3, w3, h3), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x3, y3, w3, h3), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType,
        x: x3,
        y: y3,
        width: w3,
        height: h3
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  if (color) {
    symbolPath.setColor(color);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [parsePercent2(symbolOffset[0], symbolSize[0]) || 0, parsePercent2(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}

// node_modules/echarts/lib/chart/line/LineSeries.js
var LineSeriesModel = function(_super) {
  __extends(LineSeriesModel2, _super);
  function LineSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LineSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  LineSeriesModel2.prototype.getInitialData = function(option) {
    if (true) {
      var coordSys = option.coordinateSystem;
      if (coordSys !== "polar" && coordSys !== "cartesian2d") {
        throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
    }
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  };
  LineSeriesModel2.prototype.getLegendIcon = function(opt) {
    var group = new Group_default;
    var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual("symbol");
    var visualRotate = this.getData().getVisual("symbolRotate");
    var symbolType = visualType === "none" ? "circle" : visualType;
    var size = opt.itemHeight * 0.8;
    var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  };
  LineSeriesModel2.type = "series.line";
  LineSeriesModel2.dependencies = ["grid", "polar"];
  LineSeriesModel2.defaultOption = {
    z: 3,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    clip: true,
    label: {
      position: "top"
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: "solid"
    },
    emphasis: {
      scale: true
    },
    step: false,
    smooth: false,
    smoothMonotone: null,
    symbol: "emptyCircle",
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    showAllSymbol: "auto",
    connectNulls: false,
    sampling: "none",
    animationEasing: "linear",
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: "clone"
    },
    triggerLineEvent: false
  };
  return LineSeriesModel2;
}(Series_default);
var LineSeries_default = LineSeriesModel;

// node_modules/echarts/lib/chart/helper/labelHelper.js
function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  var len2 = labelDims.length;
  if (len2 === 1) {
    var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    var vals = [];
    for (var i3 = 0;i3 < labelDims.length; i3++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i3]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray(interpolatedValue)) {
    return interpolatedValue + "";
  }
  var vals = [];
  for (var i3 = 0;i3 < labelDims.length; i3++) {
    var dimIndex = data.getDimensionIndex(labelDims[i3]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}

// node_modules/echarts/lib/chart/helper/Symbol.js
var Symbol2 = function(_super) {
  __extends(Symbol3, _super);
  function Symbol3(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;
    _this.updateData(data, idx, seriesScope, opts);
    return _this;
  }
  Symbol3.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  Symbol3.prototype.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  Symbol3.prototype.getSymbolType = function() {
    return this._symbolType;
  };
  Symbol3.prototype.getSymbolPath = function() {
    return this.childAt(0);
  };
  Symbol3.prototype.highlight = function() {
    enterEmphasis(this.childAt(0));
  };
  Symbol3.prototype.downplay = function() {
    leaveEmphasis(this.childAt(0));
  };
  Symbol3.prototype.setZ = function(zlevel, z3) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z3;
  };
  Symbol3.prototype.setDraggable = function(draggable, hasCursorOption) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
  };
  Symbol3.prototype.updateData = function(data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data.hostModel;
    var symbolSize = Symbol3.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      var symbolPath = this.childAt(0);
      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  };
  Symbol3.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    var symbolStyle = data.getItemVisual(idx, "style");
    var visualColor = symbolStyle.fill;
    if (symbolPath instanceof Image_default) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    var liftZ = data.getItemVisual(idx, "liftZ");
    var z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
    emphasisState.scaleX = this._sizeX * scaleRatio;
    emphasisState.scaleY = this._sizeY * scaleRatio;
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Symbol3.prototype.setSymbolScale = function(scale3) {
    this.scaleX = this.scaleY = scale3;
  };
  Symbol3.prototype.fadeOut = function(cb, seriesModel, opt) {
    var symbolPath = this.childAt(0);
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb: function() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex,
      cb,
      removeOpt: animationOpt
    });
  };
  Symbol3.getSymbolSize = function(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  };
  return Symbol3;
}(Group_default);
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var Symbol_default = Symbol2;

// node_modules/echarts/lib/chart/helper/SymbolDraw.js
function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject2(opt)) {
    opt = {
      isIgnore: opt
    };
  }
  return opt || {};
}
function makeSeriesScope(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = function() {
  function SymbolDraw2(SymbolCtor) {
    this.group = new Group_default;
    this._SymbolCtor = SymbolCtor || Symbol_default;
  }
  SymbolDraw2.prototype.updateData = function(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope(data);
    var symbolUpdateOpt = {
      disableAnimation
    };
    var getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      var point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };
  SymbolDraw2.prototype.updateLayout = function() {
    var _this = this;
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point = _this._getSymbolPoint(idx);
        el.setPosition(point);
        el.markRedraw();
      });
    }
  };
  SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };
  SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start;idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);
      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  SymbolDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  SymbolDraw2.prototype.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw2;
}();
var SymbolDraw_default = SymbolDraw;

// node_modules/echarts/lib/chart/line/helper.js
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  var dims = map(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(data, dims[0])) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(data, dims[1])) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis, valueOrigin) {
  var valueStart = 0;
  var extent3 = valueAxis.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value2 = NaN;
  if (dataCoordInfo.stacked) {
    value2 = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value2)) {
    value2 = dataCoordInfo.valueStart;
  }
  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value2;
  return coordSys.dataToPoint(stackedData);
}

// node_modules/echarts/lib/util/vendor.js
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}

// node_modules/echarts/lib/chart/line/lineAnimationDiff.js
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({
      cmd: "+",
      idx
    });
  }).update(function(newIdx, oldIdx) {
    diffResult.push({
      cmd: "=",
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function(idx) {
    diffResult.push({
      cmd: "-",
      idx
    });
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData);
  var currPoints = [];
  var nextPoints = [];
  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldPoints = oldData.getLayout("points") || [];
  var newPoints = newData.getLayout("points") || [];
  for (var i3 = 0;i3 < diff.length; i3++) {
    var diffItem = diff[i3];
    var pointAdded = true;
    var oldIdx2 = undefined;
    var newIdx2 = undefined;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a3, b) {
    return rawIndices[a3] - rawIndices[b];
  });
  var len2 = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len2);
  var sortedNextPoints = createFloat32Array(len2);
  var sortedCurrStackedPoints = createFloat32Array(len2);
  var sortedNextStackedPoints = createFloat32Array(len2);
  var sortedStatus = [];
  for (var i3 = 0;i3 < sortedIndices.length; i3++) {
    var idx = sortedIndices[i3];
    var i22 = i3 * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i22] = currPoints[idx2];
    sortedCurrPoints[i22 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i22] = nextPoints[idx2];
    sortedNextPoints[i22 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i22] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i22 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i22] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i22 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i3] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

// node_modules/echarts/lib/chart/line/poly.js
var mathMin6 = Math.min;
var mathMax6 = Math.max;
function isPointNull(x3, y3) {
  return isNaN(x3) || isNaN(y3);
}
function drawSegment(ctx, points2, start2, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start2;
  var k3 = 0;
  for (;k3 < segLen; k3++) {
    var x3 = points2[idx * 2];
    var y3 = points2[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull(x3, y3)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir > 0 ? "moveTo" : "lineTo"](x3, y3);
      cpx0 = x3;
      cpy0 = y3;
    } else {
      var dx = x3 - prevX;
      var dy = y3 - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir;
        continue;
      }
      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextX = points2[nextIdx * 2];
        var nextY = points2[nextIdx * 2 + 1];
        while (nextX === x3 && nextY === y3 && k3 < segLen) {
          k3++;
          nextIdx += dir;
          idx += dir;
          nextX = points2[nextIdx * 2];
          nextY = points2[nextIdx * 2 + 1];
          x3 = points2[idx * 2];
          y3 = points2[idx * 2 + 1];
          dx = x3 - prevX;
          dy = y3 - prevY;
        }
        var tmpK = k3 + 1;
        if (connectNulls) {
          while (isPointNull(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
          }
        }
        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = undefined;
        var nextCpy0 = undefined;
        if (tmpK >= segLen || isPointNull(nextX, nextY)) {
          cpx1 = x3;
          cpy1 = y3;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x3 - prevX;
          var dx1 = nextX - x3;
          var dy0 = y3 - prevY;
          var dy1 = nextY - y3;
          var lenPrevSeg = undefined;
          var lenNextSeg = undefined;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x3 - dir_1 * lenPrevSeg * smooth;
            cpy1 = y3;
            nextCpx0 = x3 + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y3;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x3;
            cpy1 = y3 - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x3;
            nextCpy0 = y3 + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x3 - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y3 - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x3 + vx * smooth * ratioNextSeg;
            nextCpy0 = y3 + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin6(nextCpx0, mathMax6(nextX, x3));
            nextCpy0 = mathMin6(nextCpy0, mathMax6(nextY, y3));
            nextCpx0 = mathMax6(nextCpx0, mathMin6(nextX, x3));
            nextCpy0 = mathMax6(nextCpy0, mathMin6(nextY, y3));
            vx = nextCpx0 - x3;
            vy = nextCpy0 - y3;
            cpx1 = x3 - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y3 - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin6(cpx1, mathMax6(prevX, x3));
            cpy1 = mathMin6(cpy1, mathMax6(prevY, y3));
            cpx1 = mathMax6(cpx1, mathMin6(prevX, x3));
            cpy1 = mathMax6(cpy1, mathMin6(prevY, y3));
            vx = x3 - cpx1;
            vy = y3 - cpy1;
            nextCpx0 = x3 + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y3 + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x3, y3);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x3, y3);
      }
    }
    prevX = x3;
    prevY = y3;
    idx += dir;
  }
  return k3;
}
var ECPolylineShape = function() {
  function ECPolylineShape2() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
  return ECPolylineShape2;
}();
var ECPolyline = function(_super) {
  __extends(ECPolyline2, _super);
  function ECPolyline2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polyline";
    return _this;
  }
  ECPolyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECPolyline2.prototype.getDefaultShape = function() {
    return new ECPolylineShape;
  };
  ECPolyline2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var i3 = 0;
    var len2 = points2.length / 2;
    if (shape.connectNulls) {
      for (;len2 > 0; len2--) {
        if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (;i3 < len2; i3++) {
        if (!isPointNull(points2[i3 * 2], points2[i3 * 2 + 1])) {
          break;
        }
      }
    }
    while (i3 < len2) {
      i3 += drawSegment(ctx, points2, i3, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };
  ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    var path = this.path;
    var data = path.data;
    var CMD4 = PathProxy_default.CMD;
    var x0;
    var y0;
    var isDimX = dim === "x";
    var roots2 = [];
    for (var i3 = 0;i3 < data.length; ) {
      var cmd = data[i3++];
      var x3 = undefined;
      var y3 = undefined;
      var x22 = undefined;
      var y22 = undefined;
      var x32 = undefined;
      var y32 = undefined;
      var t4 = undefined;
      switch (cmd) {
        case CMD4.M:
          x0 = data[i3++];
          y0 = data[i3++];
          break;
        case CMD4.L:
          x3 = data[i3++];
          y3 = data[i3++];
          t4 = isDimX ? (xOrY - x0) / (x3 - x0) : (xOrY - y0) / (y3 - y0);
          if (t4 <= 1 && t4 >= 0) {
            var val = isDimX ? (y3 - y0) * t4 + y0 : (x3 - x0) * t4 + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x0 = x3;
          y0 = y3;
          break;
        case CMD4.C:
          x3 = data[i3++];
          y3 = data[i3++];
          x22 = data[i3++];
          y22 = data[i3++];
          x32 = data[i3++];
          y32 = data[i3++];
          var nRoot = isDimX ? cubicRootAt(x0, x3, x22, x32, xOrY, roots2) : cubicRootAt(y0, y3, y22, y32, xOrY, roots2);
          if (nRoot > 0) {
            for (var i_1 = 0;i_1 < nRoot; i_1++) {
              var t_1 = roots2[i_1];
              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? cubicAt(y0, y3, y22, y32, t_1) : cubicAt(x0, x3, x22, x32, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x0 = x32;
          y0 = y32;
          break;
      }
    }
  };
  return ECPolyline2;
}(Path_default);
var ECPolygonShape = function(_super) {
  __extends(ECPolygonShape2, _super);
  function ECPolygonShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ECPolygonShape2;
}(ECPolylineShape);
var ECPolygon = function(_super) {
  __extends(ECPolygon2, _super);
  function ECPolygon2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polygon";
    return _this;
  }
  ECPolygon2.prototype.getDefaultShape = function() {
    return new ECPolygonShape;
  };
  ECPolygon2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i3 = 0;
    var len2 = points2.length / 2;
    var smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (;len2 > 0; len2--) {
        if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (;i3 < len2; i3++) {
        if (!isPointNull(points2[i3 * 2], points2[i3 * 2 + 1])) {
          break;
        }
      }
    }
    while (i3 < len2) {
      var k3 = drawSegment(ctx, points2, i3, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i3 + k3 - 1, k3, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i3 += k3 + 1;
      ctx.closePath();
    }
  };
  return ECPolygon2;
}(Path_default);

// node_modules/echarts/lib/chart/helper/createRenderPlanner.js
function createRenderPlanner() {
  var inner4 = makeInner();
  return function(seriesModel) {
    var fields = inner4(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender;
    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}

// node_modules/echarts/lib/view/Chart.js
var inner4 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
  function ChartView2() {
    this.group = new Group_default;
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }
  ChartView2.prototype.init = function(ecModel, api) {};
  ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    if (true) {
      throw new Error("render method must been implemented");
    }
  };
  ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  };
  ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    toggleHighlight(data, payload, "normal");
  };
  ChartView2.prototype.remove = function(ecModel, api) {
    this.group.removeAll();
  };
  ChartView2.prototype.dispose = function(ecModel, api) {};
  ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this.group, cb);
  };
  ChartView2.markUpdateMethod = function(payload, methodName) {
    inner4(payload).updateMethod = methodName;
  };
  ChartView2.protoInitialize = function() {
    var proto = ChartView2.prototype;
    proto.type = "chart";
  }();
  return ChartView2;
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  var dataIndex = queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner4(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var Chart_default = ChartView;

// node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x3 = rect.x;
  var y3 = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(["lineStyle", "width"]) || 0;
  x3 -= lineWidth / 2;
  y3 -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  width = Math.ceil(width);
  if (x3 !== Math.floor(x3)) {
    x3 = Math.floor(x3);
    width++;
  }
  var clipPath = new Rect_default({
    shape: {
      x: x3,
      y: y3,
      width,
      height
    }
  });
  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    var duringCb = isFunction(during) ? function(percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x: x3,
        y: y3
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea();
  var r0 = round2(sectorArea.r0, 1);
  var r3 = round2(sectorArea.r, 1);
  var clipPath = new Sector_default({
    shape: {
      cx: round2(polar.cx, 1),
      cy: round2(polar.cy, 1),
      r0,
      r: r3,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r: r3
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}

// node_modules/echarts/lib/coord/CoordinateSystem.js
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}

// node_modules/echarts/lib/chart/line/LineView.js
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }
  for (var i3 = 0;i3 < points1.length; i3++) {
    if (points1[i3] !== points2[i3]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points2) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  for (var i3 = 0;i3 < points2.length; ) {
    var x3 = points2[i3++];
    var y3 = points2[i3++];
    if (!isNaN(x3)) {
      minX = Math.min(x3, minX);
      maxX = Math.max(x3, maxX);
    }
    if (!isNaN(y3)) {
      minY = Math.min(y3, minY);
      maxY = Math.max(y3, maxY);
    }
  }
  return [[minX, minY], [maxX, maxY]];
}
function getBoundingDiff(points1, points2) {
  var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
  var _b2 = bboxFromPoints(points2), min23 = _b2[0], max23 = _b2[1];
  return Math.max(Math.abs(min1[0] - min23[0]), Math.abs(min1[1] - min23[1]), Math.abs(max1[0] - max23[0]), Math.abs(max1[1] - max23[1]));
}
function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  var len2 = data.count();
  var points2 = createFloat32Array(len2 * 2);
  for (var idx = 0;idx < len2; idx++) {
    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points2[idx * 2] = pt[0];
    points2[idx * 2 + 1] = pt[1];
  }
  return points2;
}
function turnPointsIntoStep(points2, basePoints, coordSys, stepTurnAt, connectNulls) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  var stepPoints = [];
  var i3 = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];
  var filteredPoints = [];
  if (connectNulls) {
    for (i3 = 0;i3 < points2.length; i3 += 2) {
      var reference = basePoints || points2;
      if (!isNaN(reference[i3]) && !isNaN(reference[i3 + 1])) {
        filteredPoints.push(points2[i3], points2[i3 + 1]);
      }
    }
    points2 = filteredPoints;
  }
  for (i3 = 0;i3 < points2.length - 2; i3 += 2) {
    nextPt[0] = points2[i3 + 2];
    nextPt[1] = points2[i3 + 3];
    pt[0] = points2[i3];
    pt[1] = points2[i3 + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points2[i3++], points2[i3++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len2 = colorStops.length;
  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    var coord0 = stop0.coord;
    var p3 = (clippedCoord - coord0) / (stop1.coord - coord0);
    var color = lerp2(p3, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color
    };
  }
  for (var i3 = 0;i3 < len2; i3++) {
    var stop_1 = colorStops[i3];
    var coord = stop_1.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api) {
  var visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    if (true) {
      console.warn("Visual map on line style is only supported on cartesian2d.");
    }
    return;
  }
  var coordDim;
  var visualMeta;
  for (var i3 = visualMetaList.length - 1;i3 >= 0; i3--) {
    var dimInfo = data.getDimensionInfo(visualMetaList[i3].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i3];
      break;
    }
  }
  if (!visualMeta) {
    if (true) {
      console.warn("Visual map on line style only support x or y dimension.");
    }
    return;
  }
  var axis = coordSys.getAxis(coordDim);
  var colorStops = map(visualMeta.stops, function(stop) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  var tinyExtent = 10;
  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;
  if (coordSpan < 0.001) {
    return "transparent";
  }
  each(colorStopsInRange, function(stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  var gradient = new LinearGradient_default(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get("showAllSymbol");
  var isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {
    return;
  }
  var categoryDataDim = data.mapDimension(categoryAxis.dim);
  var labelMap = {};
  each(categoryAxis.getViewLabels(), function(labelItem) {
    var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis, data) {
  var axisExtent = categoryAxis.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
  isNaN(availSize) && (availSize = 0);
  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));
  for (var dataIndex = 0;dataIndex < dataLen; dataIndex += step) {
    if (Symbol_default.getSymbolSize(data, dataIndex)[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull2(x3, y3) {
  return isNaN(x3) || isNaN(y3);
}
function getLastIndexNotNull(points2) {
  var len2 = points2.length / 2;
  for (;len2 > 0; len2--) {
    if (!isPointNull2(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points2, idx) {
  return [points2[idx * 2], points2[idx * 2 + 1]];
}
function getIndexRange(points2, xOrY, dim) {
  var len2 = points2.length / 2;
  var dimIdx = dim === "x" ? 0 : 1;
  var a3;
  var b;
  var prevIndex = 0;
  var nextIndex = -1;
  for (var i3 = 0;i3 < len2; i3++) {
    b = points2[i3 * 2 + dimIdx];
    if (isNaN(b) || isNaN(points2[i3 * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i3 === 0) {
      a3 = b;
      continue;
    }
    if (a3 <= xOrY && b >= xOrY || a3 >= xOrY && b <= xOrY) {
      nextIndex = i3;
      break;
    }
    prevIndex = i3;
    a3 = b;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a3) / (b - a3)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
    if (seriesModel.get([SPECIAL_STATES[i3], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    var endLabelModel_1 = seriesModel.getModel("endLabel");
    var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
      var endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    if (true) {
      if (seriesModel.get(["endLabel", "show"])) {
        console.warn("endLabel is not supported for lines in polar systems.");
      }
    }
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = function(_super) {
  __extends(LineView2, _super);
  function LineView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineView2.prototype.init = function() {
    var lineGroup = new Group_default;
    var symbolDraw = new SymbolDraw_default;
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
    this._changePolyState = bind(this._changePolyState, this);
  };
  LineView2.prototype.render = function(seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel("lineStyle");
    var areaStyleModel = seriesModel.getModel("areaStyle");
    var points2 = data.getLayout("points") || [];
    var isCoordSysPolar = coordSys.type === "polar";
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = !ecModel.ssr && seriesModel.get("animation");
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get("origin");
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get("showSymbol");
    var connectNulls = seriesModel.get("connectNulls");
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    var step = !isCoordSysPolar ? seriesModel.get("step") : false;
    var clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
        }
        points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
      }
      polyline = this._newPolyline(points2);
      if (isAreaChart) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      var oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
            }
            points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
          }
          polyline.setShape({
            points: points2
          });
          polygon && polygon.setShape({
            points: points2,
            stackedOnPoints
          });
        }
      }
    }
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
      fill: "none",
      stroke: visualColor,
      lineJoin: "bevel"
    }));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      var emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get("smooth"));
    var smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      var stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }
    var changePolyState = this._changePolyState;
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points2;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  };
  LineView2.prototype.packEventData = function(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  };
  LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points2 = data.getLayout("points");
      var symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        var x3 = points2[dataIndex * 2];
        var y3 = points2[dataIndex * 2 + 1];
        if (isNaN(x3) || isNaN(y3)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x3, y3)) {
          return;
        }
        var zlevel = seriesModel.get("zlevel") || 0;
        var z3 = seriesModel.get("z") || 0;
        symbol = new Symbol_default(data, dataIndex);
        symbol.x = x3;
        symbol.y = y3;
        symbol.setZ(zlevel, z3);
        var symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z3;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      Chart_default.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      Chart_default.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype._changePolyState = function(toState) {
    var polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  };
  LineView2.prototype._newPolyline = function(points2) {
    var polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points2
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  };
  LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
    var polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points2,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  };
  LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get("animationDuration");
    if (isFunction(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    var seriesDelay = seriesModel.get("animationDelay") || 0;
    var seriesDelayValue = isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;
    data.eachItemGraphicEl(function(symbol, idx) {
      var el = symbol;
      if (el) {
        var point = [symbol.x, symbol.y];
        var start2 = undefined;
        var end2 = undefined;
        var current = undefined;
        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        var delay = isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
        var symbolPath = el.getSymbolPath();
        var text = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  };
  LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var points2 = data_2.getLayout("points");
      if (!points2) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      var endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new Text_default({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      var dataIndex = getLastIndexNotNull(points2);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  };
  LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      var points2 = data.getLayout("points");
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get("connectNulls");
      var precision = endLabelModel.get("precision");
      var distance2 = endLabelModel.get("distance") || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? "x" : "y";
      var dataIndexRange = getIndexRange(points2, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value2 = undefined;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          var pt = getPointAtIndex(points2, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value2 = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value2 = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points2, idx);
        valueAnimation && (value2 = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        var inner5 = labelInner(endLabel);
        if (typeof inner5.setLabelText === "function") {
          inner5.setLabelText(value2);
        }
      }
    }
  };
  LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;
    if (step) {
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);
      current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);
      next = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    var updatedDataInfo = [];
    var diffStatus = diff.status;
    for (var i3 = 0;i3 < diffStatus.length; i3++) {
      var cmd = diffStatus[i3].cmd;
      if (cmd === "=") {
        var el = data.getItemGraphicEl(diffStatus[i3].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i3
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        var points2 = polyline.shape.__points;
        for (var i4 = 0;i4 < updatedDataInfo.length; i4++) {
          var el2 = updatedDataInfo[i4].el;
          var offset = updatedDataInfo[i4].ptIdx * 2;
          el2.x = points2[offset];
          el2.y = points2[offset + 1];
          el2.markRedraw();
        }
      });
    }
  };
  LineView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };
  LineView2.type = "line";
  return LineView2;
}(Chart_default);
var LineView_default = LineView;

// node_modules/echarts/lib/layout/points.js
function pointsLayout(seriesType, forceStoreInTypedArray) {
  return {
    seriesType,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data2) {
          var segCount = params.end - params.start;
          var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i3 = params.start, offset = 0;i3 < params.end; i3++) {
            var point = undefined;
            if (dimLen === 1) {
              var x3 = store.get(dimIdx0, i3);
              point = coordSys.dataToPoint(x3, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i3);
              tmpIn[1] = store.get(dimIdx1, i3);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points2[offset++] = point[0];
              points2[offset++] = point[1];
            } else {
              data2.setItemLayout(i3, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points2);
        }
      };
    }
  };
}

// node_modules/echarts/lib/processor/dataSample.js
var samplers = {
  average: function(frame) {
    var sum = 0;
    var count = 0;
    for (var i3 = 0;i3 < frame.length; i3++) {
      if (!isNaN(frame[i3])) {
        sum += frame[i3];
        count++;
      }
    }
    return count === 0 ? NaN : sum / count;
  },
  sum: function(frame) {
    var sum = 0;
    for (var i3 = 0;i3 < frame.length; i3++) {
      sum += frame[i3] || 0;
    }
    return sum;
  },
  max: function(frame) {
    var max3 = -Infinity;
    for (var i3 = 0;i3 < frame.length; i3++) {
      frame[i3] > max3 && (max3 = frame[i3]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    var min3 = Infinity;
    for (var i3 = 0;i3 < frame.length; i3++) {
      frame[i3] < min3 && (min3 = frame[i3]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType) {
  return {
    seriesType,
    reset: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get("sampling");
      var coordSys = seriesModel.coordinateSystem;
      var count = data.count();
      if (count > 10 && coordSys.type === "cartesian2d" && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var extent3 = baseAxis.getExtent();
        var dpr2 = api.getDevicePixelRatio();
        var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        var rate = Math.round(count / size);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));
          } else if (sampling === "minmax") {
            seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis.dim), 1 / rate));
          }
          var sampler = undefined;
          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

// node_modules/echarts/lib/chart/line/install.js
function install(registers) {
  registers.registerChartView(LineView_default);
  registers.registerSeriesModel(LineSeries_default);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
// node_modules/echarts/lib/layout/barGrid.js
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey(axis) {
  return axis.dim + axis.index;
}
function prepareLayoutBarSeries(seriesType, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  var axisValues = {};
  each(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    var data = seriesModel.getData();
    var key2 = baseAxis.dim + "_" + baseAxis.index;
    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    var store = data.getStore();
    for (var i3 = 0, cnt = store.count();i3 < cnt; ++i3) {
      var value2 = store.get(dimIdx, i3);
      if (!axisValues[key2]) {
        axisValues[key2] = [value2];
      } else {
        axisValues[key2].push(value2);
      }
    }
  });
  var axisMinGaps = {};
  for (var key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      var valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a3, b) {
          return a3 - b;
        });
        var min3 = null;
        for (var j3 = 1;j3 < valuesInAxis.length; ++j3) {
          var delta = valuesInAxis[j3] - valuesInAxis[j3 - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      var key = baseAxis.dim + "_" + baseAxis.index;
      var minGap = axisMinGaps[key];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale3 = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale3[1] - scale3[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      var data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    var barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
    var barMinWidth = parsePercent2(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  var columnsMap = {};
  each(seriesInfoList, function(seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      var columnCount = keys(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    var categoryGap = parsePercent2(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each(stacks, function(column) {
      var maxWidth = column.maxWidth;
      var minWidth = column.minWidth;
      if (!column.width) {
        var finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        var finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset = -widthSum / 2;
    each(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId(seriesModel)];
    }
    return result;
  }
}
function layout(seriesType, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each(seriesModels, function(seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType) {
  return {
    seriesType,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));
      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get("showBackground", true);
      var valueDim = data.mapDimension(valueAxis.dim);
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      var isValueAxisH = valueAxis.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      var columnWidth = data.getLayout("size");
      var columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          var count = params.count;
          var largePoints = isLarge && createFloat32Array(count * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);
          var largeDataIndices = isLarge && createFloat32Array(count);
          var coordLayout = cartesian.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data2.getStore();
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            var value2 = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var stackStartValue = undefined;
            if (stacked) {
              stackStartValue = +value2 - store.get(valueDimIdx, dataIndex);
            }
            var x3 = undefined;
            var y3 = undefined;
            var width = undefined;
            var height = undefined;
            if (isValueAxisH) {
              var coord = cartesian.dataToPoint([value2, baseValue]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x3 = baseCoord;
              y3 = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian.dataToPoint([baseValue, value2]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);
                baseCoord = startCoord[1];
              }
              x3 = coord[0] + columnOffset;
              y3 = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {
                x: x3,
                y: y3,
                width,
                height
              });
            } else {
              largePoints[idxOffset] = x3;
              largePoints[idxOffset + 1] = y3;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x3;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y3 : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis) {
  var startValue = valueAxis.model.get("startValue");
  if (!startValue) {
    startValue = 0;
  }
  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === "log" ? startValue > 0 ? startValue : 1 : startValue));
}

// node_modules/echarts/lib/chart/bar/BaseBarSeries.js
var BaseBarSeriesModel = function(_super) {
  __extends(BaseBarSeriesModel2, _super);
  function BaseBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BaseBarSeriesModel2.type;
    return _this;
  }
  BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  };
  BaseBarSeriesModel2.prototype.getMarkerPosition = function(value2, dims, startingAtTick) {
    var coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      var clampData_1 = coordSys.clampData(value2);
      var pt_1 = coordSys.dataToPoint(clampData_1);
      if (startingAtTick) {
        each(coordSys.getAxes(), function(axis, idx) {
          if (axis.type === "category" && dims != null) {
            var tickCoords = axis.getTicksCoords();
            var alignTicksWithLabel = axis.getTickModel().get("alignWithLabel");
            var targetTickId = clampData_1[idx];
            var isEnd = dims[idx] === "x1" || dims[idx] === "y1";
            if (isEnd && !alignTicksWithLabel) {
              targetTickId += 1;
            }
            if (tickCoords.length < 2) {
              return;
            } else if (tickCoords.length === 2) {
              pt_1[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);
              return;
            }
            var leftCoord = undefined;
            var coord = undefined;
            var stepTickValue = 1;
            for (var i3 = 0;i3 < tickCoords.length; i3++) {
              var tickCoord = tickCoords[i3].coord;
              var tickValue = i3 === tickCoords.length - 1 ? tickCoords[i3 - 1].tickValue + stepTickValue : tickCoords[i3].tickValue;
              if (tickValue === targetTickId) {
                coord = tickCoord;
                break;
              } else if (tickValue < targetTickId) {
                leftCoord = tickCoord;
              } else if (leftCoord != null && tickValue > targetTickId) {
                coord = (tickCoord + leftCoord) / 2;
                break;
              }
              if (i3 === 1) {
                stepTickValue = tickValue - tickCoords[0].tickValue;
              }
            }
            if (coord == null) {
              if (!leftCoord) {
                coord = tickCoords[0].coord;
              } else if (leftCoord) {
                coord = tickCoords[tickCoords.length - 1].coord;
              }
            }
            pt_1[idx] = axis.toGlobalCoord(coord);
          }
        });
      } else {
        var data = this.getData();
        var offset = data.getLayout("offset");
        var size = data.getLayout("size");
        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt_1[offsetIndex] += offset + size / 2;
      }
      return pt_1;
    }
    return [NaN, NaN];
  };
  BaseBarSeriesModel2.type = "series.__base_bar__";
  BaseBarSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    barMinHeight: 0,
    barMinAngle: 0,
    large: false,
    largeThreshold: 400,
    progressive: 3000,
    progressiveChunkMode: "mod"
  };
  return BaseBarSeriesModel2;
}(Series_default);
Series_default.registerClass(BaseBarSeriesModel);
var BaseBarSeries_default = BaseBarSeriesModel;

// node_modules/echarts/lib/chart/bar/BarSeries.js
var BarSeriesModel = function(_super) {
  __extends(BarSeriesModel2, _super);
  function BarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BarSeriesModel2.type;
    return _this;
  }
  BarSeriesModel2.prototype.getInitialData = function() {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  };
  BarSeriesModel2.prototype.getProgressive = function() {
    return this.get("large") ? this.get("progressive") : false;
  };
  BarSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.get("progressiveThreshold");
    var largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  };
  BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };
  BarSeriesModel2.type = "series.bar";
  BarSeriesModel2.dependencies = ["grid", "polar"];
  BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: "rgba(180, 180, 180, 0.2)",
      borderColor: null,
      borderWidth: 0,
      borderType: "solid",
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel2;
}(BaseBarSeries_default);
var BarSeries_default = BarSeriesModel;

// node_modules/echarts/lib/util/throttle.js
var ORIGIN_METHOD = "\x00__throttleOriginMethod";
var RATE = "\x00__throttleRate";
var THROTTLE_TYPE = "\x00__throttleType";
function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  var cb = function() {
    var cbArgs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      cbArgs[_i] = arguments[_i];
    }
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear(obj, fnAttr) {
  var fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

// node_modules/echarts/lib/util/shape/sausage.js
var SausageShape = function() {
  function SausageShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return SausageShape2;
}();
var SausagePath = function(_super) {
  __extends(SausagePath2, _super);
  function SausagePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "sausage";
    return _this;
  }
  SausagePath2.prototype.getDefaultShape = function() {
    return new SausageShape;
  };
  SausagePath2.prototype.buildPath = function(ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r3 = Math.max(shape.r, 0);
    var dr = (r3 - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI27 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI27 : startAngle - endAngle < PI27;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI27 : -PI27);
    }
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r3 + cx, unitStartY * r3 + cy);
    }
    ctx.arc(cx, cy, r3, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  };
  return SausagePath2;
}(Path_default);
var sausage_default = SausagePath;

// node_modules/echarts/lib/label/sectorLabel.js
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    var textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    var mappedSectorPosition = positionMapping(textPosition);
    var distance2 = opts2.distance != null ? opts2.distance : 5;
    var sector = this.shape;
    var cx = sector.cx;
    var cy = sector.cy;
    var r3 = sector.r;
    var r0 = sector.r0;
    var middleR = (r3 + r0) / 2;
    var startAngle = sector.startAngle;
    var endAngle = sector.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r3 - r0) / 2 : 0;
    var mathCos5 = Math.cos;
    var mathSin5 = Math.sin;
    var x3 = cx + r3 * mathCos5(startAngle);
    var y3 = cy + r3 * mathSin5(startAngle);
    var textAlign = "left";
    var textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x3 = cx + (r0 - distance2) * mathCos5(middleAngle);
        y3 = cy + (r0 - distance2) * mathSin5(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x3 = cx + (r0 + distance2) * mathCos5(middleAngle);
        y3 = cy + (r0 + distance2) * mathSin5(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x3 = cx + middleR * mathCos5(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y3 = cy + middleR * mathSin5(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x3 = cx + middleR * mathCos5(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y3 = cy + middleR * mathSin5(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x3 = cx + middleR * mathCos5(middleAngle);
        y3 = cy + middleR * mathSin5(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x3 = cx + (r3 + distance2) * mathCos5(middleAngle);
        y3 = cy + (r3 + distance2) * mathSin5(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x3 = cx + (r3 - distance2) * mathCos5(middleAngle);
        y3 = cy + (r3 - distance2) * mathSin5(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x3 = cx + middleR * mathCos5(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y3 = cy + middleR * mathSin5(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x3 = cx + middleR * mathCos5(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y3 = cy + middleR * mathSin5(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x3;
    out2.y = y3;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  var shape = sector.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  var rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}

// node_modules/echarts/lib/chart/helper/sectorHelper.js
function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }
  if (!isArray(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map(cornerRadius, function(cr) {
      return parsePercent(cr, dr);
    })
  };
}

// node_modules/echarts/lib/chart/bar/BarView.js
var mathMax7 = Math.max;
var mathMin7 = Math.min;
function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      var expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView = function(_super) {
  __extends(BarView2, _super);
  function BarView2() {
    var _this = _super.call(this) || this;
    _this.type = BarView2.type;
    _this._isFirstFrame = true;
    return _this;
  }
  BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api);
    this._updateDrawMode(seriesModel);
    var coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    } else if (true) {
      warn("Only cartesian2d and polar supported for bar.");
    }
  };
  BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype.incrementalRender = function(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  };
  BarView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  BarView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }
    var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    var roundCap = seriesModel.get("roundCap", true);
    var drawBackground = seriesModel.get("showBackground", true);
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var barBorderRadius = backgroundModel.get("borderRadius") || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      } else {
        bgEl.setShape("cornerRadius", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data.diff(oldData).add(function(dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
      }
      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {
          shape: layout2
        }, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout2 = getLayout[coord.type](data, newIndex, itemModel);
      if (drawBackground) {
        var bgEl = undefined;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          } else {
            bgEl.setShape("cornerRadius", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps(bgEl, {
          shape
        }, animationModel, newIndex);
      }
      var el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
        group.remove(el);
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
        if (isClipped) {
          group.remove(el);
        }
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        var textEl = el.getTextContent();
        if (textEl) {
          var labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps(el, {
          shape: layout2
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_default);
    bgGroup.removeAll();
    for (var i3 = 0;i3 < bgEls.length; ++i3) {
      bgGroup.add(bgEls[i3]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };
  BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
    this._clear();
    createLarge(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    this._removeBackground();
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };
  BarView2.prototype._updateLargeClip = function(seriesModel) {
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };
  BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
    var _this = this;
    if (!data.count()) {
      return;
    }
    var baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);
      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function(idx) {
        var el = data.getItemGraphicEl(idx);
        var shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = function() {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };
      api.getZr().on("rendered", this._onRendered);
    }
  };
  BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort(function(a3, b) {
      return b.mappedValue - a3.mappedValue;
    });
    return {
      ordinalNumbers: map(info, function(item) {
        return item.ordinalNumber;
      })
    };
  };
  BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
    var scale3 = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;
    for (var tickNum = 0, len2 = scale3.getOrdinalMeta().categories.length;tickNum < len2; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale3.getRawOrdinalNumber(tickNum));
      var value2 = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value2 > lastValue) {
        return true;
      }
      lastValue = value2;
    }
    return false;
  };
  BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
    var scale3 = baseAxis.scale;
    var extent3 = scale3.getExtent();
    var tickNum = Math.max(0, extent3[0]);
    var tickMax = Math.min(extent3[1], scale3.getOrdinalMeta().categories.length - 1);
    for (;tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale3.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };
  BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    var sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  };
  BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;
    var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });
    api.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };
  BarView2.prototype.remove = function(ecModel, api) {
    this._clear(this._model);
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype.dispose = function(ecModel, api) {
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype._removeOnRenderedListener = function(api) {
    if (this._onRendered) {
      api.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  };
  BarView2.prototype._clear = function(model) {
    var group = this.group;
    var data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  };
  BarView2.prototype._removeBackground = function() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };
  BarView2.type = "bar";
  return BarView2;
}(Chart_default);
var clip = {
  cartesian2d: function(coordSysBoundingRect, layout2) {
    var signWidth = layout2.width < 0 ? -1 : 1;
    var signHeight = layout2.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x3 = mathMax7(layout2.x, coordSysBoundingRect.x);
    var x22 = mathMin7(layout2.x + layout2.width, coordSysX2);
    var y3 = mathMax7(layout2.y, coordSysBoundingRect.y);
    var y22 = mathMin7(layout2.y + layout2.height, coordSysY2);
    var xClipped = x22 < x3;
    var yClipped = y22 < y3;
    layout2.x = xClipped && x3 > coordSysX2 ? x22 : x3;
    layout2.y = yClipped && y3 > coordSysY2 ? y22 : y3;
    layout2.width = xClipped ? 0 : x22 - x3;
    layout2.height = yClipped ? 0 : y22 - y3;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    return xClipped || yClipped;
  },
  polar: function(coordSysClipArea, layout2) {
    var signR = layout2.r0 <= layout2.r ? 1 : -1;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    var r3 = mathMin7(layout2.r, coordSysClipArea.r);
    var r0 = mathMax7(layout2.r0, coordSysClipArea.r0);
    layout2.r = r3;
    layout2.r0 = r0;
    var clipped = r3 - r0 < 0;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function(seriesModel, data, newIndex, layout2, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect_default({
      shape: extend({}, layout2),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar: function(seriesModel, data, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? sausage_default : Sector_default;
    var sector = new ShapeClass({
      shape: layout2,
      z2: 1
    });
    sector.name = "item";
    var positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === sausage_default
    });
    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? "r" : "endAngle";
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? layout2.r0 : layout2.startAngle;
      animateTarget[animateProperty] = layout2[animateProperty];
      (isUpdate ? updateProps : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get("realtimeSort", true);
  var baseAxis = coordSys.getBaseAxis();
  if (true) {
    if (realtimeSortOption) {
      if (baseAxis.type !== "category") {
        warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
      }
      if (coordSys.type !== "cartesian2d") {
        warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
      }
    }
  }
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout2, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout2.x,
      width: layout2.width
    };
    seriesTarget = {
      y: layout2.y,
      height: layout2.height
    };
  } else {
    axisTarget = {
      y: layout2.y,
      height: layout2.height
    };
    seriesTarget = {
      x: layout2.x,
      width: layout2.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (var i3 = 0;i3 < props.length; i3++) {
    if (!isFinite(obj[props[i3]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d: function(layout2) {
    return !checkPropertiesNotValid(layout2, rectPropties);
  },
  polar: function(layout2) {
    return !checkPropertiesNotValid(layout2, polarPropties);
  }
};
var getLayout = {
  cartesian2d: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
    var signX = layout2.width > 0 ? 1 : -1;
    var signY = layout2.height > 0 ? 1 : -1;
    return {
      x: layout2.x + signX * fixedLineWidth / 2,
      y: layout2.y + signY * fixedLineWidth / 2,
      width: layout2.width - signX * fixedLineWidth,
      height: layout2.height - signY * fixedLineWidth
    };
  },
  polar: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    return {
      cx: layout2.cx,
      cy: layout2.cy,
      r0: layout2.r0,
      r: layout2.r,
      startAngle: layout2.startAngle,
      endAngle: layout2.endAngle,
      clockwise: layout2.clockwise
    };
  }
};
function isZeroOnPolar(layout2) {
  return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return function(isRadial2) {
    var arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return function(position) {
      switch (position) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position + arcOrAngle;
        default:
          return position;
      }
    };
  }(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    var borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
    el.setShape("r", borderRadius);
  } else if (!seriesModel.get("roundCap")) {
    var sectorShape = el.shape;
    var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend(sectorShape, cornerRadius);
    el.setShape(sectorShape);
  }
  el.useStyle(style);
  var cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el.getTextContent();
  if (isPolar && label) {
    var position = itemModel.get(["label", "position"]);
    el.textConfig.inside = position === "middle" ? true : null;
    setSectorTextRotation(el, position === "outside" ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value2) {
    return getDefaultInterpolatedLabel(data, value2);
  });
  var emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout2)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each(el.states, function(state) {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  var borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = function() {
  function LagePathShape2() {}
  return LagePathShape2;
}();
var LargePath = function(_super) {
  __extends(LargePath2, _super);
  function LargePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeBar";
    return _this;
  }
  LargePath2.prototype.getDefaultShape = function() {
    return new LagePathShape;
  };
  LargePath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size = [];
    var barWidth = this.barWidth;
    for (var i3 = 0;i3 < points2.length; i3 += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points2[i3 + 2];
      startPoint[baseDimIdx] = points2[i3 + baseDimIdx];
      startPoint[valueDimIdx] = points2[i3 + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  };
  return LargePath2;
}(Path_default);
function createLarge(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  var largeDataIndices = data.getLayout("largeDataIndices");
  var barWidth = data.getLayout("size");
  var backgroundModel = seriesModel.getModel("backgroundStyle");
  var bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  var el = new LargePath({
    shape: {
      points: data.getLayout("largePoints")
    },
    incremental: !!incremental,
    ignoreCoarsePointer: true,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  el.style.stroke = null;
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x3, y3) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points2 = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size = [];
  var barWidth = largePath.barWidth;
  for (var i3 = 0, len2 = points2.length / 3;i3 < len2; i3++) {
    var ii = i3 * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points2[ii + 2];
    startPoint[baseDimIdx] = points2[ii + baseDimIdx];
    startPoint[valueDimIdx] = points2[ii + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x3 >= startPoint[0] && x3 <= startPoint[0] + size[0] && y3 >= startPoint[1] && y3 <= startPoint[1] + size[1]) {
      return largeDataIndices[i3];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var rectShape = layout2;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout2;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
  var ElementClz = coord.type === "polar" ? Sector_default : Rect_default;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
    silent: true,
    z2: 0
  });
}
var BarView_default = BarView;

// node_modules/echarts/lib/chart/bar/install.js
function install2(registers) {
  registers.registerChartView(BarView_default);
  registers.registerSeriesModel(BarSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}
// node_modules/echarts/lib/legacy/dataSelectAction.js
function createLegacyDataSelectAction(seriesType, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each([[seriesType + "ToggleSelect", "toggleSelect"], [seriesType + "Select", "select"], [seriesType + "UnSelect", "unselect"]], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
      payload = extend({}, payload);
      if (true) {
        deprecateReplaceLog(payload.type, eventsMap[1]);
      }
      api.dispatchAction(extend(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    if (true) {
      deprecateLog("event " + legacyEventName + " is deprecated.");
    }
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;
      for (var i3 = 0;i3 < selected.length; i3++) {
        if (selected[i3].seriesIndex === seriesIndex) {
          var data = seriesModel.getData();
          var dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on("selectchanged", function(params) {
    var ecModel = api.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}

// node_modules/echarts/lib/chart/pie/pieLayout.js
var PI27 = Math.PI * 2;
var RADIAN = Math.PI / 180;
function getViewRect(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api) {
  var viewRect2 = getViewRect(seriesModel, api);
  var center = seriesModel.get("center");
  var radius = seriesModel.get("radius");
  if (!isArray(radius)) {
    radius = [0, radius];
  }
  var width = parsePercent2(viewRect2.width, api.getWidth());
  var height = parsePercent2(viewRect2.height, api.getHeight());
  var size = Math.min(width, height);
  var r0 = parsePercent2(radius[0], size / 2);
  var r3 = parsePercent2(radius[1], size / 2);
  var cx;
  var cy;
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys) {
    var point = coordSys.dataToPoint(center);
    cx = point[0] || 0;
    cy = point[1] || 0;
  } else {
    if (!isArray(center)) {
      center = [center, center];
    }
    cx = parsePercent2(center[0], width) + viewRect2.x;
    cy = parsePercent2(center[1], height) + viewRect2.y;
  }
  return {
    cx,
    cy,
    r0,
    r: r3
  };
}
function pieLayout(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var viewRect2 = getViewRect(seriesModel, api);
    var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r3 = _a2.r, r0 = _a2.r0;
    var startAngle = -seriesModel.get("startAngle") * RADIAN;
    var endAngle = seriesModel.get("endAngle");
    var padAngle = seriesModel.get("padAngle") * RADIAN;
    endAngle = endAngle === "auto" ? startAngle - PI27 : -endAngle * RADIAN;
    var minAngle = seriesModel.get("minAngle") * RADIAN;
    var minAndPadAngle = minAngle + padAngle;
    var validDataCount = 0;
    data.each(valueDim, function(value2) {
      !isNaN(value2) && validDataCount++;
    });
    var sum = data.getSum(valueDim);
    var unitRadian = Math.PI / (sum || validDataCount) * 2;
    var clockwise = seriesModel.get("clockwise");
    var roseType = seriesModel.get("roseType");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var extent3 = data.getDataExtent(valueDim);
    extent3[0] = 0;
    var dir = clockwise ? 1 : -1;
    var angles = [startAngle, endAngle];
    var halfPadAngle = dir * padAngle / 2;
    normalizeArcAngles(angles, !clockwise);
    startAngle = angles[0], endAngle = angles[1];
    var layoutData = getSeriesLayoutData(seriesModel);
    layoutData.startAngle = startAngle;
    layoutData.endAngle = endAngle;
    layoutData.clockwise = clockwise;
    var angleRange = Math.abs(endAngle - startAngle);
    var restAngle = angleRange;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    data.setLayout({
      viewRect: viewRect2,
      r: r3
    });
    data.each(valueDim, function(value2, idx) {
      var angle;
      if (isNaN(value2)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r3
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum === 0 && stillShowZeroSum ? unitRadian : value2 * unitRadian;
      } else {
        angle = angleRange / validDataCount;
      }
      if (angle < minAndPadAngle) {
        angle = minAndPadAngle;
        restAngle -= minAndPadAngle;
      } else {
        valueSumLargerThanMinAngle += value2;
      }
      var endAngle2 = currentAngle + dir * angle;
      var actualStartAngle = 0;
      var actualEndAngle = 0;
      if (padAngle > angle) {
        actualStartAngle = currentAngle + dir * angle / 2;
        actualEndAngle = actualStartAngle;
      } else {
        actualStartAngle = currentAngle + halfPadAngle;
        actualEndAngle = endAngle2 - halfPadAngle;
      }
      data.setItemLayout(idx, {
        angle,
        startAngle: actualStartAngle,
        endAngle: actualEndAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap(value2, extent3, [r0, r3]) : r3
      });
      currentAngle = endAngle2;
    });
    if (restAngle < PI27 && validDataCount) {
      if (restAngle <= 0.001) {
        var angle_1 = angleRange / validDataCount;
        data.each(valueDim, function(value2, idx) {
          if (!isNaN(value2)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            var actualStartAngle = 0;
            var actualEndAngle = 0;
            if (angle_1 < padAngle) {
              actualStartAngle = startAngle + dir * (idx + 1 / 2) * angle_1;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = startAngle + dir * idx * angle_1 + halfPadAngle;
              actualEndAngle = startAngle + dir * (idx + 1) * angle_1 - halfPadAngle;
            }
            layout_1.startAngle = actualStartAngle;
            layout_1.endAngle = actualEndAngle;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value2, idx) {
          if (!isNaN(value2)) {
            var layout_2 = data.getItemLayout(idx);
            var angle = layout_2.angle === minAndPadAngle ? minAndPadAngle : value2 * unitRadian;
            var actualStartAngle = 0;
            var actualEndAngle = 0;
            if (angle < padAngle) {
              actualStartAngle = currentAngle + dir * angle / 2;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = currentAngle + halfPadAngle;
              actualEndAngle = currentAngle + dir * angle - halfPadAngle;
            }
            layout_2.startAngle = actualStartAngle;
            layout_2.endAngle = actualEndAngle;
            currentAngle += dir * angle;
          }
        });
      }
    }
  });
}
var getSeriesLayoutData = makeInner();

// node_modules/echarts/lib/processor/dataFilter.js
function dataFilter(seriesType) {
  return {
    seriesType,
    reset: function(seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var name = data.getName(idx);
        for (var i3 = 0;i3 < legendModels.length; i3++) {
          if (!legendModels[i3].isSelected(name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}

// node_modules/echarts/lib/label/labelGuideHelper.js
var PI28 = Math.PI * 2;
var CMD4 = PathProxy_default.CMD;
function projectPointToLine(x1, y1, x22, y22, x3, y3, out2, limitToEnds) {
  var dx = x3 - x1;
  var dy = y3 - y1;
  var dx1 = x22 - x1;
  var dy1 = y22 - y1;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  var projectedLen = dx * dx1 + dy * dy1;
  var t4 = projectedLen / lineLen;
  if (limitToEnds) {
    t4 = Math.min(Math.max(t4, 0), 1);
  }
  t4 *= lineLen;
  var ox = out2[0] = x1 + t4 * dx1;
  var oy = out2[1] = y1 + t4 * dy1;
  return Math.sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3));
}
var pt0 = new Point_default;
var pt1 = new Point_default;
var pt2 = new Point_default;
var dir = new Point_default;
var dir2 = new Point_default;
var tmpArr = [];
var tmpProjPoint = new Point_default;
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt0, pt1);
  Point_default.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 0.001 || len2 < 0.001) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    var d3 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d3 / Math.tan(Math.PI - minTurnAngle));
    var t4 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t4)) {
      return;
    }
    if (t4 < 0) {
      Point_default.copy(tmpProjPoint, pt1);
    } else if (t4 > 1) {
      Point_default.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt1, pt0);
  Point_default.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 0.001 || len2 < 0.001) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    var d3 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle2 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point_default.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d3 / Math.tan(Math.PI / 2 - newAngle));
      var t4 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t4)) {
        return;
      }
      if (t4 < 0) {
        Point_default.copy(tmpProjPoint, pt1);
      } else if (t4 > 1) {
        Point_default.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === "normal";
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  var smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  var styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (!points2) {
    return;
  }
  path.moveTo(points2[0][0], points2[0][1]);
  if (smooth > 0 && points2.length >= 3) {
    var len1 = dist(points2[0], points2[1]);
    var len2 = dist(points2[1], points2[2]);
    if (!len1 || !len2) {
      path.lineTo(points2[1][0], points2[1][1]);
      path.lineTo(points2[2][0], points2[2][1]);
      return;
    }
    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp([], points2[1], points2[0], moveLen / len1);
    var midPoint2 = lerp([], points2[1], points2[2], moveLen / len2);
    var midPoint1 = lerp([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points2[2][0], points2[2][1]);
  } else {
    for (var i3 = 1;i3 < points2.length; i3++) {
      path.lineTo(points2[i3][0], points2[i3][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  var normalModel = statesModels.normal;
  var showNormal = normalModel.get("show");
  var labelIgnoreNormal = label.ignore;
  for (var i3 = 0;i3 < DISPLAY_STATES.length; i3++) {
    var stateName = DISPLAY_STATES[i3];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === "normal";
    if (stateModel) {
      var stateShow = stateModel.get("show");
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        if (!!labelLine) {
          setLabelLineState(labelLine, true, stateName, stateModel);
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline_default;
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    var showAbove = normalModel.get("showAbove");
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (var i3 = 0;i3 < SPECIAL_STATES.length; i3++) {
    var stateName = SPECIAL_STATES[i3];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}

// node_modules/echarts/lib/label/labelLayoutHelper.js
function prepareLayoutList(input) {
  var list = [];
  for (var i3 = 0;i3 < input.length; i3++) {
    var rawItem = input[i3];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    var label = rawItem.label;
    var transform = label.getComputedTransform();
    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform || transform[1] < 0.00001 && transform[2] < 0.00001;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect_default(localRect, transform) : null;
    list.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform
    });
  }
  return list;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a3, b) {
    return a3.rect[xyDim] - b.rect[xyDim];
  });
  var lastPos = 0;
  var delta;
  var adjusted = false;
  var shifts = [];
  var totalShifts = 0;
  for (var i3 = 0;i3 < len2; i3++) {
    var item = list[i3];
    var rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    var shift = Math.max(-delta, 0);
    shifts.push(shift);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  var first = list[0];
  var last = list[len2 - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        var remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (var i4 = start2;i4 < end2; i4++) {
      var item2 = list[i4];
      var rect2 = item2.rect;
      rect2[xyDim] += delta2;
      item2.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;
    for (var i4 = 1;i4 < len2; i4++) {
      var prevItemRect = list[i4 - 1].rect;
      var gap = Math.max(list[i4].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (var i4 = 0;i4 < len2 - 1; i4++) {
        var movement = gaps[i4] * squeezePercent;
        shiftList(movement, 0, i4 + 1);
      }
    } else {
      for (var i4 = len2 - 1;i4 > 0; i4--) {
        var movement = gaps[i4 - 1] * squeezePercent;
        shiftList(-movement, i4, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    var dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (var i4 = 0;i4 < len2 - 1; i4++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i4 + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i4 - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = [];
  labelList.sort(function(a3, b) {
    return b.priority - a3.priority;
  });
  var globalRect = new BoundingRect_default(0, 0, 0, 0);
  function hideEl(el) {
    if (!el.ignore) {
      var emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (var i3 = 0;i3 < labelList.length; i3++) {
    var labelItem = labelList[i3];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;
    for (var j3 = 0;j3 < displayedLabels.length; j3++) {
      var existsTextCfg = displayedLabels[j3];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect_default(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect_default(localRect, transform);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}

// node_modules/echarts/lib/chart/pie/labelLayout.js
var RADIAN2 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r3, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;
    for (var i4 = 0;i4 < semi.list.length; i4++) {
      var item = semi.list[i4];
      var dy = Math.abs(item.label.y - cy);
      var rA = r3 + item.len;
      var rA2 = rA * rA;
      var dx2 = Math.sqrt(Math.abs((1 - dy * dy / rB2) * rA2));
      var newX = cx + (dx2 + item.len2) * dir3;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };
    for (var i4 = 0;i4 < items.length; i4++) {
      if (items[i4].labelAlignTo !== "none") {
        continue;
      }
      var item = items[i4];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        var dx2 = item.label.x - cx - item.len2 * dir3;
        var rA = r3 + item.len;
        var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  var len2 = list.length;
  for (var i3 = 0;i3 < len2; i3++) {
    if (list[i3].position === "outer" && list[i3].labelAlignTo === "labelLine") {
      var dx = list[i3].label.x - farthestX;
      list[i3].linePoints[1][0] += dx;
      list[i3].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r3, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;
  for (var i3 = 0;i3 < labelLayoutList.length; i3++) {
    var label = labelLayoutList[i3].label;
    if (isPositionCenter(labelLayoutList[i3])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i3]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i3]);
    }
  }
  for (var i3 = 0;i3 < labelLayoutList.length; i3++) {
    var layout2 = labelLayoutList[i3];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      if (layout2.labelStyleWidth != null) {
        continue;
      }
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var targetTextWidth = undefined;
      if (layout2.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
        }
      } else if (layout2.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
        }
      }
      layout2.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout2, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r3, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r3, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (var i3 = 0;i3 < labelLayoutList.length; i3++) {
    var layout2 = labelLayoutList[i3];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var isAlignToEdge = layout2.labelAlignTo === "edge";
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0;
      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout2.rect.width + extraPaddingH;
      var dist2 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout2.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout2.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist2;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
  if (forceRecalculate === undefined) {
    forceRecalculate = false;
  }
  if (layout2.labelStyleWidth != null) {
    return;
  }
  var label = layout2.label;
  var style = label.style;
  var textRect = layout2.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow;
  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      var innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN2;
  var viewRect2 = data.getLayout("viewRect");
  var r3 = data.getLayout("r");
  var viewWidth = viewRect2.width;
  var viewLeft = viewRect2.x;
  var viewTop = viewRect2.y;
  var viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label2) {
    if (!label2.ignore) {
      return true;
    }
    for (var key in label2.states) {
      if (label2.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    var sector = data.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label2 = sector.getTextContent();
    var labelLine2 = sector.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    var labelDistance = labelModel.get("distanceToLabelLine");
    var labelAlignTo = labelModel.get("alignTo");
    var edgeDistance = parsePercent2(labelModel.get("edgeDistance"), viewWidth);
    var bleedMargin = labelModel.get("bleedMargin");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent2(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent2(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each(label2.states, setNotShow);
      label2.ignore = true;
      if (labelLine2) {
        each(labelLine2.states, setNotShow);
        labelLine2.ignore = true;
      }
      return;
    }
    if (!isLabelShown(label2)) {
      return;
    }
    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints2;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        var x22 = x1 + nx * (labelLineLen + r3 - sectorShape.r);
        var y22 = y1 + ny * (labelLineLen + r3 - sectorShape.r);
        var x3 = x22 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y22;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints2 = [[x1, y1], [x22, y22], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    var PI4 = Math.PI;
    var labelRotate = 0;
    var rotate2 = labelModel.get("rotate");
    if (isNumber(rotate2)) {
      labelRotate = rotate2 * (PI4 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      var radialAngle = nx < 0 ? -midAngle + PI4 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      var rad = Math.atan2(nx, ny);
      if (rad < 0) {
        rad = PI4 * 2 + rad;
      }
      var isDown = ny > 0;
      if (isDown) {
        rad = PI4 + rad;
      }
      labelRotate = rad - PI4;
    }
    hasLabelRotate = !!labelRotate;
    label2.x = textX;
    label2.y = textY;
    label2.rotation = labelRotate;
    label2.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      var textRect = label2.getBoundingRect().clone();
      textRect.applyTransform(label2.getComputedTransform());
      var margin = (label2.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label2,
        labelLine: labelLine2,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point_default(nx, ny),
        linePoints: linePoints2,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label2.style.width
      });
    } else {
      label2.setStyle({
        align: textAlign
      });
      var selectState2 = label2.states.select;
      if (selectState2) {
        selectState2.x += label2.x;
        selectState2.y += label2.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r3, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (var i3 = 0;i3 < labelLayoutList.length; i3++) {
    var layout2 = labelLayoutList[i3];
    var label = layout2.label;
    var labelLine = layout2.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout2.textAlign
      });
      if (notShowLabel) {
        each(label.states, setNotShow);
        label.ignore = true;
      }
      var selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      var linePoints = layout2.linePoints;
      if (notShowLabel || !linePoints) {
        each(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout2.minTurnAngle);
        limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        });
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point_default(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}

// node_modules/echarts/lib/chart/pie/PieView.js
var PiePiece = function(_super) {
  __extends(PiePiece2, _super);
  function PiePiece2(data, idx, startAngle) {
    var _this = _super.call(this) || this;
    _this.z2 = 2;
    var text = new Text_default;
    _this.setTextContent(text);
    _this.updateData(data, idx, startAngle, true);
    return _this;
  }
  PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = data.getItemLayout(idx);
    var sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout2.r0;
        initProps(sector, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({
            startAngle,
            endAngle: startAngle
          });
          initProps(sector, {
            shape: {
              startAngle: layout2.startAngle,
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout2.startAngle;
          updateProps(sector, {
            shape: {
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var offset = seriesModel.get("selectedOffset");
    var dx = Math.cos(midAngle) * offset;
    var dy = Math.sin(midAngle) * offset;
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector.ensureState("emphasis").shape = extend({
      r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
    extend(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
    });
    extend(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && extend(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
    var sector = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel("labelLine");
    var style = data.getItemVisual(idx, "style");
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    var labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline_default;
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  };
  return PiePiece2;
}(Sector_default);
var PieView = function(_super) {
  __extends(PieView2, _super);
  function PieView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle;
    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);
      for (var s3 = 1;isNaN(shape && shape.startAngle) && s3 < data.count(); ++s3) {
        shape = data.getItemLayout(s3);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      var layoutData = getSeriesLayoutData(seriesModel);
      var sector = new Sector_default({
        shape: extend(getBasicPieLayout(seriesModel, api), layoutData)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data.diff(oldData).add(function(idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  };
  PieView2.prototype.dispose = function() {};
  PieView2.prototype.containPoint = function(point, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  PieView2.type = "pie";
  return PieView2;
}(Chart_default);
var PieView_default = PieView;

// node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray(opt) && {
    coordDimensions: opt
  } || extend({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
  var list = new SeriesData_default(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}

// node_modules/echarts/lib/visual/LegendVisualProvider.js
var LegendVisualProvider = function() {
  function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  LegendVisualProvider2.prototype.getAllNames = function() {
    var rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  };
  LegendVisualProvider2.prototype.containName = function(name) {
    var rawData = this._getRawData();
    return rawData.indexOfName(name) >= 0;
  };
  LegendVisualProvider2.prototype.indexOfName = function(name) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name);
  };
  LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };
  return LegendVisualProvider2;
}();
var LegendVisualProvider_default = LegendVisualProvider;

// node_modules/echarts/lib/chart/pie/PieSeries.js
var innerData = makeInner();
var PieSeriesModel = function(_super) {
  __extends(PieSeriesModel2, _super);
  function PieSeriesModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  PieSeriesModel2.prototype.mergeOption = function() {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  PieSeriesModel2.prototype.getInitialData = function() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
  };
  PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data = this.getData();
    var dataInner = innerData(data);
    var seats = dataInner.seats;
    if (!seats) {
      var valueList_1 = [];
      data.each(data.mapDimension("value"), function(value2) {
        valueList_1.push(value2);
      });
      seats = dataInner.seats = getPercentSeats(valueList_1, data.hostModel.get("percentPrecision"));
    }
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    params.percent = seats[dataIndex] || 0;
    params.$vars.push("percent");
    return params;
  };
  PieSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  PieSeriesModel2.type = "series.pie";
  PieSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    endAngle: "auto",
    padAngle: 0,
    minAngle: 0,
    minShowLabelAngle: 0,
    selectedOffset: 10,
    percentPrecision: 2,
    stillShowZeroSum: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      rotate: 0,
      show: true,
      overflow: "truncate",
      position: "outer",
      alignTo: "none",
      edgeDistance: "25%",
      bleedMargin: 10,
      distanceToLabelLine: 5
    },
    labelLine: {
      show: true,
      length: 15,
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: "round"
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: "lightgray",
      opacity: 1
    },
    labelLayout: {
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    avoidLabelOverlap: true,
    animationType: "expansion",
    animationDuration: 1000,
    animationTypeUpdate: "transition",
    animationEasingUpdate: "cubicInOut",
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut"
  };
  return PieSeriesModel2;
}(Series_default);
var PieSeries_default = PieSeriesModel;

// node_modules/echarts/lib/processor/negativeDataFilter.js
function negativeDataFilter(seriesType) {
  return {
    seriesType,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var valueDim = data.mapDimension("value");
        var curValue = data.get(valueDim, idx);
        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}

// node_modules/echarts/lib/chart/pie/install.js
function install3(registers) {
  registers.registerChartView(PieView_default);
  registers.registerSeriesModel(PieSeries_default);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry(pieLayout, "pie"));
  registers.registerProcessor(dataFilter("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}
// node_modules/zrender/lib/mixin/Draggable.js
var Param = function() {
  function Param2(target, e4) {
    this.target = target;
    this.topTarget = e4 && e4.topTarget;
  }
  return Param2;
}();
var Draggable = function() {
  function Draggable2(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  Draggable2.prototype._dragStart = function(e4) {
    var draggingTarget = e4.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e4.offsetX;
      this._y = e4.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e4), "dragstart", e4.event);
    }
  };
  Draggable2.prototype._drag = function(e4) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x3 = e4.offsetX;
      var y3 = e4.offsetY;
      var dx = x3 - this._x;
      var dy = y3 - this._y;
      this._x = x3;
      this._y = y3;
      draggingTarget.drift(dx, dy, e4);
      this.handler.dispatchToElement(new Param(draggingTarget, e4), "drag", e4.event);
      var dropTarget = this.handler.findHover(x3, y3, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e4), "dragleave", e4.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e4), "dragenter", e4.event);
        }
      }
    }
  };
  Draggable2.prototype._dragEnd = function(e4) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e4), "dragend", e4.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e4), "drop", e4.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  };
  return Draggable2;
}();
var Draggable_default = Draggable;

// node_modules/zrender/lib/core/event.js
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut2 = [];
var firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
function clientToLocal(el, e4, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e4, out2);
  } else if (firefoxNotSupportOffsetXY && e4.layerX != null && e4.layerX !== e4.offsetX) {
    out2.zrX = e4.layerX;
    out2.zrY = e4.layerY;
  } else if (e4.offsetX != null) {
    out2.zrX = e4.offsetX;
    out2.zrY = e4.offsetY;
  } else {
    calculateZrXY(el, e4, out2);
  }
  return out2;
}
function calculateZrXY(el, e4, out2) {
  if (env_default.domSupported && el.getBoundingClientRect) {
    var ex = e4.clientX;
    var ey = e4.clientY;
    if (isCanvasEl(el)) {
      var box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut2, el, ex, ey)) {
        out2.zrX = _calcOut2[0];
        out2.zrY = _calcOut2[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e4) {
  return e4 || window.event;
}
function normalizeEvent(el, e4, calculate) {
  e4 = getNativeEvent(e4);
  if (e4.zrX != null) {
    return e4;
  }
  var eventType = e4.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e4, e4, calculate);
    var wheelDelta = getWheelDeltaMayPolyfill(e4);
    e4.zrDelta = wheelDelta ? wheelDelta / 120 : -(e4.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e4.targetTouches[0] : e4.changedTouches[0];
    touch && clientToLocal(el, touch, e4, calculate);
  }
  var button = e4.button;
  if (e4.which == null && button !== undefined && MOUSE_EVENT_REG.test(e4.type)) {
    e4.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e4;
}
function getWheelDeltaMayPolyfill(e4) {
  var rawWheelDelta = e4.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  var deltaX = e4.deltaX;
  var deltaY = e4.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign;
}
function addEventListener2(el, name, handler, opt) {
  el.addEventListener(name, handler, opt);
}
function removeEventListener2(el, name, handler, opt) {
  el.removeEventListener(name, handler, opt);
}
var stop = function(e4) {
  e4.preventDefault();
  e4.stopPropagation();
  e4.cancelBubble = true;
};

// node_modules/zrender/lib/core/GestureMgr.js
var GestureMgr = function() {
  function GestureMgr2() {
    this._track = [];
  }
  GestureMgr2.prototype.recognize = function(event, target, root) {
    this._doTrack(event, target, root);
    return this._recognize(event);
  };
  GestureMgr2.prototype.clear = function() {
    this._track.length = 0;
    return this;
  };
  GestureMgr2.prototype._doTrack = function(event, target, root) {
    var touches = event.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (var i3 = 0, len2 = touches.length;i3 < len2; i3++) {
      var touch = touches[i3];
      var pos = clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  };
  GestureMgr2.prototype._recognize = function(event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  };
  return GestureMgr2;
}();
function dist2(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    var trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (tracks[trackLen - 1] || {}).points;
    var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist2(pinchEnd) / dist2(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};

// node_modules/zrender/lib/Handler.js
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_super) {
  __extends2(EmptyProxy2, _super);
  function EmptyProxy2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.handler = null;
    return _this;
  }
  EmptyProxy2.prototype.dispose = function() {};
  EmptyProxy2.prototype.setCursor = function() {};
  return EmptyProxy2;
}(Eventful_default);
var HoveredResult = function() {
  function HoveredResult2(x3, y3) {
    this.x = x3;
    this.y = y3;
  }
  return HoveredResult2;
}();
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
var Handler = function(_super) {
  __extends2(Handler2, _super);
  function Handler2(storage, painter, proxy, painterRoot, pointerSize) {
    var _this = _super.call(this) || this;
    _this._hovered = new HoveredResult(0, 0);
    _this.storage = storage;
    _this.painter = painter;
    _this.painterRoot = painterRoot;
    _this._pointerSize = pointerSize;
    proxy = proxy || new EmptyProxy;
    _this.proxy = null;
    _this.setHandlerProxy(proxy);
    _this._draggingMgr = new Draggable_default(_this);
    return _this;
  }
  Handler2.prototype.setHandlerProxy = function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each(handlerNames, function(name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  };
  Handler2.prototype.mousemove = function(event) {
    var x3 = event.zrX;
    var y3 = event.zrY;
    var isOutside = isOutsideBoundary(this, x3, y3);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? new HoveredResult(x3, y3) : this.findHover(x3, y3);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  };
  Handler2.prototype.mouseout = function(event) {
    var eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", { type: "globalout", event });
    }
  };
  Handler2.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  };
  Handler2.prototype.dispatch = function(eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  };
  Handler2.prototype.dispose = function() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  };
  Handler2.prototype.setCursorStyle = function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  };
  Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    var eventKey = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  };
  Handler2.prototype.findHover = function(x3, y3, exclude) {
    var list = this.storage.getDisplayList();
    var out2 = new HoveredResult(x3, y3);
    setHoverTarget(list, out2, x3, y3, exclude);
    if (this._pointerSize && !out2.target) {
      var candidates = [];
      var pointerSize = this._pointerSize;
      var targetSizeHalf = pointerSize / 2;
      var pointerRect = new BoundingRect_default(x3 - targetSizeHalf, y3 - targetSizeHalf, pointerSize, pointerSize);
      for (var i3 = list.length - 1;i3 >= 0; i3--) {
        var el = list[i3];
        if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
          tmpRect2.copy(el.getBoundingRect());
          if (el.transform) {
            tmpRect2.applyTransform(el.transform);
          }
          if (tmpRect2.intersect(pointerRect)) {
            candidates.push(el);
          }
        }
      }
      if (candidates.length) {
        var rStep = 4;
        var thetaStep = Math.PI / 12;
        var PI29 = Math.PI * 2;
        for (var r3 = 0;r3 < targetSizeHalf; r3 += rStep) {
          for (var theta = 0;theta < PI29; theta += thetaStep) {
            var x1 = x3 + r3 * Math.cos(theta);
            var y1 = y3 + r3 * Math.sin(theta);
            setHoverTarget(candidates, out2, x1, y1, exclude);
            if (out2.target) {
              return out2;
            }
          }
        }
      }
    }
    return out2;
  };
  Handler2.prototype.processGesture = function(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr;
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      var res = new HoveredResult;
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  };
  return Handler2;
}(Eventful_default);
each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
  Handler.prototype[name] = function(event) {
    var x3 = event.zrX;
    var y3 = event.zrY;
    var isOutside = isOutsideBoundary(this, x3, y3);
    var hovered;
    var hoveredTarget;
    if (name !== "mouseup" || !isOutside) {
      hovered = this.findHover(x3, y3);
      hoveredTarget = hovered.target;
    }
    if (name === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name, event);
  };
});
function isHover(displayable, x3, y3) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x3, y3)) {
    var el = displayable;
    var isSilent = undefined;
    var ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        var clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x3, y3)) {
          return false;
        }
      }
      if (el.silent) {
        isSilent = true;
      }
      var hostEl = el.__hostTarget;
      el = hostEl ? hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function setHoverTarget(list, out2, x3, y3, exclude) {
  for (var i3 = list.length - 1;i3 >= 0; i3--) {
    var el = list[i3];
    var hoverCheckResult = undefined;
    if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x3, y3))) {
      !out2.topTarget && (out2.topTarget = el);
      if (hoverCheckResult !== SILENT) {
        out2.target = el;
        break;
      }
    }
  }
}
function isOutsideBoundary(handlerInstance, x3, y3) {
  var painter = handlerInstance.painter;
  return x3 < 0 || x3 > painter.getWidth() || y3 < 0 || y3 > painter.getHeight();
}
var Handler_default = Handler;

// node_modules/zrender/lib/core/timsort.js
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n3) {
  var r3 = 0;
  while (n3 >= DEFAULT_MIN_MERGE) {
    r3 |= n3 & 1;
    n3 >>= 1;
  }
  return n3 + r3;
}
function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t4 = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t4;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare) {
  if (start2 === lo) {
    start2++;
  }
  for (;start2 < hi; start2++) {
    var pivot = array[start2];
    var left = lo;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n3 = start2 - left;
    switch (n3) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n3 > 0) {
          array[left + n3] = array[left + n3 - 1];
          n3--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value2, array, start2, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare(value2, array[start2 + hint]) > 0) {
    maxOffset = length - hint;
    while (offset < maxOffset && compare(value2, array[start2 + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare(value2, array[start2 + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m5 = lastOffset + (offset - lastOffset >>> 1);
    if (compare(value2, array[start2 + m5]) > 0) {
      lastOffset = m5 + 1;
    } else {
      offset = m5;
    }
  }
  return offset;
}
function gallopRight(value2, array, start2, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare(value2, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare(value2, array[start2 + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;
    while (offset < maxOffset && compare(value2, array[start2 + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m5 = lastOffset + (offset - lastOffset >>> 1);
    if (compare(value2, array[start2 + m5]) < 0) {
      offset = m5;
    } else {
      lastOffset = m5 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n3 = stackSize - 2;
      if (n3 >= 1 && runLength[n3 - 1] <= runLength[n3] + runLength[n3 + 1] || n3 >= 2 && runLength[n3 - 2] <= runLength[n3] + runLength[n3 - 1]) {
        if (runLength[n3 - 1] < runLength[n3 + 1]) {
          n3--;
        }
      } else if (runLength[n3] > runLength[n3 + 1]) {
        break;
      }
      mergeAt(n3);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n3 = stackSize - 2;
      if (n3 > 0 && runLength[n3 - 1] < runLength[n3 + 1]) {
        n3--;
      }
      mergeAt(n3);
    }
  }
  function mergeAt(i3) {
    var start1 = runStart[i3];
    var length1 = runLength[i3];
    var start2 = runStart[i3 + 1];
    var length2 = runLength[i3 + 1];
    runLength[i3] = length1 + length2;
    if (i3 === stackSize - 3) {
      runStart[i3 + 1] = runStart[i3 + 2];
      runLength[i3 + 1] = runLength[i3 + 2];
    }
    stackSize--;
    var k3 = gallopRight(array[start2], array, start1, length1, 0, compare);
    start1 += k3;
    length1 -= k3;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i3 = 0;
    for (i3 = 0;i3 < length1; i3++) {
      tmp[i3] = array[start1 + i3];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i3 = 0;i3 < length1; i3++) {
        array[dest + i3] = tmp[cursor1 + i3];
      }
      return;
    }
    if (length1 === 1) {
      for (i3 = 0;i3 < length2; i3++) {
        array[dest + i3] = array[cursor2 + i3];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (true) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
        if (count1 !== 0) {
          for (i3 = 0;i3 < count1; i3++) {
            array[dest + i3] = tmp[cursor1 + i3];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
        if (count2 !== 0) {
          for (i3 = 0;i3 < count2; i3++) {
            array[dest + i3] = array[cursor2 + i3];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i3 = 0;i3 < length2; i3++) {
        array[dest + i3] = array[cursor2 + i3];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error;
    } else {
      for (i3 = 0;i3 < length1; i3++) {
        array[dest + i3] = tmp[cursor1 + i3];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i3 = 0;
    for (i3 = 0;i3 < length2; i3++) {
      tmp[i3] = array[start2 + i3];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i3 = 0;i3 < length2; i3++) {
        array[customCursor + i3] = tmp[i3];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i3 = length1 - 1;i3 >= 0; i3--) {
        array[customDest + i3] = array[customCursor + i3];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i3 = count1 - 1;i3 >= 0; i3--) {
            array[customDest + i3] = array[customCursor + i3];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i3 = 0;i3 < count2; i3++) {
            array[customDest + i3] = tmp[customCursor + i3];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i3 = length1 - 1;i3 >= 0; i3--) {
        array[customDest + i3] = array[customCursor + i3];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error;
    } else {
      customCursor = dest - (length2 - 1);
      for (i3 = 0;i3 < length2; i3++) {
        array[customCursor + i3] = tmp[i3];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort(array, compare, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }
  var ts = TimSort(array, compare);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}

// node_modules/zrender/lib/Storage.js
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a3, b) {
  if (a3.zlevel === b.zlevel) {
    if (a3.z === b.z) {
      return a3.z2 - b.z2;
    }
    return a3.z - b.z;
  }
  return a3.zlevel - b.zlevel;
}
var Storage = function() {
  function Storage2() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  Storage2.prototype.traverse = function(cb, context) {
    for (var i3 = 0;i3 < this._roots.length; i3++) {
      this._roots[i3].traverse(cb, context);
    }
  };
  Storage2.prototype.getDisplayList = function(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    var displayList = this._displayList;
    if (update || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  };
  Storage2.prototype.updateDisplayList = function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i3 = 0, len2 = roots2.length;i3 < len2; i3++) {
      this._updateAndAddDisplayable(roots2[i3], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort(displayList, shapeCompareFunc);
  };
  Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    var userSetClipPath = el.getClipPath();
    if (el.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el.childrenRef) {
      var children = el.childrenRef();
      for (var i3 = 0;i3 < children.length; i3++) {
        var child = children[i3];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      var disp = el;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    var decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    var textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    var textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  };
  Storage2.prototype.addRoot = function(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  };
  Storage2.prototype.delRoot = function(el) {
    if (el instanceof Array) {
      for (var i3 = 0, l3 = el.length;i3 < l3; i3++) {
        this.delRoot(el[i3]);
      }
      return;
    }
    var idx = indexOf(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  };
  Storage2.prototype.delAllRoots = function() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  };
  Storage2.prototype.getRoots = function() {
    return this._roots;
  };
  Storage2.prototype.dispose = function() {
    this._displayList = null;
    this._roots = null;
  };
  return Storage2;
}();
var Storage_default = Storage;

// node_modules/zrender/lib/animation/requestAnimationFrame.js
var requestAnimationFrame2;
requestAnimationFrame2 = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame_default = requestAnimationFrame2;

// node_modules/zrender/lib/animation/Animation.js
function getTime() {
  return new Date().getTime();
}
var Animation = function(_super) {
  __extends2(Animation2, _super);
  function Animation2(opts) {
    var _this = _super.call(this) || this;
    _this._running = false;
    _this._time = 0;
    _this._pausedTime = 0;
    _this._pauseStart = 0;
    _this._paused = false;
    opts = opts || {};
    _this.stage = opts.stage || {};
    return _this;
  }
  Animation2.prototype.addClip = function(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  };
  Animation2.prototype.addAnimator = function(animator) {
    animator.animation = this;
    var clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  };
  Animation2.prototype.removeClip = function(clip2) {
    if (!clip2.animation) {
      return;
    }
    var prev = clip2.prev;
    var next = clip2.next;
    if (prev) {
      prev.next = next;
    } else {
      this._head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  };
  Animation2.prototype.removeAnimator = function(animator) {
    var clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  };
  Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
    var time = getTime() - this._pausedTime;
    var delta = time - this._time;
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      var finished = clip2.step(time, delta);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  };
  Animation2.prototype._startLoop = function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame_default(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame_default(step);
  };
  Animation2.prototype.start = function() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  };
  Animation2.prototype.stop = function() {
    this._running = false;
  };
  Animation2.prototype.pause = function() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  };
  Animation2.prototype.resume = function() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  };
  Animation2.prototype.clear = function() {
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  };
  Animation2.prototype.isFinished = function() {
    return this._head == null;
  };
  Animation2.prototype.animate = function(target, options) {
    options = options || {};
    this.start();
    var animator = new Animator_default(target, options.loop);
    this.addAnimator(animator);
    return animator;
  };
  return Animation2;
}(Eventful_default);
var Animation_default = Animation;

// node_modules/zrender/lib/dom/HandlerProxy.js
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env_default.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = map(mouseHandlerNames, function(name) {
    var nm = name.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
  var elTmp = el;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = function() {
  function FakeGlobalEvent2(instance, event) {
    this.stopPropagation = noop;
    this.stopImmediatePropagation = noop;
    this.preventDefault = noop;
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
  return FakeGlobalEvent2;
}();
var localDOMHandlers = {
  mousedown: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove: function(event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout: function(event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel: function(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel: function(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date;
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each(["click", "dblclick", "contextmenu"], function(name) {
  localDOMHandlers[name] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    var pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  var domHandlers = scope.domHandlers;
  if (env_default.pointerEventsSupported) {
    each(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance, event);
      });
    });
  } else {
    if (env_default.touchEventsSupported) {
      each(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      });
    }
    each(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env_default.pointerEventsSupported) {
    each(globalNativeListenerNames.pointer, mount);
  } else if (!env_default.touchEventsSupported) {
    each(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener2(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;
  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener2(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = function() {
  function DOMHandlerScope2(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
  return DOMHandlerScope2;
}();
var HandlerDomProxy = function(_super) {
  __extends2(HandlerDomProxy2, _super);
  function HandlerDomProxy2(dom, painterRoot) {
    var _this = _super.call(this) || this;
    _this.__pointerCapturing = false;
    _this.dom = dom;
    _this.painterRoot = painterRoot;
    _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(_this, _this._localHandlerScope);
    return _this;
  }
  HandlerDomProxy2.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };
  HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  };
  HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      var globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  };
  return HandlerDomProxy2;
}(Eventful_default);
var HandlerProxy_default = HandlerDomProxy;

// node_modules/zrender/lib/zrender.js
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances = {};
function delInstance(id) {
  delete instances[id];
}
function isDarkMode(backgroundColor) {
  if (!backgroundColor) {
    return false;
  }
  if (typeof backgroundColor === "string") {
    return lum(backgroundColor, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor.colorStops) {
    var colorStops = backgroundColor.colorStops;
    var totalLum = 0;
    var len2 = colorStops.length;
    for (var i3 = 0;i3 < len2; i3++) {
      totalLum += lum(colorStops[i3].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = function() {
  function ZRender2(id, dom, opts) {
    var _this = this;
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    var storage = new Storage_default;
    var rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys(painterCtors)[0];
    }
    if (true) {
      if (!painterCtors[rendererType]) {
        throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
      }
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    var painter = new painterCtors[rendererType](dom, storage, opts, id);
    var ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage;
    this.painter = painter;
    var handlerProxy = !env_default.node && !env_default.worker && !ssrMode ? new HandlerProxy_default(painter.getViewportRoot(), painter.root) : null;
    var useCoarsePointer = opts.useCoarsePointer;
    var usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env_default.touchEventsSupported : !!useCoarsePointer;
    var defaultPointerSize = 44;
    var pointerSize;
    if (usePointerSize) {
      pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
    }
    this.handler = new Handler_default(storage, painter, handlerProxy, painter.root, pointerSize);
    this.animation = new Animation_default({
      stage: {
        update: ssrMode ? null : function() {
          return _this._flush(true);
        }
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  ZRender2.prototype.add = function(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  };
  ZRender2.prototype.remove = function(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  };
  ZRender2.prototype.configLayer = function(zLevel, config) {
    if (this._disposed) {
      return;
    }
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  };
  ZRender2.prototype.setBackgroundColor = function(backgroundColor) {
    if (this._disposed) {
      return;
    }
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor);
    }
    this.refresh();
    this._backgroundColor = backgroundColor;
    this._darkMode = isDarkMode(backgroundColor);
  };
  ZRender2.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  };
  ZRender2.prototype.setDarkMode = function(darkMode) {
    this._darkMode = darkMode;
  };
  ZRender2.prototype.isDarkMode = function() {
    return this._darkMode;
  };
  ZRender2.prototype.refreshImmediately = function(fromInside) {
    if (this._disposed) {
      return;
    }
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  };
  ZRender2.prototype.refresh = function() {
    if (this._disposed) {
      return;
    }
    this._needsRefresh = true;
    this.animation.start();
  };
  ZRender2.prototype.flush = function() {
    if (this._disposed) {
      return;
    }
    this._flush(false);
  };
  ZRender2.prototype._flush = function(fromInside) {
    var triggerRendered;
    var start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    var end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  };
  ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  };
  ZRender2.prototype.wakeUp = function() {
    if (this._disposed) {
      return;
    }
    this.animation.start();
    this._stillFrameAccum = 0;
  };
  ZRender2.prototype.refreshHover = function() {
    this._needsRefreshHover = true;
  };
  ZRender2.prototype.refreshHoverImmediately = function() {
    if (this._disposed) {
      return;
    }
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  };
  ZRender2.prototype.resize = function(opts) {
    if (this._disposed) {
      return;
    }
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  };
  ZRender2.prototype.clearAnimation = function() {
    if (this._disposed) {
      return;
    }
    this.animation.clear();
  };
  ZRender2.prototype.getWidth = function() {
    if (this._disposed) {
      return;
    }
    return this.painter.getWidth();
  };
  ZRender2.prototype.getHeight = function() {
    if (this._disposed) {
      return;
    }
    return this.painter.getHeight();
  };
  ZRender2.prototype.setCursorStyle = function(cursorStyle) {
    if (this._disposed) {
      return;
    }
    this.handler.setCursorStyle(cursorStyle);
  };
  ZRender2.prototype.findHover = function(x3, y3) {
    if (this._disposed) {
      return;
    }
    return this.handler.findHover(x3, y3);
  };
  ZRender2.prototype.on = function(eventName, eventHandler, context) {
    if (!this._disposed) {
      this.handler.on(eventName, eventHandler, context);
    }
    return this;
  };
  ZRender2.prototype.off = function(eventName, eventHandler) {
    if (this._disposed) {
      return;
    }
    this.handler.off(eventName, eventHandler);
  };
  ZRender2.prototype.trigger = function(eventName, event) {
    if (this._disposed) {
      return;
    }
    this.handler.trigger(eventName, event);
  };
  ZRender2.prototype.clear = function() {
    if (this._disposed) {
      return;
    }
    var roots2 = this.storage.getRoots();
    for (var i3 = 0;i3 < roots2.length; i3++) {
      if (roots2[i3] instanceof Group_default) {
        roots2[i3].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  };
  ZRender2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    this._disposed = true;
    delInstance(this.id);
  };
  return ZRender2;
}();
function init(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}
var ssrDataGetter;
function registerSSRDataGetter(getter) {
  ssrDataGetter = getter;
}

// node_modules/echarts/lib/model/globalDefault.js
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault_default = {
  darkMode: "auto",
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1000,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2000,
  progressiveThreshold: 3000,
  progressive: 400,
  hoverLayerThreshold: 3000,
  useUTC: false
};

// node_modules/echarts/lib/model/internalComponentCreator.js
var internalOptionCreatorMap = createHashMap();
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  var internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  if (true) {
    for (var i3 = 0;i3 < internalOptions.length; i3++) {
      assert(isComponentIdInternal(internalOptions[i3]));
    }
  }
  return newCmptOptionList.concat(internalOptions);
}

// node_modules/echarts/lib/model/Global.js
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\x00_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
  each(option, function(componentOption, mainType) {
    if (!Component_default.hasClass(mainType)) {
      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
        error("Component " + mainType + ` is used but not imported.
import { ` + componentImportName + ` } from 'echarts/components';
echarts.use([` + componentImportName + "]);");
        componetsMissingLogPrinted[componentImportName] = true;
      }
    }
  });
}
var GlobalModel = function(_super) {
  __extends(GlobalModel2, _super);
  function GlobalModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme, locale, optionManager) {
    theme = theme || {};
    this.option = null;
    this._theme = new Model_default(theme);
    this._locale = new Model_default(locale);
    this._optionManager = optionManager;
  };
  GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs) {
    if (true) {
      assert(option != null, "option is null/undefined");
      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
    }
    var innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);
    this._resetOption(null, innerOpt);
  };
  GlobalModel2.prototype.resetOption = function(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  };
  GlobalModel2.prototype._resetOption = function(type, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type || type === "recreate") {
      var baseOption = optionManager.mountOption(type === "recreate");
      if (true) {
        checkMissingComponents(baseOption);
      }
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      var mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  };
  GlobalModel2.prototype.mergeOption = function(option) {
    this._mergeOption(option, null);
  };
  GlobalModel2.prototype._mergeOption = function(newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!Component_default.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (Component_default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    Component_default.topologicalTravel(newCmptTypes, Component_default.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, Component_default);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      var tooltipWarningLogged;
      each(mappingResult, function(resultItem, index) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          var isSeriesType = mainType === "series";
          var ComponentModelClass = Component_default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
          if (!ComponentModelClass) {
            if (true) {
              var subType = resultItem.keyInfo.subType;
              var seriesImportName = BUILTIN_CHARTS_MAP[subType];
              if (!componetsMissingLogPrinted[subType]) {
                componetsMissingLogPrinted[subType] = true;
                if (seriesImportName) {
                  error("Series " + subType + ` is used but not imported.
import { ` + seriesImportName + ` } from 'echarts/charts';
echarts.use([` + seriesImportName + "]);");
                } else {
                  error("Unknown series " + subType);
                }
              }
            }
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              if (true) {
                if (!tooltipWarningLogged) {
                  warn("Currently only one tooltip component is allowed.");
                  tooltipWarningLogged = true;
                }
              }
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            var extraOpt = extend({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(undefined);
          cmptsByMainType.push(undefined);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  GlobalModel2.prototype.getOption = function() {
    var option = clone(this.option);
    each(option, function(optInMainType, mainType) {
      if (Component_default.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType);
        var realLen = opts.length;
        var metNonInner = false;
        for (var i3 = realLen - 1;i3 >= 0; i3--) {
          if (opts[i3] && !isComponentIdInternal(opts[i3])) {
            metNonInner = true;
          } else {
            opts[i3] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };
  GlobalModel2.prototype.getTheme = function() {
    return this._theme;
  };
  GlobalModel2.prototype.getLocaleModel = function() {
    return this._locale;
  };
  GlobalModel2.prototype.setUpdatePayload = function(payload) {
    this._payload = payload;
  };
  GlobalModel2.prototype.getUpdatePayload = function() {
    return this._payload;
  };
  GlobalModel2.prototype.getComponent = function(mainType, idx) {
    var list = this._componentsMap.get(mainType);
    if (list) {
      var cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i3 = 0;i3 < list.length; i3++) {
          if (list[i3]) {
            return list[i3];
          }
        }
      }
    }
  };
  GlobalModel2.prototype.queryComponents = function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index = condition.index;
    var id = condition.id;
    var name = condition.name;
    var cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    var result;
    if (index != null) {
      result = [];
      each(normalizeToArray(index), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName("name", name, cmpts);
    } else {
      result = filter(cmpts, function(cmpt) {
        return !!cmpt;
      });
    }
    return filterBySubType(result, condition);
  };
  GlobalModel2.prototype.findComponents = function(condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q2) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q2 && (q2[indexAttr] != null || q2[idAttr] != null || q2[nameAttr] != null) ? {
        mainType,
        index: q2[indexAttr],
        id: q2[idAttr],
        name: q2[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  };
  GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (isFunction(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function(cmpts2, componentType) {
        for (var i4 = 0;cmpts2 && i4 < cmpts2.length; i4++) {
          var cmpt2 = cmpts2[i4];
          cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
        }
      });
    } else {
      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject2(mainType) ? this.findComponents(mainType) : null;
      for (var i3 = 0;cmpts && i3 < cmpts.length; i3++) {
        var cmpt = cmpts[i3];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  GlobalModel2.prototype.getSeriesByName = function(name) {
    var nameStr = convertOptionIdName(name, null);
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  };
  GlobalModel2.prototype.getSeriesByType = function(subType) {
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  GlobalModel2.prototype.getSeries = function() {
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries;
    });
  };
  GlobalModel2.prototype.getSeriesCount = function() {
    return this._componentsCount.get("series");
  };
  GlobalModel2.prototype.eachSeries = function(cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  GlobalModel2.prototype.eachRawSeries = function(cb, context) {
    each(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  };
  GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };
  GlobalModel2.prototype.getCurrentSeriesIndices = function() {
    return (this._seriesIndices || []).slice();
  };
  GlobalModel2.prototype.filterSeries = function(cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each(this._seriesIndices, function(seriesRawIdx) {
      var series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };
  GlobalModel2.prototype.restoreData = function(payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (Component_default.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    Component_default.topologicalTravel(componentTypes, Component_default.getAllClassMainTypes(), function(componentType) {
      each(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };
  GlobalModel2.internalField = function() {
    reCreateSeriesIndices = function(ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each(ecModel._componentsMap.get("series"), function(series) {
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };
    assertSeriesInitialized = function(ecModel) {
      if (true) {
        if (!ecModel._seriesIndices) {
          throw new Error("Option should contains series.");
        }
      }
    };
    initBase = function(ecModel, baseOption) {
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap();
      var airaOption = baseOption.aria;
      if (isObject2(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }
      mergeTheme(baseOption, ecModel._theme.option);
      merge(baseOption, globalDefault_default, false);
      ecModel._mergeOption(baseOption, null);
    };
  }();
  return GlobalModel2;
}(Model_default);
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index = payload.seriesIndex;
    var id = payload.seriesId;
    var name_1 = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
  }
}
function mergeTheme(option, theme) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each(theme, function(themeItem, name) {
    if (name === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!Component_default.hasClass(name)) {
      if (typeof themeItem === "object") {
        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr, idOrName, cmpts) {
  if (isArray(idOrName)) {
    var keyMap_1 = createHashMap();
    each(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter(cmpts, function(cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter(cmpts, function(cmpt) {
      return cmpt && idName_1 != null && cmpt[attr] === idName_1;
    });
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components;
}
function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
    if (true) {
      assert(Component_default.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
    }
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin2(GlobalModel, PaletteMixin);
var Global_default = GlobalModel;

// node_modules/echarts/lib/core/ExtensionAPI.js
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = function() {
  function ExtensionAPI2(ecInstance) {
    each(availableMethods, function(methodName) {
      this[methodName] = bind(ecInstance[methodName], ecInstance);
    }, this);
  }
  return ExtensionAPI2;
}();
var ExtensionAPI_default = ExtensionAPI;

// node_modules/echarts/lib/model/OptionManager.js
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = function() {
  function OptionManager2(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api;
  }
  OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs, opt) {
    if (rawOption) {
      each(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone(rawOption);
    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };
  OptionManager2.prototype.mountOption = function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  };
  OptionManager2.prototype.getTimelineOption = function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }
    return option;
  };
  OptionManager2.prototype.getMediaOption = function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i3 = 0, len2 = mediaList.length;i3 < len2; i3++) {
      if (applyMediaQuery(mediaList[i3].query, ecWidth, ecHeight)) {
        indices.push(i3);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function(index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  };
  return OptionManager2;
}();
function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption;
  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray(mediaOnRoot)) {
      each(mediaOnRoot, function(singleMedia) {
        if (true) {
          if (singleMedia && !singleMedia.option && isObject2(singleMedia.query) && isObject2(singleMedia.query.option)) {
            error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
          }
        }
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    } else {
      if (true) {
        error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
      }
    }
  }
  doPreprocess(baseOption);
  each(timelineOptionsOnRoot, function(option) {
    return doPreprocess(option);
  });
  each(mediaList, function(media) {
    return doPreprocess(media.option);
  });
  function doPreprocess(option) {
    each(optionPreprocessorFuncs, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  var applicable = true;
  each(query, function(value2, attr) {
    var matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value2, operator)) {
      applicable = false;
    }
  });
  return applicable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager_default = OptionManager;

// node_modules/echarts/lib/preprocessor/helper/compatStyle.js
var each3 = each;
var isObject4 = isObject2;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i3 = 0, len2 = POSSIBLE_STYLES.length;i3 < len2; i3++) {
    var styleName = POSSIBLE_STYLES[i3];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (true) {
        deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
      }
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      if (true) {
        deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
      }
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject4(opt) && opt[propName];
  var textStyle = isObject4(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    if (true) {
      deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
    }
    for (var i3 = 0, len2 = TEXT_STYLE_OPTIONS.length;i3 < len2; i3++) {
      var textPropName = TEXT_STYLE_OPTIONS[i3];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject4(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  var markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  var markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  var data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (var i3 = 0;i3 < edgeData.length; i3++) {
        compatEC3CommonStyles(edgeData[i3]);
      }
    }
    each(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray(data)) {
    for (var i3 = 0;i3 < data.length; i3++) {
      compatEC3CommonStyles(data[i3]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;
    for (var i3 = 0;i3 < mpData.length; i3++) {
      compatEC3CommonStyles(mpData[i3]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    var mlData = markLine.data;
    for (var i3 = 0;i3 < mlData.length; i3++) {
      if (isArray(mlData[i3])) {
        compatEC3CommonStyles(mlData[i3][0]);
        compatEC3CommonStyles(mlData[i3][1]);
      } else {
        compatEC3CommonStyles(mlData[i3]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o3) {
  return isArray(o3) ? o3 : o3 ? [o3] : [];
}
function toObj(o3) {
  return (isArray(o3) ? o3[0] : o3) || {};
}
function globalCompatStyle(option, isTheme) {
  each3(toArr(option.series), function(seriesOpt) {
    isObject4(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each3(axes, function(axisName) {
    each3(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each3(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each3(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each3(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
      if (true) {
        deprecateLog("name property in radar component has been changed to axisName");
      }
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
      if (true) {
        deprecateLog("nameGap property in radar component has been changed to axisNameGap");
      }
    }
    if (true) {
      each3(radarOpt.indicator, function(indicatorOpt) {
        if (indicatorOpt.text) {
          deprecateReplaceLog("text", "name", "radar.indicator");
        }
      });
    }
  });
  each3(toArr(option.geo), function(geoOpt) {
    if (isObject4(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each3(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each3(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    var data = timelineOpt.data;
    isArray(data) && each(data, function(item) {
      if (isObject2(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each3(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each3(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}

// node_modules/echarts/lib/preprocessor/backwardCompat.js
function get(opt, path) {
  var pathArr = path.split(",");
  var obj = opt;
  for (var i3 = 0;i3 < pathArr.length; i3++) {
    obj = obj && obj[pathArr[i3]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set(opt, path, val, overwrite) {
  var pathArr = path.split(",");
  var obj = opt;
  var key;
  var i3 = 0;
  for (;i3 < pathArr.length - 1; i3++) {
    key = pathArr[i3];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i3]] == null) {
    obj[pathArr[i3]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (var i3 = 0;i3 < BAR_ITEM_STYLE_MAP.length; i3++) {
      var oldName = BAR_ITEM_STYLE_MAP[i3][1];
      var newName = BAR_ITEM_STYLE_MAP[i3][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
        if (true) {
          deprecateReplaceLog(oldName, newName);
        }
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    if (true) {
      deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
    }
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
    if (true) {
      deprecateReplaceLog("downplay", "blur", "sunburst");
    }
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      if (true) {
        deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
      }
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (var i3 = 0;i3 < data.length; i3++) {
      cb(data[i3]);
      data[i3] && traverseTree(data[i3].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each(option.series, function(seriesOpt) {
    if (!isObject2(seriesOpt)) {
      return;
    }
    var seriesType = seriesOpt.type;
    if (seriesType === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
        if (true) {
          deprecateReplaceLog("clipOverflow", "clip", "line");
        }
      }
    } else if (seriesType === "pie" || seriesType === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
        if (true) {
          deprecateReplaceLog("clockWise", "clockwise");
        }
      }
      compatPieLabel(seriesOpt.label);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i3 = 0;i3 < data.length; i3++) {
          compatPieLabel(data[i3]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          if (true) {
            deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
          }
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType === "gauge") {
      var pointerColor = get(seriesOpt, "pointer.color");
      pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i3 = 0;i3 < data.length; i3++) {
          if (typeof data[i3] === "object") {
            compatBarItemStyle(data[i3]);
            compatBarItemStyle(data[i3] && data[i3].emphasis);
          }
        }
      }
    } else if (seriesType === "sunburst") {
      var highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
          if (true) {
            deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
          }
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType === "graph" || seriesType === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        if (true) {
          deprecateReplaceLog("mapType", "map", "map");
        }
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        if (true) {
          deprecateLog("`mapLocation` is not used anymore.");
        }
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        if (true) {
          deprecateReplaceLog("hoverAnimation", "emphasis.scale");
        }
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each(COMPATITABLE_COMPONENTS, function(componentName) {
    var options = option[componentName];
    if (options) {
      if (!isArray(options)) {
        options = [options];
      }
      each(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}

// node_modules/echarts/lib/processor/dataStack.js
function dataStack(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    var stack = seriesModel.get("stack");
    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
    targetData.modify(dims, function(v0, v1, dataIndex) {
      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j3 = idxInStack - 1;j3 >= 0; j3--) {
        var stackInfo = stackInfoList[j3];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum >= 0 && val > 0 || stackStrategy === "samesign" && sum <= 0 && val < 0) {
            sum = addSafe(sum, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}

// node_modules/echarts/lib/view/Component.js
var ComponentView = function() {
  function ComponentView2() {
    this.group = new Group_default;
    this.uid = getUID("viewComponent");
  }
  ComponentView2.prototype.init = function(ecModel, api) {};
  ComponentView2.prototype.render = function(model, ecModel, api, payload) {};
  ComponentView2.prototype.dispose = function(ecModel, api) {};
  ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {};
  ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {};
  ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {};
  ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {};
  ComponentView2.prototype.eachRendered = function(cb) {
    var group = this.group;
    if (group) {
      group.traverse(cb);
    }
  };
  return ComponentView2;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var Component_default2 = ComponentView;

// node_modules/echarts/lib/visual/style.js
var inner5 = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn("Unknown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn("Unknown style type '" + stylePath + "'.");
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var styleModel = seriesModel.getModel(stylePath);
    var getStyle = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle(styleModel);
    var decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color = globalStyle[colorKey];
    var colorCallback = isFunction(color) ? color : null;
    var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      var colorPalette = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach: function(data2, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model_default;
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var getStyle = getStyleMapper(seriesModel, stylePath);
    var colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        var rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle(sharedModel);
          var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function(ecModel) {
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      var key = seriesModel.type + "-" + colorBy;
      var colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner5(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data = seriesModel.getData();
      var colorScope = inner5(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        var rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};

// node_modules/echarts/lib/loading/default.js
var PI6 = Math.PI;
function defaultLoading(api, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group_default;
  var mask = new Rect_default({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  var textContent = new Text_default({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect_default({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;
  if (opts.showSpinner) {
    arc = new Arc_default({
      shape: {
        startAngle: -PI6 / 2,
        endAngle: -PI6 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1000, {
      endAngle: PI6 * 3 / 2
    }).start("circularInOut");
    arc.animateShape(true).when(1000, {
      startAngle: PI6 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc);
  }
  group.resize = function() {
    var textWidth = textContent.getBoundingRect().width;
    var r3 = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r3 * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r3);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r3,
      y: cy - r3,
      width: r3 * 2,
      height: r3 * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}

// node_modules/echarts/lib/core/Scheduler.js
var Scheduler = function() {
  function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  Scheduler2.prototype.restoreData = function(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  };
  Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    var pipeline = this._pipelineMap.get(task.__pipeline.id);
    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step,
      modBy,
      modDataCount
    };
  };
  Scheduler2.prototype.getPipeline = function(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);
    var data = seriesModel.getData();
    var dataLen = data.count();
    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  };
  Scheduler2.prototype.restorePipelines = function(ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };
  Scheduler2.prototype.prepareStageTasks = function() {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each(this._allHandlers, function(handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      var errMsg = "";
      if (true) {
        errMsg = '"reset" and "overallReset" must not be both specified.';
      }
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
    }, this);
  };
  Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  };
  Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };
  Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };
  Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs_1);
        });
        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          var performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.performSeriesTasks = function(ecModel) {
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.plan = function() {
    this._pipelineMap.each(function(pipeline) {
      var task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  };
  Scheduler2.prototype.updatePayload = function(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  };
  Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create3);
    } else if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, create3);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create3);
    }
    function create3(seriesModel) {
      var pipelineId = seriesModel.uid;
      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  };
  Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel,
      api,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap;
    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false;
    var errMsg = "";
    if (true) {
      errMsg = '"createOnAllSeries" is not supported for "overallReset", ' + "because it will block all streams.";
    }
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } else {
      overallProgress = false;
      each(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };
  Scheduler2.prototype._pipe = function(seriesModel, task) {
    var pipelineId = seriesModel.uid;
    var pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };
  Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
    if (isFunction(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler2;
}();
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map(resetDefines, function(v3, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i3 = params.start;i3 < params.end; i3++) {
        resetDefine.dataEach(data, i3);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e4) {}
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, Global_default);
mockMethods(apiMock, ExtensionAPI_default);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name_1 in Clz.prototype) {
    target[name_1] = noop;
  }
}
var Scheduler_default = Scheduler;

// node_modules/echarts/lib/theme/light.js
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var light_default = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};

// node_modules/echarts/lib/theme/dark.js
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    },
    pageTextStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var dark_default = theme;

// node_modules/echarts/lib/util/ECEventProcessor.js
var ECEventProcessor = function() {
  function ECEventProcessor2() {}
  ECEventProcessor2.prototype.normalizeQuery = function(query) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {};
    if (isString(query)) {
      var condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      var suffixes_1 = ["Index", "Name", "Id"];
      var dataKeys_1 = {
        name: 1,
        dataIndex: 1,
        dataType: 1
      };
      each(query, function(val, key) {
        var reserved = false;
        for (var i3 = 0;i3 < suffixes_1.length; i3++) {
          var propSuffix = suffixes_1[i3];
          var suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            var mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys_1.hasOwnProperty(key)) {
          dataQuery[key] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  };
  ECEventProcessor2.prototype.filter = function(eventType, query) {
    var eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    var cptQuery = query.cptQuery;
    var dataQuery = query.dataQuery;
    return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  };
  ECEventProcessor2.prototype.afterTrigger = function() {
    this.eventInfo = null;
  };
  return ECEventProcessor2;
}();

// node_modules/echarts/lib/visual/symbol.js
var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;
    for (var i3 = 0;i3 < SYMBOL_PROPS_WITH_CB.length; i3++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i3];
      var val = seriesModel.get(symbolPropName);
      if (isFunction(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var symbolPropsCb = keys(symbolOptionsCb);
    function dataEach(data2, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);
      for (var i4 = 0;i4 < symbolPropsCb.length; i4++) {
        var symbolPropName2 = symbolPropsCb[i4];
        data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
      }
    }
    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      for (var i3 = 0;i3 < SYMBOL_PROPS.length; i3++) {
        var symbolPropName = SYMBOL_PROPS[i3];
        var val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};

// node_modules/echarts/lib/visual/helper.js
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case "color":
      var style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key);
    default:
      if (true) {
        console.warn("Unknown visual type " + key);
      }
  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case "color":
      var style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key);
    default:
      if (true) {
        console.warn("Unknown visual type " + key);
      }
  }
}

// node_modules/echarts/lib/util/event.js
function findEventDispatcher(target, det, returnFirstMatch) {
  var found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}

// node_modules/zrender/lib/core/WeakMap.js
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap2 = function() {
  function WeakMap3() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  WeakMap3.prototype.get = function(key) {
    return this._guard(key)[this._id];
  };
  WeakMap3.prototype.set = function(key, value2) {
    var target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value: value2,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value2;
    }
    return this;
  };
  WeakMap3.prototype["delete"] = function(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  };
  WeakMap3.prototype.has = function(key) {
    return !!this._guard(key)[this._id];
  };
  WeakMap3.prototype._guard = function(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  };
  return WeakMap3;
}();
var WeakMap_default = WeakMap2;

// node_modules/zrender/lib/canvas/helper.js
function isSafeNum(num) {
  return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
  var x3 = obj.x == null ? 0 : obj.x;
  var x22 = obj.x2 == null ? 1 : obj.x2;
  var y3 = obj.y == null ? 0 : obj.y;
  var y22 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x3 = x3 * rect.width + rect.x;
    x22 = x22 * rect.width + rect.x;
    y3 = y3 * rect.height + rect.y;
    y22 = y22 * rect.height + rect.y;
  }
  x3 = isSafeNum(x3) ? x3 : 0;
  x22 = isSafeNum(x22) ? x22 : 1;
  y3 = isSafeNum(y3) ? y3 : 0;
  y22 = isSafeNum(y22) ? y22 : 0;
  var canvasGradient = ctx.createLinearGradient(x3, y3, x22, y22);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min3 = Math.min(width, height);
  var x3 = obj.x == null ? 0.5 : obj.x;
  var y3 = obj.y == null ? 0.5 : obj.y;
  var r3 = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x3 = x3 * width + rect.x;
    y3 = y3 * height + rect.y;
    r3 = r3 * min3;
  }
  x3 = isSafeNum(x3) ? x3 : 0.5;
  y3 = isSafeNum(y3) ? y3 : 0.5;
  r3 = r3 >= 0 && isSafeNum(r3) ? r3 : 0.5;
  var canvasGradient = ctx.createRadialGradient(x3, y3, 0, x3, y3, r3);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  var colorStops = obj.colorStops;
  for (var i3 = 0;i3 < colorStops.length; i3++) {
    canvasGradient.addColorStop(colorStops[i3].offset, colorStops[i3].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i3 = 0;i3 < clipPaths.length; i3++) {
    if (clipPaths[i3] !== prevClipPaths[i3]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize(root, whIdx, opts) {
  var wh = ["width", "height"][whIdx];
  var cwh = ["clientWidth", "clientHeight"][whIdx];
  var plt = ["paddingLeft", "paddingTop"][whIdx];
  var prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  var stl = document.defaultView.getComputedStyle(root);
  return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}

// node_modules/zrender/lib/canvas/dashStyle.js
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
}
function getLineDash(el) {
  var style = el.style;
  var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  var lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale_1 && lineScale_1 !== 1) {
      lineDash = map(lineDash, function(rawVal) {
        return rawVal / lineScale_1;
      });
      lineDashOffset /= lineScale_1;
    }
  }
  return [lineDash, lineDashOffset];
}

// node_modules/zrender/lib/canvas/graphic.js
var pathProxyForDraw = new PathProxy_default(true);
function styleHasStroke(style) {
  var stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  var image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      var matrix = new DOMMatrix;
      matrix.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  var _a2;
  var hasStroke = styleHasStroke(style);
  var hasFill = styleHasFill(style);
  var strokePercent = style.strokePercent;
  var strokePart = strokePercent < 1;
  var firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  var path = el.path || pathProxyForDraw;
  var dirtyFlag = el.__dirty;
  if (!inBatch) {
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    var fillGradient = undefined;
    var strokeGradient = undefined;
    var fillPattern = undefined;
    var strokePattern = undefined;
    var rect = undefined;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  var scale3 = el.getGlobalScale();
  path.setScale(scale3[0], scale3[1], el.segmentIgnoreThreshold);
  var lineDash;
  var lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
  }
  var needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  var x3 = style.x || 0;
  var y3 = style.y || 0;
  var width = el.getWidth();
  var height = el.getHeight();
  var aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x3, y3, width, height);
  } else if (style.sx && style.sy) {
    var sx = style.sx;
    var sy = style.sy;
    var sWidth = width - sx;
    var sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x3, y3, width, height);
  } else {
    ctx.drawImage(image, x3, y3, width, height);
  }
}
function brushText(ctx, el, style) {
  var _a2;
  var text = style.text;
  text != null && (text += "");
  if (text) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    var lineDash = undefined;
    var lineDashOffset = undefined;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  var styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    var opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (var i3 = 0;i3 < SHADOW_NUMBER_PROPS.length; i3++) {
    var propName = SHADOW_NUMBER_PROPS[i3];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  var style = getStyle(el, scope.inHover);
  var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    var lineWidth = style.lineWidth;
    var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (var i3 = 0;i3 < STROKE_PROPS.length; i3++) {
    var prop = STROKE_PROPS[i3];
    var propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  var m5 = el.transform;
  var dpr2 = ctx.dpr || 1;
  if (m5) {
    ctx.setTransform(dpr2 * m5[0], dpr2 * m5[1], dpr2 * m5[2], dpr2 * m5[3], dpr2 * m5[4], dpr2 * m5[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  var allClipped = false;
  for (var i3 = 0;i3 < clipPaths.length; i3++) {
    var clipPath = clipPaths[i3];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  var hasFill = styleHasFill(style);
  var hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush(ctx, el, scope, isLast) {
  var m5 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  var clipPaths = el.__clipPaths;
  var prevElClipPaths = scope.prevElClipPaths;
  var forceSetTransform = false;
  var forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  var prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  var canBatchPath = el instanceof Path_default && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m5, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  var style = getStyle(el, scope.inHover);
  if (el instanceof Path_default) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan_default) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof Image_default) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  var displayables = el.getDisplayables();
  var temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  var innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  var i3;
  var len2;
  for (i3 = el.getCursor(), len2 = displayables.length;i3 < len2; i3++) {
    var displayable = displayables[i3];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i3 === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (var i_1 = 0, len_1 = temporalDisplayables.length;i_1 < len_1; i_1++) {
    var displayable = temporalDisplayables[i_1];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}

// node_modules/echarts/lib/util/decal.js
var decalMap = new WeakMap_default;
var decalCache = new LRU_default(100);
var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === "none") {
    return null;
  }
  var dpr2 = api.getDevicePixelRatio();
  var zr = api.getZr();
  var isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }
  var oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  var decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  var pattern = {
    repeat: "repeat"
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    var keys2 = [dpr2];
    var isValidKey = true;
    for (var i3 = 0;i3 < decalKeys.length; ++i3) {
      var value2 = decalOpt[decalKeys[i3]];
      if (value2 != null && !isArray(value2) && !isString(value2) && !isNumber(value2) && typeof value2 !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value2);
    }
    var cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      var cache2 = decalCache.get(cacheKey);
      if (cache2) {
        isSVG ? pattern2.svgElement = cache2 : pattern2.image = cache2;
      }
    }
    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    var pSize = getPatternSize();
    var ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      var width = 1;
      for (var i4 = 0, xlen = lineBlockLengthsX.length;i4 < xlen; ++i4) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i4]);
      }
      var symbolRepeats = 1;
      for (var i4 = 0, xlen = symbolArray.length;i4 < xlen; ++i4) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i4].length);
      }
      width *= symbolRepeats;
      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      if (true) {
        var warn2 = function(attrName) {
          console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
        };
        if (width > decalOpt.maxTileWidth) {
          warn2("maxTileWidth");
        }
        if (height > decalOpt.maxTileHeight) {
          warn2("maxTileHeight");
        }
      }
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      var ySum = 0;
      for (var i4 = 0;i4 < dashArrayY.length; ++i4) {
        ySum += dashArrayY[i4];
      }
      if (ySum <= 0) {
        return;
      }
      var y3 = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;
      while (y3 < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x3 = 0;
          var xId1 = 0;
          var xId1Total = 0;
          while (x3 < pSize.width * 2) {
            var xSum = 0;
            for (var i4 = 0;i4 < dashArrayX[xId0].length; ++i4) {
              xSum += dashArrayX[xId0][i4];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              var size = (1 - decalOpt.symbolSize) * 0.5;
              var left = x3 + dashArrayX[xId0][xId1] * size;
              var top_1 = y3 + dashArrayY[yId] * size;
              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x3 += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y3 += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x4, y4, width2, height2, symbolType) {
        var scale3 = isSVG ? 1 : dpr2;
        var symbol = createSymbol(symbolType, x4 * scale3, y4 * scale3, width2 * scale3, height2 * scale3, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          var symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString(symbol)) {
    return [[symbol]];
  }
  var isAllString = true;
  for (var i3 = 0;i3 < symbol.length; ++i3) {
    if (!isString(symbol[i3])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  var result = [];
  for (var i3 = 0;i3 < symbol.length; ++i3) {
    if (isString(symbol[i3])) {
      result.push([symbol[i3]]);
    } else {
      result.push(symbol[i3]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  var isAllNumber = true;
  for (var i3 = 0;i3 < dash.length; ++i3) {
    if (!isNumber(dash[i3])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  var result = [];
  for (var i3 = 0;i3 < dash.length; ++i3) {
    if (isNumber(dash[i3])) {
      var dashValue = Math.ceil(dash[i3]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map(dash[i3], function(n3) {
        return Math.ceil(n3);
      });
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }
  var dashValue = map(dash, function(n3) {
    return Math.ceil(n3);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map(dash, function(line) {
    return getLineBlockLengthY(line);
  });
}
function getLineBlockLengthY(dash) {
  var blockLength = 0;
  for (var i3 = 0;i3 < dash.length; ++i3) {
    blockLength += dash[i3];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}

// node_modules/echarts/lib/visual/decal.js
function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function(seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each(function(idx) {
        var decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
        }
      });
    }
    var decal = data.getVisual("decal");
    if (decal) {
      var style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}

// node_modules/echarts/lib/core/lifecycle.js
var lifecycle = new Eventful_default;
var lifecycle_default = lifecycle;

// node_modules/echarts/lib/core/impl.js
var implsStore = {};
function registerImpl(name, impl) {
  if (true) {
    if (implsStore[name]) {
      error("Already has an implementation of " + name + ".");
    }
  }
  implsStore[name] = impl;
}
function getImpl(name) {
  if (true) {
    if (!implsStore[name]) {
      error("Implementation of " + name + " doesn't exists.");
    }
  }
  return implsStore[name];
}

// node_modules/echarts/lib/core/echarts.js
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_DEFAULT = 2000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;
var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5000;
var PRIORITY_VISUAL_ARIA = 6000;
var PRIORITY_VISUAL_DECAL = 7000;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful_default.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
  __extends(MessageCenter2, _super);
  function MessageCenter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return MessageCenter2;
}(Eventful_default);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = function(_super) {
  __extends(ECharts2, _super);
  function ECharts2(dom, theme2, opts) {
    var _this = _super.call(this, new ECEventProcessor) || this;
    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {};
    _this._pendingActions = [];
    opts = opts || {};
    if (isString(theme2)) {
      theme2 = themeStorage[theme2];
    }
    _this._dom = dom;
    var defaultRenderer = "canvas";
    var defaultCoarsePointer = "auto";
    var defaultUseDirtyRect = false;
    if (true) {
      var root = env_default.hasGlobalWindow ? window : global;
      if (root) {
        defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
        defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
        defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
      }
    }
    if (opts.ssr) {
      registerSSRDataGetter(function(el) {
        var ecData = getECData(el);
        var dataIndex = ecData.dataIndex;
        if (dataIndex == null) {
          return;
        }
        var hashMap = createHashMap();
        hashMap.set("series_index", ecData.seriesIndex);
        hashMap.set("data_index", dataIndex);
        ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
        return hashMap;
      });
    }
    var zr = _this._zr = init(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
      useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
      pointerSize: opts.pointerSize
    });
    _this._ssr = opts.ssr;
    _this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
    theme2 = clone(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    _this._theme = theme2;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem_default;
    var api = _this._api = createExtensionAPI(_this);
    function prioritySortFunc(a3, b) {
      return a3.__prio - b.__prio;
    }
    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler_default(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter;
    _this._initEvents();
    _this.resize = bind(_this.resize, _this);
    zr.animation.on("frame", _this._onframe, _this);
    bindRenderedEvent(zr, _this);
    bindMouseEvent(zr, _this);
    setAsPrimitive(_this);
    return _this;
  }
  ECharts2.prototype._onframe = function() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    var scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e4) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e4;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +new Date;
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain", {});
        remainTime -= +new Date - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  ECharts2.prototype.getDom = function() {
    return this._dom;
  };
  ECharts2.prototype.getId = function() {
    return this.id;
  };
  ECharts2.prototype.getZr = function() {
    return this._zr;
  };
  ECharts2.prototype.isSSR = function() {
    return this._ssr;
  };
  ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`setOption` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    var replaceMerge;
    var transitionOpt;
    if (isObject2(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager_default(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new Global_default;
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {
      replaceMerge
    }, optionPreprocessorFuncs);
    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e4) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e4;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  ECharts2.prototype.setTheme = function() {
    deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
  };
  ECharts2.prototype.getModel = function() {
    return this._model;
  };
  ECharts2.prototype.getOption = function() {
    return this._model && this._model.getOption();
  };
  ECharts2.prototype.getWidth = function() {
    return this._zr.getWidth();
  };
  ECharts2.prototype.getHeight = function() {
    return this._zr.getHeight();
  };
  ECharts2.prototype.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
  };
  ECharts2.prototype.getRenderedCanvas = function(opts) {
    if (true) {
      deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
    }
    return this.renderToCanvas(opts);
  };
  ECharts2.prototype.renderToCanvas = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    if (true) {
      if (painter.type !== "canvas") {
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      }
    }
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };
  ECharts2.prototype.renderToSVGString = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    if (true) {
      if (painter.type !== "svg") {
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      }
    }
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  ECharts2.prototype.getSvgDataURL = function() {
    if (!env_default.svgSupported) {
      return;
    }
    var zr = this._zr;
    var list = zr.storage.getDisplayList();
    each(list, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  };
  ECharts2.prototype.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        var view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url2 = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url2;
  };
  ECharts2.prototype.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin8 = Math.min;
    var mathMax8 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each(instances2, function(chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin8(boundingRect.left, left_1);
          top_1 = mathMin8(boundingRect.top, top_1);
          right_1 = mathMax8(boundingRect.right, right_1);
          bottom_1 = mathMax8(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width = right_1 - left_1;
      var height = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr_1.resize({
        width,
        height
      });
      if (isSvg) {
        var content_1 = "";
        each(canvasList_1, function(item) {
          var x3 = item.left - left_1;
          var y3 = item.top - top_1;
          content_1 += '<g transform="translate(' + x3 + "," + y3 + ')">' + item.dom + "</g>";
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;
        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect_default({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each(canvasList_1, function(item) {
          var img = new Image_default({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  ECharts2.prototype.convertToPixel = function(finder, value2) {
    return doConvertPixel(this, "convertToPixel", finder, value2);
  };
  ECharts2.prototype.convertFromPixel = function(finder, value2) {
    return doConvertPixel(this, "convertFromPixel", finder, value2);
  };
  ECharts2.prototype.containPixel = function(finder, value2) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    var findResult = parseFinder(ecModel, finder);
    each(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each(models, function(model) {
        var coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value2);
        } else if (key === "seriesModels") {
          var view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value2, model);
          } else {
            if (true) {
              warn(key + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
            }
          }
        } else {
          if (true) {
            warn(key + ": containPoint is not supported");
          }
        }
      }, this);
    }, this);
    return !!result;
  };
  ECharts2.prototype.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = parsedFinder.seriesModel;
    if (true) {
      if (!seriesModel) {
        warn("There is no specified series model");
      }
    }
    var data = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  };
  ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  ECharts2.prototype._initEvents = function() {
    var _this = this;
    each(MOUSE_EVENT_NAMES, function(eveName) {
      var handler = function(e4) {
        var ecModel = _this.getModel();
        var el = e4.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, function(parent) {
            var ecData = getECData(parent);
            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          if (true) {
            if (!isGlobalOut && !(model && view)) {
              warn("model or view can not be found by params");
            }
          }
          params.event = e4;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view
          };
          _this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      _this._zr.on(eveName, handler, _this);
    });
    each(eventActionMap, function(actionType, eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    each(["selectchanged"], function(eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };
  ECharts2.prototype.isDisposed = function() {
    return this._disposed;
  };
  ECharts2.prototype.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  ECharts2.prototype.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    var dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each(chart._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances2[chart.id];
  };
  ECharts2.prototype.resize = function(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`resize` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var needPrepare = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e4) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e4;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.showLoading = function(name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject2(name)) {
      cfg = name;
      name = "";
    }
    name = name || "default";
    this.hideLoading();
    if (!loadingEffects[name]) {
      if (true) {
        warn("Loading effects " + name + " not exists.");
      }
      return;
    }
    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  ECharts2.prototype.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  ECharts2.prototype.makeActionFromEvent = function(eventObj) {
    var payload = extend({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  ECharts2.prototype.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject2(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env_default.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.updateLabelLayout = function() {
    lifecycle_default.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  };
  ECharts2.prototype.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (true) {
      assert(params.data && seriesModel);
    }
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  };
  ECharts2.internalField = function() {
    prepare = function(ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    prepareView = function(ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i3 = 0;i3 < viewList.length; i3++) {
        viewList[i3].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var requireNewView = model.__requireNewView;
        model.__requireNewView = false;
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = !requireNewView && viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? Component_default2.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
          if (true) {
            assert(Clazz, classType.sub + " does not exist.");
          }
          view2 = new Clazz;
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i3 = 0;i3 < viewList.length; ) {
        var view = viewList[i3];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i3, 1);
          if (viewMap[view.__id] === view) {
            delete viewMap[view.__id];
          }
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i3++;
        }
      }
    };
    updateDirectly = function(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload);
      if (!mainType) {
        each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;
      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each(normalizeToArray(excludeSeriesId), function(id) {
          var modelId = convertOptionIdName(id, null);
          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
        if (isExcluded) {
          return;
        }
        if (isHighDownPayload(payload)) {
          if (model instanceof Series_default) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            }
            if (dispatchers) {
              each(dispatchers, function(dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          if (model instanceof Series_default) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    };
    updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          optionChanged: payload.newOption != null
        });
      },
      update: function(payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload, updateParams);
        var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
        var darkMode = ecModel.get("darkMode");
        zr.setBackgroundColor(backgroundColor2);
        if (darkMode != null && darkMode !== "auto") {
          zr.setDarkMode(darkMode);
        }
        lifecycle_default.trigger("afterupdate", ecModel, api);
      },
      updateTransform: function(payload) {
        var _this = this;
        var ecModel = this._model;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType === "series") {
            return;
          }
          var componentView = _this.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle_default.trigger("afterupdate", ecModel, api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        Chart_default.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, ecModel, this._api, payload, {});
        lifecycle_default.trigger("afterupdate", ecModel, this._api);
      },
      updateVisual: function(payload) {
        var _this = this;
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.getData().clearAllVisual();
        });
        Chart_default.markUpdateMethod(payload, "updateVisual");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: "visual",
          setDirty: true
        });
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType !== "series") {
            var componentView = _this.getViewOfComponentModel(componentModel);
            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle_default.trigger("afterupdate", ecModel, this._api);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    doConvertPixel = function(ecIns, methodName, finder, value2) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }
      var ecModel = ecIns._model;
      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
      var result;
      var parsedFinder = parseFinder(ecModel, finder);
      for (var i3 = 0;i3 < coordSysList.length; i3++) {
        var coordSys = coordSysList[i3];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value2)) != null) {
          return result;
        }
      }
      if (true) {
        warn("No coordinate system that supports " + methodName + " found by the given finder.");
      }
    };
    updateStreamModes = function(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };
    doDispatchAction = function(payload, silent) {
      var _this = this;
      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo.update || "update").split(":");
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = map(payload.batch, function(item) {
          item = defaults(extend({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload);
      if (isHighDown) {
        allLeaveBlur(this._api);
      }
      each(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
        eventObj = eventObj || extend({}, batchItem);
        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          updateDirectly(_this, updateMethod, batchItem, "series");
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });
      if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
        try {
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e4) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e4;
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj);
        if (isSelectChange) {
          var newObj = {
            type: "selectchanged",
            escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };
    flushPendingActions = function(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };
    triggerUpdatedEvent = function(silent) {
      !silent && this.trigger("updated");
    };
    bindRenderedEvent = function(zr, ecIns) {
      zr.on("rendered", function(params) {
        ecIns.trigger("rendered", params);
        if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    };
    bindMouseEvent = function(zr, ecIns) {
      zr.on("mouseover", function(e4) {
        var el = e4.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e4, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("mouseout", function(e4) {
        var el = e4.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e4, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("click", function(e4) {
        var el = e4.target;
        var dispatcher = findEventDispatcher(el, function(target) {
          return getECData(target).dataIndex != null;
        }, true);
        if (dispatcher) {
          var actionType = dispatcher.selected ? "unselect" : "select";
          var ecData = getECData(dispatcher);
          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeparateZLevel = false;
      ecModel.eachComponent(function(componentType, componentModel) {
        var zlevel = componentModel.get("zlevel") || 0;
        var z3 = componentModel.get("z") || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
        (componentType === "series" ? seriesZLevels : componentZLevels).push({
          zlevel,
          z: z3,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });
      if (hasSeparateZLevel) {
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort(zLevels, function(a3, b) {
          if (a3.zlevel === b.zlevel) {
            return a3.z - b.z;
          }
          return a3.zlevel - b.zlevel;
        });
        each(zLevels, function(item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key = item.key;
          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }
          if (key) {
            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
              zlevel++;
            }
            lastSeriesKey_1 = key;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }
            lastSeriesKey_1 = "";
          }
          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }
    render = function(ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams);
      each(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };
    renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      var scheduler = ecIns._scheduler;
      updateParams = extend(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      });
      lifecycle_default.trigger("series:beforeupdate", ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        clearStates(seriesModel, chartView);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }
        chartView.group.silent = !!seriesModel.get("silent");
        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle_default.trigger("series:layoutlabels", ecModel, api, updateParams);
      lifecycle_default.trigger("series:transition", ecModel, api, updateParams);
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        updateZ(seriesModel, chartView);
        updateStates(seriesModel, chartView);
      });
      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle_default.trigger("series:afterupdate", ecModel, api, updateParams);
    };
    markStatusToUpdate = function(ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
      ecIns.getZr().wakeUp();
    };
    applyChangedStates = function(ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }
      ecIns.getZr().storage.traverse(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        applyElementStates(el);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };
    function applyElementStates(el) {
      var newStates = [];
      var oldStates = el.currentStates;
      for (var i3 = 0;i3 < oldStates.length; i3++) {
        var stateName = oldStates[i3];
        if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
          newStates.push(stateName);
        }
      }
      if (el.selected && el.states.select) {
        newStates.push("select");
      }
      if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
        newStates.push("emphasis");
      } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
        newStates.push("blur");
      }
      el.useStates(newStates);
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage = zr.storage;
      var elCount = 0;
      storage.traverse(function(el) {
        if (!el.isGroup) {
          elCount++;
        }
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.eachRendered(function(el) {
              if (el.states.emphasis) {
                el.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.eachRendered(function(el) {
        if (!el.isGroup) {
          el.style.blend = blendMode;
        }
      });
    }
    function updateZ(model, view) {
      if (model.preventAutoZ) {
        return;
      }
      var z3 = model.get("z") || 0;
      var zlevel = model.get("zlevel") || 0;
      view.eachRendered(function(el) {
        doUpdateZ(el, z3, zlevel, -Infinity);
        return true;
      });
    }
    function doUpdateZ(el, z3, zlevel, maxZ2) {
      var label = el.getTextContent();
      var labelLine = el.getTextGuideLine();
      var isGroup = el.isGroup;
      if (isGroup) {
        var children = el.childrenRef();
        for (var i3 = 0;i3 < children.length; i3++) {
          maxZ2 = Math.max(doUpdateZ(children[i3], z3, zlevel, maxZ2), maxZ2);
        }
      } else {
        el.z = z3;
        el.zlevel = zlevel;
        maxZ2 = Math.max(el.z2, maxZ2);
      }
      if (label) {
        label.z = z3;
        label.zlevel = zlevel;
        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }
      if (labelLine) {
        var textGuideLineConfig = el.textGuideLineConfig;
        labelLine.z = z3;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }
      return maxZ2;
    }
    function clearStates(model, view) {
      view.eachRendered(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        var textContent = el.getTextContent();
        var textGuide = el.getTextGuideLine();
        if (el.stateTransition) {
          el.stateTransition = null;
        }
        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }
        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        }
        if (el.hasState()) {
          el.prevStates = el.currentStates;
          el.clearStates();
        } else if (el.prevStates) {
          el.prevStates = null;
        }
      });
    }
    function updateStates(model, view) {
      var stateAnimationModel = model.getModel("stateAnimation");
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get("duration");
      var stateTransition = duration > 0 ? {
        duration,
        delay: stateAnimationModel.get("delay"),
        easing: stateAnimationModel.get("easing")
      } : null;
      view.eachRendered(function(el) {
        if (el.states && el.states.emphasis) {
          if (isElementRemoved(el)) {
            return;
          }
          if (el instanceof Path_default) {
            savePathStates(el);
          }
          if (el.__dirty) {
            var prevStates = el.prevStates;
            if (prevStates) {
              el.useStates(prevStates);
            }
          }
          if (enableAnimation) {
            el.stateTransition = stateTransition;
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (textContent) {
              textContent.stateTransition = stateTransition;
            }
            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          }
          if (el.__dirty) {
            applyElementStates(el);
          }
        }
      });
    }
    createExtensionAPI = function(ecIns) {
      return new (function(_super2) {
        __extends(class_1, _super2);
        function class_1() {
          return _super2 !== null && _super2.apply(this, arguments) || this;
        }
        class_1.prototype.getCoordinateSystems = function() {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };
        class_1.prototype.getComponentByElement = function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        };
        class_1.prototype.enterEmphasis = function(el, highlightDigit) {
          enterEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
          leaveEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterBlur = function(el) {
          enterBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveBlur = function(el) {
          leaveBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterSelect = function(el) {
          enterSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveSelect = function(el) {
          leaveSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.getModel = function() {
          return ecIns.getModel();
        };
        class_1.prototype.getViewOfComponentModel = function(componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };
        class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };
        return class_1;
      }(ExtensionAPI_default))(ecIns);
    };
    enableConnect = function(chart) {
      function updateConnectedChartsStatus(charts, status) {
        for (var i3 = 0;i3 < charts.length; i3++) {
          var otherChart = charts[i3];
          otherChart[CONNECT_STATUS_KEY] = status;
        }
      }
      each(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action_1 = chart.makeActionFromEvent(event);
            var otherCharts_1 = [];
            each(instances2, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts_1.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
            each(otherCharts_1, function(otherChart) {
              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                otherChart.dispatchAction(action_1);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
          }
        });
      });
    };
  }();
  return ECharts2;
}(Eventful_default);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  var self2 = this;
  deprecateLog("ECharts#one is deprecated.");
  function wrapped() {
    var args2 = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(id) {
  if (true) {
    warn("Instance " + id + " has been disposed");
  }
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances2 = {};
var connectedGroups = {};
var idBase = +new Date - 0;
var groupIdBase = +new Date - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init2(dom, theme2, opts) {
  var isClient = !(opts && opts.ssr);
  if (isClient) {
    if (true) {
      if (!dom) {
        throw new Error("Initialize failed: invalid dom.");
      }
    }
    var existInstance = getInstanceByDom(dom);
    if (existInstance) {
      if (true) {
        warn("There is a chart instance already initialized on the dom.");
      }
      return existInstance;
    }
    if (true) {
      if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
        warn("Can't get DOM width or height. Please check " + "dom.clientWidth and dom.clientHeight. They should not be 0." + "For example, you may need to call this in the callback " + "of window.onload.");
      }
    }
  }
  var chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances2[chart.id] = chart;
  isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle_default.trigger("afterinit", chart);
  return chart;
}
function getInstanceByDom(dom) {
  return instances2[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function registerTheme(name, theme2) {
  themeStorage[name] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle_default.on(name, cb);
}
function registerAction(actionInfo, eventName, action) {
  if (isFunction(eventName)) {
    action = eventName;
    eventName = "";
  }
  var actionType = isObject2(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0];
  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {
      action,
      actionInfo
    };
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem_default.register(type, coordSysCreator);
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject2(priority)) {
    fn = priority;
    priority = defaultPriority;
  }
  if (true) {
    if (isNaN(priority) || priority == null) {
      throw new Error("Illegal priority");
    }
    each(targetList, function(wrap) {
      assert(wrap.__raw !== fn);
    });
  }
  if (indexOf(registeredTasks, fn) >= 0) {
    return;
  }
  registeredTasks.push(fn);
  var stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
function registerMap(mapName, geoJson, specialAreas) {
  var registerMap2 = getImpl("registerMap");
  registerMap2 && registerMap2(mapName, geoJson, specialAreas);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop);
registerTheme("light", light_default);
registerTheme("dark", dark_default);

// node_modules/echarts/lib/extension.js
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap,
  registerImpl,
  PRIORITY,
  ComponentModel: Component_default,
  ComponentView: Component_default2,
  SeriesModel: Series_default,
  ChartView: Chart_default,
  registerComponentModel: function(ComponentModelClass) {
    Component_default.registerClass(ComponentModelClass);
  },
  registerComponentView: function(ComponentViewClass) {
    Component_default2.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function(SeriesModelClass) {
    Series_default.registerClass(SeriesModelClass);
  },
  registerChartView: function(ChartViewClass) {
    Chart_default.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function(componentType, defaulter) {
    Component_default.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray(ext)) {
    each(ext, function(singleExt) {
      use(singleExt);
    });
    return;
  }
  if (indexOf(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}

// node_modules/echarts/lib/coord/cartesian/GridModel.js
var GridModel = function(_super) {
  __extends(GridModel2, _super);
  function GridModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridModel2.type = "grid";
  GridModel2.dependencies = ["xAxis", "yAxis"];
  GridModel2.layoutMode = "box";
  GridModel2.defaultOption = {
    show: false,
    z: 0,
    left: "10%",
    top: 60,
    right: "10%",
    bottom: 70,
    containLabel: false,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 1,
    borderColor: "#ccc"
  };
  return GridModel2;
}(Component_default);
var GridModel_default = GridModel;

// node_modules/echarts/lib/coord/axisModelCommonMixin.js
var AxisModelCommonMixin = function() {
  function AxisModelCommonMixin2() {}
  AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
    var option = this.option;
    return !option.scale;
  };
  AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
    return;
  };
  return AxisModelCommonMixin2;
}();

// node_modules/echarts/lib/coord/cartesian/AxisModel.js
var CartesianAxisModel = function(_super) {
  __extends(CartesianAxisModel2, _super);
  function CartesianAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  };
  CartesianAxisModel2.type = "cartesian2dAxis";
  return CartesianAxisModel2;
}(Component_default);
mixin2(CartesianAxisModel, AxisModelCommonMixin);

// node_modules/echarts/lib/coord/axisDefault.js
var defaultOption = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    showMinLine: true,
    showMaxLine: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis = merge({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption);
var valueAxis = merge({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption);
var timeAxis = merge({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault_default = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};

// node_modules/echarts/lib/data/OrdinalMeta.js
var uidBase = 0;
var OrdinalMeta = function() {
  function OrdinalMeta2(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  OrdinalMeta2.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map(data, getName);
    return new OrdinalMeta2({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  };
  OrdinalMeta2.prototype.getOrdinal = function(category) {
    return this._getOrCreateMap().get(category);
  };
  OrdinalMeta2.prototype.parseAndCollect = function(category) {
    var index;
    var needCollect = this._needCollect;
    if (!isString(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }
    var map3 = this._getOrCreateMap();
    index = map3.get(category);
    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map3.set(category, index);
      } else {
        index = NaN;
      }
    }
    return index;
  };
  OrdinalMeta2.prototype._getOrCreateMap = function() {
    return this._map || (this._map = createHashMap(this.categories));
  };
  return OrdinalMeta2;
}();
function getName(obj) {
  if (isObject2(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta_default = OrdinalMeta;

// node_modules/echarts/lib/coord/axisCommonTypes.js
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};

// node_modules/echarts/lib/coord/axisModelCreator.js
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each(AXIS_TYPES, function(v3, axisType) {
    var defaultOption2 = merge(merge({}, axisDefault_default[axisType], true), extraDefaultOption, true);
    var AxisModel = function(_super) {
      __extends(AxisModel2, _super);
      function AxisModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = axisName + "Axis." + axisType;
        return _this;
      }
      AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis"));
        merge(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      AxisModel2.prototype.optionUpdated = function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
        }
      };
      AxisModel2.prototype.getCategories = function(rawData) {
        var option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      };
      AxisModel2.prototype.getOrdinalMeta = function() {
        return this.__ordinalMeta;
      };
      AxisModel2.type = axisName + "Axis." + axisType;
      AxisModel2.defaultOption = defaultOption2;
      return AxisModel2;
    }(BaseAxisModelClass);
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}

// node_modules/echarts/lib/scale/Scale.js
var Scale = function() {
  function Scale2(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }
  Scale2.prototype.getSetting = function(name) {
    return this._setting[name];
  };
  Scale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  };
  Scale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  Scale2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  };
  Scale2.prototype.isInExtentRange = function(value2) {
    return this._extent[0] <= value2 && this._extent[1] >= value2;
  };
  Scale2.prototype.isBlank = function() {
    return this._isBlank;
  };
  Scale2.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  return Scale2;
}();
enableClassManagement(Scale);
var Scale_default = Scale;

// node_modules/echarts/lib/scale/helper.js
function isValueNice(val) {
  var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
  var f3 = Math.abs(val / exp10);
  return f3 === 0 || f3 === 1 || f3 === 2 || f3 === 3 || f3 === 5;
}
function isIntervalOrLogScale(scale3) {
  return scale3.type === "interval" || scale3.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent3[1] - extent3[0];
  var interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  var precision = result.intervalPrecision = getIntervalPrecision(interval);
  var niceTickExtent = result.niceTickExtent = [round2(Math.ceil(extent3[0] / interval) * interval, precision), round2(Math.floor(extent3[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval));
  var f3 = interval / exp10;
  if (!f3) {
    f3 = 1;
  } else if (f3 === 2) {
    f3 = 3;
  } else if (f3 === 3) {
    f3 = 5;
  } else {
    f3 *= 2;
  }
  return round2(f3 * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp(niceTickExtent, 0, extent3);
  clamp(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain2(val, extent3) {
  return val >= extent3[0] && val <= extent3[1];
}
function normalize2(val, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale3(val, extent3) {
  return val * (extent3[1] - extent3[0]) + extent3[0];
}

// node_modules/echarts/lib/scale/Ordinal.js
var OrdinalScale = function(_super) {
  __extends(OrdinalScale2, _super);
  function OrdinalScale2(setting) {
    var _this = _super.call(this, setting) || this;
    _this.type = "ordinal";
    var ordinalMeta = _this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta_default({});
    }
    if (isArray(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta_default({
        categories: map(ordinalMeta, function(item) {
          return isObject2(item) ? item.value : item;
        })
      });
    }
    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
    return _this;
  }
  OrdinalScale2.prototype.parse = function(val) {
    if (val == null) {
      return NaN;
    }
    return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  };
  OrdinalScale2.prototype.contain = function(rank) {
    rank = this.parse(rank);
    return contain2(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  };
  OrdinalScale2.prototype.normalize = function(val) {
    val = this._getTickNumber(this.parse(val));
    return normalize2(val, this._extent);
  };
  OrdinalScale2.prototype.scale = function(val) {
    val = Math.round(scale3(val, this._extent));
    return this.getRawOrdinalNumber(val);
  };
  OrdinalScale2.prototype.getTicks = function() {
    var ticks = [];
    var extent3 = this._extent;
    var rank = extent3[0];
    while (rank <= extent3[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  };
  OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
    return;
  };
  OrdinalScale2.prototype.setSortInfo = function(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    var infoOrdinalNumbers = info.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = [];
    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;
    for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length);tickNum < len2; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    var unusedOrdinal = 0;
    for (;tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };
  OrdinalScale2.prototype._getTickNumber = function(ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  OrdinalScale2.prototype.getLabel = function(tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  };
  OrdinalScale2.prototype.count = function() {
    return this._extent[1] - this._extent[0] + 1;
  };
  OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  OrdinalScale2.prototype.isInExtentRange = function(value2) {
    value2 = this._getTickNumber(value2);
    return this._extent[0] <= value2 && this._extent[1] >= value2;
  };
  OrdinalScale2.prototype.getOrdinalMeta = function() {
    return this._ordinalMeta;
  };
  OrdinalScale2.prototype.calcNiceTicks = function() {};
  OrdinalScale2.prototype.calcNiceExtent = function() {};
  OrdinalScale2.type = "ordinal";
  return OrdinalScale2;
}(Scale_default);
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale;

// node_modules/echarts/lib/scale/Interval.js
var roundNumber = round2;
var IntervalScale = function(_super) {
  __extends(IntervalScale2, _super);
  function IntervalScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "interval";
    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }
  IntervalScale2.prototype.parse = function(val) {
    return val;
  };
  IntervalScale2.prototype.contain = function(val) {
    return contain2(val, this._extent);
  };
  IntervalScale2.prototype.normalize = function(val) {
    return normalize2(val, this._extent);
  };
  IntervalScale2.prototype.scale = function(val) {
    return scale3(val, this._extent);
  };
  IntervalScale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  };
  IntervalScale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  };
  IntervalScale2.prototype.getInterval = function() {
    return this._interval;
  };
  IntervalScale2.prototype.setInterval = function(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
    var interval = this._interval;
    var extent3 = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    var safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    var tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  };
  IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent3 = this.getExtent();
    for (var i3 = 1;i3 < ticks.length; i3++) {
      var nextTick2 = ticks[i3];
      var prevTick = ticks[i3 - 1];
      var count = 0;
      var minorTicksGroup = [];
      var interval = nextTick2.value - prevTick.value;
      var minorInterval = interval / splitNumber;
      while (count < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  };
  IntervalScale2.prototype.getLabel = function(data, opt) {
    if (data == null) {
      return "";
    }
    var precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    var dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  };
  IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };
  IntervalScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        var expandSize = Math.abs(extent3[0]);
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    var interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  };
  IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
    this._niceExtent = [min3, max3];
  };
  IntervalScale2.type = "interval";
  return IntervalScale2;
}(Scale_default);
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale;

// node_modules/echarts/lib/scale/Time.js
var bisect = function(a3, x3, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a3[mid][1] < x3) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = function(_super) {
  __extends(TimeScale2, _super);
  function TimeScale2(settings) {
    var _this = _super.call(this, settings) || this;
    _this.type = "time";
    return _this;
  }
  TimeScale2.prototype.getLabel = function(tick) {
    var useUTC = this.getSetting("useUTC");
    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  };
  TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
    var isUTC = this.getSetting("useUTC");
    var lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  TimeScale2.prototype.getTicks = function() {
    var interval = this._interval;
    var extent3 = this._extent;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    var useUTC = this.getSetting("useUTC");
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  };
  TimeScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      var d3 = new Date;
      extent3[1] = +new Date(d3.getFullYear(), d3.getMonth(), d3.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };
  TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };
  TimeScale2.prototype.parse = function(val) {
    return isNumber(val) ? val : +parseDate(val);
  };
  TimeScale2.prototype.contain = function(val) {
    return contain2(this.parse(val), this._extent);
  };
  TimeScale2.prototype.normalize = function(val) {
    return normalize2(this.parse(val), this._extent);
  };
  TimeScale2.prototype.scale = function(val) {
    return scale3(val, this._extent);
  };
  TimeScale2.type = "time";
  return TimeScale2;
}(Interval_default);
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate(valueA);
  var dateB = parseDate(valueB);
  var isSame = function(unit2) {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  var isSameYear = function() {
    return isSame("year");
  };
  var isSameMonth = function() {
    return isSameYear() && isSame("month");
  };
  var isSameDay = function() {
    return isSameMonth() && isSame("day");
  };
  var isSameHour = function() {
    return isSameDay() && isSame("hour");
  };
  var isSameMinute = function() {
    return isSameHour() && isSame("minute");
  };
  var isSameSecond = function() {
    return isSameMinute() && isSame("second");
  };
  var isSameMilliSecond = function() {
    return isSameSecond() && isSame("millisecond");
  };
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  var safeLimit = 1e4;
  var unitNames = timeUnits;
  var iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d3 = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d3 += interval;
      date[setMethodName](d3);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (var i4 = 0;i4 < lastLevelTicks.length - 1; i4++) {
      var startTick = lastLevelTicks[i4].value;
      var endTick = lastLevelTicks[i4 + 1].value;
      if (startTick === endTick) {
        continue;
      }
      var interval = undefined;
      var getterName = undefined;
      var setterName = undefined;
      var isDate = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval, 31);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
      if (unitName === "year" && levelTicks2.length > 1 && i4 === 0) {
        levelTicks2.unshift({
          value: levelTicks2[0].value - interval
        });
      }
    }
    for (var i4 = 0;i4 < newAddedTicks.length; i4++) {
      levelTicks2.push(newAddedTicks[i4]);
    }
    return newAddedTicks;
  }
  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;
  for (var i3 = 0;i3 < unitNames.length && iter++ < safeLimit; ++i3) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i3]);
    if (!isPrimaryTimeUnit(unitNames[i3])) {
      continue;
    }
    addLevelTicks(unitNames[i3], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i3 + 1] ? getPrimaryTimeUnit(unitNames[i3 + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort(function(a3, b) {
          return a3.value - b.value;
        });
        var levelTicksRemoveDuplicated = [];
        for (var i_1 = 0;i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;
          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i3]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  if (true) {
    if (iter >= safeLimit) {
      warn("Exceed safe limit.");
    }
  }
  var levelsTicksInExtent = filter(map(levelsTicks, function(levelTicks2) {
    return filter(levelTicks2, function(tick) {
      return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
    });
  }), function(levelTicks2) {
    return levelTicks2.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;
  for (var i3 = 0;i3 < levelsTicksInExtent.length; ++i3) {
    var levelTicks = levelsTicksInExtent[i3];
    for (var k3 = 0;k3 < levelTicks.length; ++k3) {
      ticks.push({
        value: levelTicks[k3].value,
        level: maxLevel - i3
      });
    }
  }
  ticks.sort(function(a3, b) {
    return a3.value - b.value;
  });
  var result = [];
  for (var i3 = 0;i3 < ticks.length; ++i3) {
    if (i3 === 0 || ticks[i3].value !== ticks[i3 - 1].value) {
      result.push(ticks[i3]);
    }
  }
  return result;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale;

// node_modules/echarts/lib/scale/Log.js
var scaleProto = Scale_default.prototype;
var intervalScaleProto = Interval_default.prototype;
var roundingErrorFix = round2;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow2 = Math.pow;
var mathLog = Math.log;
var LogScale = function(_super) {
  __extends(LogScale2, _super);
  function LogScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    _this.base = 10;
    _this._originalScale = new Interval_default;
    _this._interval = 0;
    return _this;
  }
  LogScale2.prototype.getTicks = function(expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent3 = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map(ticks, function(tick) {
      var val = tick.value;
      var powVal = round2(mathPow2(this.base, val));
      powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };
  LogScale2.prototype.setExtent = function(start2, end2) {
    var base2 = mathLog(this.base);
    start2 = mathLog(Math.max(0, start2)) / base2;
    end2 = mathLog(Math.max(0, end2)) / base2;
    intervalScaleProto.setExtent.call(this, start2, end2);
  };
  LogScale2.prototype.getExtent = function() {
    var base2 = this.base;
    var extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow2(base2, extent3[0]);
    extent3[1] = mathPow2(base2, extent3[1]);
    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  };
  LogScale2.prototype.unionExtent = function(extent3) {
    this._originalScale.unionExtent(extent3);
    var base2 = this.base;
    extent3[0] = mathLog(extent3[0]) / mathLog(base2);
    extent3[1] = mathLog(extent3[1]) / mathLog(base2);
    scaleProto.unionExtent.call(this, extent3);
  };
  LogScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    var interval = quantity(span);
    var err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    var niceExtent = [round2(mathCeil(extent3[0] / interval) * interval), round2(mathFloor(extent3[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };
  LogScale2.prototype.calcNiceExtent = function(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };
  LogScale2.prototype.parse = function(val) {
    return val;
  };
  LogScale2.prototype.contain = function(val) {
    val = mathLog(val) / mathLog(this.base);
    return contain2(val, this._extent);
  };
  LogScale2.prototype.normalize = function(val) {
    val = mathLog(val) / mathLog(this.base);
    return normalize2(val, this._extent);
  };
  LogScale2.prototype.scale = function(val) {
    val = scale3(val, this._extent);
    return mathPow2(this.base, val);
  };
  LogScale2.type = "log";
  return LogScale2;
}(Scale_default);
var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;

// node_modules/echarts/lib/coord/scaleRawExtentInfo.js
var ScaleRawExtentInfo = function() {
  function ScaleRawExtentInfo2(scale4, model, originalExtent) {
    this._prepareParams(scale4, model, originalExtent);
  }
  ScaleRawExtentInfo2.prototype._prepareParams = function(scale4, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale4.type === "ordinal";
    this._needCrossZero = scale4.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    var axisMinValue = model.get("min", true);
    if (axisMinValue == null) {
      axisMinValue = model.get("startValue", true);
    }
    var modelMinRaw = this._modelMinRaw = axisMinValue;
    if (isFunction(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw);
    }
    var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get("boundaryGap");
      var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        if (true) {
          console.warn("Boolean type for boundaryGap is only " + "allowed for ordinal axis. Please use string in " + 'percentage instead, e.g., "20%". Currently, ' + "boundaryGap is set to be 0.");
        }
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)];
      }
    }
  };
  ScaleRawExtentInfo2.prototype.calculate = function() {
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    var minFixed = min3 != null;
    var maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  };
  ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
    if (true) {
      assert(!this.frozen);
    }
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  };
  ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
    if (true) {
      assert(!this.frozen && this[attr] == null);
    }
    this[attr] = val;
  };
  ScaleRawExtentInfo2.prototype.freeze = function() {
    this.frozen = true;
  };
  return ScaleRawExtentInfo2;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(scale4, model, originalExtent) {
  var rawExtentInfo = scale4.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale4, model, originalExtent);
  scale4.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale4, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale4.parse(minMax);
}

// node_modules/echarts/lib/coord/axisHelper.js
function getScaleExtent(scale4, model) {
  var scaleType = scale4.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale4, model, scale4.getExtent()).calculate();
  scale4.setBlank(rawExtentResult.isBlank);
  var min3 = rawExtentResult.min;
  var max3 = rawExtentResult.max;
  var ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries_1) {
      var barWidthAndOffset = makeColumnLayout(barSeriesModels);
      var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  var axisExtent = model.axis.getExtent();
  var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === undefined) {
    return {
      min: min3,
      max: max3
    };
  }
  var minOverflow = Infinity;
  each(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow;
  var oldRange = max3 - min3;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min3,
    max: max3
  };
}
function niceScaleExtent(scale4, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale4, model);
  var extent3 = extentInfo.extent;
  var splitNumber = model.get("splitNumber");
  if (scale4 instanceof Log_default) {
    scale4.base = model.get("logBase");
  }
  var scaleType = scale4.type;
  var interval = model.get("interval");
  var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale4.setExtent(extent3[0], extent3[1]);
  scale4.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale4.setInterval && scale4.setInterval(interval);
  }
}
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new Ordinal_default({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new Time_default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale_default.getClass(axisType) || Interval_default);
    }
  }
}
function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min3 = dataExtent[0];
  var max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get("formatter");
  var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text = tpl.replace("{value}", label != null ? label : "");
        return text;
      };
    }(labelFormatter);
  } else if (isFunction(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale4 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale4.isBlank()) {
    return;
  }
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale4.getExtent();
  if (scale4 instanceof Ordinal_default) {
    tickCount = scale4.count();
  } else {
    realNumberScaleTicks = scale4.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (var i3 = 0;i3 < tickCount; i3 += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i3] : {
      value: categoryScaleExtent[0] + i3
    };
    var label = labelFormatter(tick, i3);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  var rotateRadians = rotate2 * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  var rotatedRect = new BoundingRect_default(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  var interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  var dataDimMap = {};
  each(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys(dataDimMap);
}

// node_modules/echarts/lib/coord/cartesian/Cartesian.js
var Cartesian = function() {
  function Cartesian2(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian_default = Cartesian;

// node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale4) {
  return scale4.type === "interval" || scale4.type === "time";
}
var Cartesian2D = function(_super) {
  __extends(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end2[0] - start2[0]) / xScaleSpan;
    var scaleY = (end2[1] - start2[1]) / yScaleSpan;
    var translateX = start2[0] - xScaleExtent[0] * scaleX;
    var translateY = start2[1] - yScaleExtent[0] * scaleY;
    var m5 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m5);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };
  Cartesian2D2.prototype.containData = function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  };
  Cartesian2D2.prototype.containZone = function(data1, data2) {
    var zoneDiag1 = this.dataToPoint(data1);
    var zoneDiag2 = this.dataToPoint(data2);
    var area = this.getArea();
    var zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  };
  Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
    out2 = out2 || [];
    var xVal = data[0];
    var yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform(out2, data, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  };
  Cartesian2D2.prototype.clampData = function(data, out2) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x3 = xScale.parse(data[0]);
    var y3 = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x3), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y3), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  };
  Cartesian2D2.prototype.pointToData = function(point, clamp2) {
    var out2 = [];
    if (this._invTransform) {
      return applyTransform(out2, point, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function(tolerance) {
    tolerance = tolerance || 0;
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x3 = Math.min(xExtent[0], xExtent[1]) - tolerance;
    var y3 = Math.min(yExtent[0], yExtent[1]) - tolerance;
    var width = Math.max(xExtent[0], xExtent[1]) - x3 + tolerance;
    var height = Math.max(yExtent[0], yExtent[1]) - y3 + tolerance;
    return new BoundingRect_default(x3, y3, width, height);
  };
  return Cartesian2D2;
}(Cartesian_default);
var Cartesian2D_default = Cartesian2D;

// node_modules/echarts/lib/coord/axisTickLabelBuilder.js
var inner6 = makeInner();
function tickValuesToNumbers(axis, values) {
  var nums = map(values, function(val) {
    return axis.scale.parse(val);
  });
  if (axis.type === "time" && nums.length > 0) {
    nums.sort();
    nums.unshift(nums[0]);
    nums.push(nums[nums.length - 1]);
  }
  return nums;
}
function createAxisLabels(axis) {
  var custom = axis.getLabelModel().get("customValues");
  if (custom) {
    var labelFormatter_1 = makeLabelFormatter(axis);
    var extent_1 = axis.scale.getExtent();
    var tickNumbers = tickValuesToNumbers(axis, custom);
    var ticks = filter(tickNumbers, function(val) {
      return val >= extent_1[0] && val <= extent_1[1];
    });
    return {
      labels: map(ticks, function(numval) {
        var tick = {
          value: numval
        };
        return {
          formattedLabel: labelFormatter_1(tick),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: numval
        };
      })
    };
  }
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  var custom = axis.getTickModel().get("customValues");
  if (custom) {
    var extent_2 = axis.scale.getExtent();
    var tickNumbers = tickValuesToNumbers(axis, custom);
    return {
      ticks: filter(tickNumbers, function(val) {
        return val >= extent_2[0] && val <= extent_2[1];
      })
    };
  }
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
    ticks: map(axis.scale.getTicks(), function(tick) {
      return tick.value;
    })
  };
}
function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, "labels");
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  var labels;
  var numericLabelInterval;
  if (isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, "ticks");
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  var ticks;
  var tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner6(axis)[prop] || (inner6(axis)[prop] = []);
}
function listCacheGet(cache2, key) {
  for (var i3 = 0;i3 < cache2.length; i3++) {
    if (cache2[i3].key === key) {
      return cache2[i3].value;
    }
  }
}
function listCacheSet(cache2, key, value2) {
  cache2.push({
    key,
    value: value2
  });
  return value2;
}
function makeAutoCategoryInterval(axis) {
  var result = inner6(axis).autoInterval;
  return result != null ? result : inner6(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  var step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0;
  for (;tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0;
    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  var dw = maxW / unitW;
  var dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache2 = inner6(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache2.lastAutoInterval;
  var lastTickCount = cache2.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache2.axisExtent0 === axisExtent[0] && cache2.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache2.lastTickCount = tickCount;
    cache2.lastAutoInterval = interval;
    cache2.axisExtent0 = axisExtent[0];
    cache2.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = [];
  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  var tickValue = startTick;
  for (;tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    var tickObj = {
      value: tickValue2
    };
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each(ordinalScale.getTicks(), function(tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}

// node_modules/echarts/lib/coord/Axis.js
var NORMALIZED_EXTENT = [0, 1];
var Axis = function() {
  function Axis2(dim, scale4, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale4;
    this._extent = extent3 || [0, 0];
  }
  Axis2.prototype.contain = function(coord) {
    var extent3 = this._extent;
    var min3 = Math.min(extent3[0], extent3[1]);
    var max3 = Math.max(extent3[0], extent3[1]);
    return coord >= min3 && coord <= max3;
  };
  Axis2.prototype.containData = function(data) {
    return this.scale.contain(data);
  };
  Axis2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Axis2.prototype.getPixelPrecision = function(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  Axis2.prototype.setExtent = function(start2, end2) {
    var extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  };
  Axis2.prototype.dataToCoord = function(data, clamp2) {
    var extent3 = this._extent;
    var scale4 = this.scale;
    data = scale4.normalize(data);
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    return linearMap(data, NORMALIZED_EXTENT, extent3, clamp2);
  };
  Axis2.prototype.coordToData = function(coord, clamp2) {
    var extent3 = this._extent;
    var scale4 = this.scale;
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    var t4 = linearMap(coord, extent3, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t4);
  };
  Axis2.prototype.pointToData = function(point, clamp2) {
    return;
  };
  Axis2.prototype.getTicksCoords = function(opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };
  Axis2.prototype.getMinorTicksCoords = function() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    var minorTickModel = this.model.getModel("minorTick");
    var splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
      return map(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };
  Axis2.prototype.getViewLabels = function() {
    return createAxisLabels(this).labels;
  };
  Axis2.prototype.getLabelModel = function() {
    return this.model.getModel("axisLabel");
  };
  Axis2.prototype.getTickModel = function() {
    return this.model.getModel("axisTick");
  };
  Axis2.prototype.getBandWidth = function() {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  };
  Axis2.prototype.calculateCategoryInterval = function() {
    return calculateCategoryInterval(this);
  };
  return Axis2;
}();
function fixExtentWithBands(extent3, nTick) {
  var size = extent3[1] - extent3[0];
  var len2 = nTick;
  var margin = size / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  var ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  var axisExtent = axis.getExtent();
  var last;
  var diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[1],
      tickValue: ticksCoords[0].tickValue
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,
      tickValue: dataExtent[1] + 1
    };
    ticksCoords.push(last);
  }
  var inverse = axisExtent[0] > axisExtent[1];
  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }
  if (littleThan(axisExtent[1], last.coord)) {
    clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }
  function littleThan(a3, b) {
    a3 = round2(a3);
    b = round2(b);
    return inverse ? a3 > b : a3 < b;
  }
}
var Axis_default = Axis;

// node_modules/echarts/lib/coord/cartesian/Axis2D.js
var Axis2D = function(_super) {
  __extends(Axis2D2, _super);
  function Axis2D2(dim, scale4, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale4, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position = this.position;
    return position === "top" || position === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  };
  Axis2D2.prototype.pointToData = function(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };
  return Axis2D2;
}(Axis_default);
var Axis2D_default = Axis2D;

// node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js
function layout2(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout3 = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get("offset") || 0;
  var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout3.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
  layout3.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout3.labelDirection = layout3.tickDirection = layout3.nameDirection = dirMap[rawAxisPosition];
  layout3.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout3.tickDirection = -layout3.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout3.labelDirection = -layout3.labelDirection;
  }
  var labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout3.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout3.z2 = 1;
  return layout3;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each(axisModelMap, function(v3, key) {
    var axisType = key.replace(/Model$/, "");
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    if (true) {
      if (!axisModel) {
        throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
      }
    }
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}

// node_modules/echarts/lib/coord/axisAlignTicks.js
var mathLog2 = Math.log;
function alignScaleTicks(scale4, axisModel, alignToScale) {
  var intervalScaleProto2 = Interval_default.prototype;
  var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale4, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale4.type === "log") {
    var logBase = mathLog2(scale4.base);
    rawExtent = [mathLog2(rawExtent[0]) / logBase, mathLog2(rawExtent[1]) / logBase];
  }
  scale4.setExtent(rawExtent[0], rawExtent[1]);
  scale4.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent3 = intervalScaleProto2.getExtent.call(scale4);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  var interval = intervalScaleProto2.getInterval.call(scale4);
  var min3 = rawExtent[0];
  var max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale4.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round2(max3 - range);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round2(range);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round2(range);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale4, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto2.setInterval.call(scale4, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale4, min3 + interval, max3 - interval);
  }
  if (true) {
    var ticks = intervalScaleProto2.getTicks.call(scale4);
    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn("The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + " and alignTicks: true");
    }
  }
}

// node_modules/echarts/lib/coord/cartesian/Grid.js
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys(axes);
      var len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i3 = len2 - 1;i3 >= 0; i3--) {
        var idx = +axesIndices[i3];
        var axis = axes[idx];
        var model = axis.model;
        var scale4 = axis.scale;
        if (isIntervalOrLogScale(scale4) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale4, model);
          if (isIntervalOrLogScale(scale4)) {
            alignTo = axis;
          }
        }
      }
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject2(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i3 = 0, coordList = this._coordsList;i3 < coordList.length; i3++) {
      if (coordList[i3].getAxis("x").index === xAxisIndex || coordList[i3].getAxis("y").index === yAxisIndex) {
        return coordList[i3];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value2) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value2) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value2)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value2) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value2) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value2)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each(axesMap.x, function(xAxis, xAxisIndex) {
      each(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D_default(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;
        _this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D_default(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid = new Grid2(gridModel, ecModel, api);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      if (true) {
        if (!gridModel) {
          throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
        }
        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error("xAxis and yAxis must use the same grid");
        }
      }
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid_default = Grid;

// node_modules/echarts/lib/component/axis/AxisBuilder.js
var PI7 = Math.PI;
var AxisBuilder = function() {
  function AxisBuilder2(axisModel, opt) {
    this.group = new Group_default;
    this.opt = opt;
    this.axisModel = axisModel;
    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function() {
        return true;
      }
    });
    var transformGroup = new Group_default({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  AxisBuilder2.prototype.hasBuilder = function(name) {
    return !!builders[name];
  };
  AxisBuilder2.prototype.add = function(name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  };
  AxisBuilder2.prototype.getGroup = function() {
    return this.group;
  };
  AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI7)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI7) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  AxisBuilder2.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  return AxisBuilder2;
}();
var builders = {
  axisLine: function(opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    var extent3 = axisModel.axis.getExtent();
    var matrix = transformGroup.transform;
    var pt12 = [extent3[0], 0];
    var pt22 = [extent3[1], 0];
    var inverse = pt12[0] > pt22[0];
    if (matrix) {
      applyTransform(pt12, pt12, matrix);
      applyTransform(pt22, pt22, matrix);
    }
    var lineStyle = extend({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    var line = new Line_default({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    subPixelOptimizeLine2(line.shape, line.style.lineWidth);
    line.anid = "line";
    group.add(line);
    var arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString(arrowSize) || isNumber(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index) {
        if (arrows[index] !== "none" && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
          var r3 = point.r + point.offset;
          var pt = inverse ? pt22 : pt12;
          symbol.attr({
            rotation: point.rotate,
            x: pt[0] + r3 * Math.cos(opt.rotation),
            y: pt[1] - r3 * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function(opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      var labelList = prepareLayoutList(map(labelEls, function(label) {
        return {
          label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function(opt, axisModel, group, transformGroup) {
    var name = retrieve(opt.axisName, axisModel.get("name"));
    if (!name) {
      return;
    }
    var nameLocation = axisModel.get("nameLocation");
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel("nameTextStyle");
    var gap = axisModel.get("nameGap") || 0;
    var extent3 = axisModel.axis.getExtent();
    var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    var pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    var labelLayout;
    var nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI7 / 180;
    }
    var axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
    } else {
      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get("nameTruncate", true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new Text_default({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle(textStyleModel, {
        text: name,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent3[0] > extent3[1];
  var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI7 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI7 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI7 * 1.5 && rotationDiff > PI7 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick2 = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick2);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function isTwoLabelOverlapped(current, next) {
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  var mRotationBack = identity([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt12 = [];
  var pt22 = [];
  for (var i3 = 0;i3 < ticksCoords.length; i3++) {
    var tickCoord = ticksCoords[i3].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform(pt12, pt12, tickTransform);
      applyTransform(pt22, pt22, tickTransform);
    }
    var tickEl = new Line_default({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    subPixelOptimizeLine2(tickEl.shape, tickEl.style.lineWidth);
    tickEl.anid = anidPrefix + "_" + ticksCoords[i3].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel("axisTick");
  var shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  var lineStyleModel = tickModel.getModel("lineStyle");
  var tickEndCoord = opt.tickDirection * tickModel.get("length");
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (var i3 = 0;i3 < ticksEls.length; i3++) {
    group.add(ticksEls[i3]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  var minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  var lineStyleModel = minorTickModel.getModel("lineStyle");
  var tickEndCoord = tickDirection * minorTickModel.get("length");
  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (var i3 = 0;i3 < minorTicksCoords.length; i3++) {
    var minorTicksEls = createTicks(minorTicksCoords[i3], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i3);
    for (var k3 = 0;k3 < minorTicksEls.length; k3++) {
      group.add(minorTicksEls[k3]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show || axis.scale.isBlank()) {
    return;
  }
  var labelModel = axisModel.getModel("axisLabel");
  var labelMargin = labelModel.get("margin");
  var labels = axis.getViewLabels();
  var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI7 / 180;
  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get("triggerEvent");
  each(labels, function(labelItem, index) {
    var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];
      if (isObject2(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model_default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    var tickCoord = axis.dataToCoord(tickValue);
    var align = itemLabelModel.getShallow("align", true) || labelLayout.textAlign;
    var alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
    var alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
    var verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign;
    var verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
    var verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
    var textEl = new Text_default({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle(itemLabelModel, {
        text: formattedLabel,
        align: index === 0 ? alignMin : index === labels.length - 1 ? alignMax : align,
        verticalAlign: index === 0 ? verticalAlignMin : index === labels.length - 1 ? verticalAlignMax : verticalAlign,
        fill: isFunction(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: formattedLabel,
      formatterParamsExtra: {
        isTruncated: function() {
          return textEl.isTruncated;
        },
        value: rawLabel,
        tickIndex: index
      }
    });
    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index;
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder_default = AxisBuilder;

// node_modules/echarts/lib/component/axisPointer/modelHelper.js
function collect(ecModel, api) {
  var result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent("tooltip");
  var globalAxisPointerModel = ecModel.getComponent("axisPointer");
  var linksOption = globalAxisPointerModel.get("link", true) || [];
  var linkGroups = [];
  each(api.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      var triggerAxis = baseTooltipModel.get("trigger") === "axis";
      var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
      }
      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get("snap");
      var triggerEmphasis = axisPointerModel.get("triggerEmphasis");
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === "category";
      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        triggerEmphasis,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
  var volatileOption = {};
  each(fields, function(field) {
    volatileOption[field] = clone(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  var labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model_default(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      var axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;
  for (var i3 = 0;i3 < linksOption.length; i3++) {
    var linkOption = linksOption[i3] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i3;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  if (!axisInfo) {
    return;
  }
  var axisPointerModel = axisInfo.axisPointerModel;
  var scale4 = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get("status");
  var value2 = axisPointerModel.get("value");
  if (value2 != null) {
    value2 = scale4.parse(value2);
  }
  var useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  var extent3 = scale4.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value2 == null || value2 > extent3[1]) {
    value2 = extent3[1];
  }
  if (value2 < extent3[0]) {
    value2 = extent3[0];
  }
  option.value = value2;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}

// node_modules/echarts/lib/component/axis/AxisView.js
var axisPointerClazz = {};
var AxisView = function(_super) {
  __extends(AxisView2, _super);
  function AxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisView2.type;
    return _this;
  }
  AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.axisPointerClass && fixValue(axisModel);
    _super.prototype.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  AxisView2.prototype.remove = function(ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  AxisView2.prototype.dispose = function(ecModel, api) {
    this._disposeAxisPointer(api);
    _super.prototype.dispose.apply(this, arguments);
  };
  AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
    var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz)).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };
  AxisView2.prototype._disposeAxisPointer = function(api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };
  AxisView2.registerAxisPointerClass = function(type, clazz) {
    if (true) {
      if (axisPointerClazz[type]) {
        throw new Error("axisPointer " + type + " exists");
      }
    }
    axisPointerClazz[type] = clazz;
  };
  AxisView2.getAxisPointerClass = function(type) {
    return type && axisPointerClazz[type];
  };
  AxisView2.type = "axis";
  return AxisView2;
}(Component_default2);
var AxisView_default = AxisView;

// node_modules/echarts/lib/component/axis/axisSplitHelper.js
var inner7 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  var splitAreaModel = axisModel.getModel("splitArea");
  var areaStyleModel = splitAreaModel.getModel("areaStyle");
  var areaColors = areaStyleModel.get("color");
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner7(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;
  if (lastSplitAreaColors) {
    for (var i3 = 0;i3 < ticksCoords.length; i3++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i3].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i3) % areaColorsLen;
        break;
      }
    }
  }
  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray(areaColors) ? areaColors : [areaColors];
  for (var i3 = 1;i3 < ticksCoords.length; i3++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i3].coord);
    var x3 = undefined;
    var y3 = undefined;
    var width = undefined;
    var height = undefined;
    if (axis.isHorizontal()) {
      x3 = prev;
      y3 = gridRect.y;
      width = tickCoord - x3;
      height = gridRect.height;
      prev = x3 + width;
    } else {
      x3 = gridRect.x;
      y3 = prev;
      width = gridRect.width;
      height = tickCoord - y3;
      prev = y3 + height;
    }
    var tickValue = ticksCoords[i3 - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect_default({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x: x3,
        y: y3,
        width,
        height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner7(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner7(axisView).splitAreaColors = null;
}

// node_modules/echarts/lib/component/axis/CartesianAxisView.js
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
var CartesianAxisView = function(_super) {
  __extends(CartesianAxisView2, _super);
  function CartesianAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianAxisView2.type;
    _this.axisPointerClass = "CartesianAxisPointer";
    return _this;
  }
  CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default;
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var gridModel = axisModel.getCoordSysModel();
    var layout3 = layout2(gridModel, axisModel);
    var axisBuilder = new AxisBuilder_default(axisModel, extend({
      handleAutoShown: function(elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();
        for (var i3 = 0;i3 < cartesians.length; i3++) {
          if (isIntervalOrLogScale(cartesians[i3].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout3));
    each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each(selfBuilderAttrs, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  CartesianAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  CartesianAxisView2.type = "cartesianAxis";
  return CartesianAxisView2;
}(AxisView_default);
var axisElementBuilders = {
  splitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var showMinLine = splitLineModel.get("showMinLine") !== false;
    var showMaxLine = splitLineModel.get("showMaxLine") !== false;
    lineColors = isArray(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p22 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i3 = 0;i3 < ticksCoords.length; i3++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i3].coord);
      if (i3 === 0 && !showMinLine || i3 === ticksCoords.length - 1 && !showMaxLine) {
        continue;
      }
      var tickValue = ticksCoords[i3].tickValue;
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p22[0] = tickCoord;
        p22[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p22[0] = gridRect.x + gridRect.width;
        p22[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      var line = new Line_default({
        anid: tickValue != null ? "line_" + tickValue : null,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p22[0],
          y2: p22[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      });
      subPixelOptimizeLine2(line.shape, lineStyle.lineWidth);
      axisGroup.add(line);
    }
  },
  minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var p1 = [];
    var p22 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i3 = 0;i3 < minorTicksCoords.length; i3++) {
      for (var k3 = 0;k3 < minorTicksCoords[i3].length; k3++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i3][k3].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p22[0] = tickCoord;
          p22[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p22[0] = gridRect.x + gridRect.width;
          p22[1] = tickCoord;
        }
        var line = new Line_default({
          anid: "minor_line_" + minorTicksCoords[i3][k3].tickValue,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p22[0],
            y2: p22[1]
          },
          style: lineStyle,
          silent: true
        });
        subPixelOptimizeLine2(line.shape, lineStyle.lineWidth);
        axisGroup.add(line);
      }
    }
  },
  splitArea: function(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView = function(_super) {
  __extends(CartesianXAxisView2, _super);
  function CartesianXAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView2.type;
    return _this;
  }
  CartesianXAxisView2.type = "xAxis";
  return CartesianXAxisView2;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
  __extends(CartesianYAxisView2, _super);
  function CartesianYAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView.type;
    return _this;
  }
  CartesianYAxisView2.type = "yAxis";
  return CartesianYAxisView2;
}(CartesianAxisView);

// node_modules/echarts/lib/component/grid/installSimple.js
var GridView = function(_super) {
  __extends(GridView2, _super);
  function GridView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    return _this;
  }
  GridView2.prototype.render = function(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect_default({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };
  GridView2.type = "grid";
  return GridView2;
}(Component_default2);
var extraOption = {
  offset: 0
};
function install4(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel_default);
  registers.registerCoordinateSystem("cartesian2d", Grid_default);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}

// node_modules/echarts/lib/chart/radar/radarLayout.js
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    var data = seriesModel.getData();
    var points2 = [];
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    var axes = coordSys.getIndicatorAxes();
    each(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points2[dataIndex] = points2[dataIndex] || [];
        var point = coordSys.dataToPoint(val, axisIndex);
        points2[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      var firstPoint = find(points2[idx], function(point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys);
      points2[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points2[idx]);
    });
  });
}
function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}

// node_modules/echarts/lib/chart/radar/backwardCompat.js
function radarBackwardCompat(option) {
  var polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    var polarNotRadar_1 = [];
    each(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar_1.push(polarOpt);
      }
    });
    option.polar = polarNotRadar_1;
  }
  each(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}

// node_modules/echarts/lib/chart/radar/RadarView.js
var RadarView = function(_super) {
  __extends(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(seriesModel, ecModel, api) {
    var polar = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    function createSymbol2(data2, idx) {
      var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      var symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
      var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (var i3 = 0;i3 < newPoints.length - 1; i3++) {
        var symbolPath = createSymbol2(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i3;
          if (oldPoints[i3]) {
            symbolPath.setPosition(oldPoints[i3]);
            exports_graphic[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i3][0],
              y: newPoints[i3][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i3]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points2) {
      return map(points2, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      var points2 = data.getItemLayout(idx);
      if (!points2) {
        return;
      }
      var polygon = new Polygon_default;
      var polyline = new Polyline_default;
      var target = {
        shape: {
          points: points2
        }
      };
      polygon.shape.points = getInitialPoints(points2);
      polyline.shape.points = getInitialPoints(points2);
      initProps(polygon, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      var itemGroup = new Group_default;
      var symbolGroup = new Group_default;
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points2, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      var itemGroup = oldData.getItemGraphicEl(oldIdx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon);
      saveOldStyle(polyline);
      updateProps(polyline, target, seriesModel);
      updateProps(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      var itemModel = data.getItemModel(idx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var itemStyle = data.getItemVisual(idx, "style");
      var color = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon, itemModel, "areaStyle");
      var areaStyleModel = itemModel.getModel("areaStyle");
      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      each(["emphasis", "select", "blur"], function(stateName) {
        var stateModel = itemModel.getModel([stateName, "areaStyle"]);
        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: color,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      var emphasisModel = itemModel.getModel("emphasis");
      var itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof Image_default) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color);
          symbolPath.style.strokeNoScale = true;
        }
        var pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone(itemHoverStyle);
        var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  };
  RadarView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  RadarView2.type = "radar";
  return RadarView2;
}(Chart_default);
var RadarView_default = RadarView;

// node_modules/echarts/lib/chart/radar/RadarSeries.js
var RadarSeriesModel = function(_super) {
  __extends(RadarSeriesModel2, _super);
  function RadarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  RadarSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  };
  RadarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  };
  RadarSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var coordSys = this.coordinateSystem;
    var indicatorAxes = coordSys.getIndicatorAxes();
    var name = this.getData().getName(dataIndex);
    var nameToDisplay = name === "" ? this.name : name;
    var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map(indicatorAxes, function(axis) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  };
  RadarSeriesModel2.prototype.getTooltipPosition = function(dataIndex) {
    if (dataIndex != null) {
      var data_1 = this.getData();
      var coordSys = this.coordinateSystem;
      var values = data_1.getValues(map(coordSys.dimensions, function(dim) {
        return data_1.mapDimension(dim);
      }), dataIndex);
      for (var i3 = 0, len2 = values.length;i3 < len2; i3++) {
        if (!isNaN(values[i3])) {
          var indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i3].dataToCoord(values[i3]), i3);
        }
      }
    }
  };
  RadarSeriesModel2.type = "series.radar";
  RadarSeriesModel2.dependencies = ["radar"];
  RadarSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "radar",
    legendHoverLink: true,
    radarIndex: 0,
    lineStyle: {
      width: 2,
      type: "solid",
      join: "round"
    },
    label: {
      position: "top"
    },
    symbolSize: 8
  };
  return RadarSeriesModel2;
}(Series_default);
var RadarSeries_default = RadarSeriesModel;

// node_modules/echarts/lib/coord/radar/RadarModel.js
var valueAxisDefault = axisDefault_default.value;
function defaultsShow(opt, show) {
  return defaults({
    show
  }, opt);
}
var RadarModel = function(_super) {
  __extends(RadarModel2, _super);
  function RadarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarModel2.type;
    return _this;
  }
  RadarModel2.prototype.optionUpdated = function() {
    var boundaryGap = this.get("boundaryGap");
    var splitNumber = this.get("splitNumber");
    var scale4 = this.get("scale");
    var axisLine = this.get("axisLine");
    var axisTick = this.get("axisTick");
    var axisLabel = this.get("axisLabel");
    var nameTextStyle = this.get("axisName");
    var showName = this.get(["axisName", "show"]);
    var nameFormatter = this.get(["axisName", "formatter"]);
    var nameGap = this.get("axisNameGap");
    var triggerEvent = this.get("triggerEvent");
    var indicatorModels = map(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      var iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      var innerIndicatorOpt = merge(clone(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale4,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (isString(nameFormatter)) {
        var indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      var model = new Model_default(innerIndicatorOpt, null, this.ecModel);
      mixin2(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  };
  RadarModel2.prototype.getIndicatorModels = function() {
    return this._indicatorModels;
  };
  RadarModel2.type = "radar";
  RadarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "75%",
    startAngle: 90,
    axisName: {
      show: true
    },
    boundaryGap: [0, 0],
    splitNumber: 5,
    axisNameGap: 15,
    scale: false,
    shape: "polygon",
    axisLine: merge({
      lineStyle: {
        color: "#bbb"
      }
    }, valueAxisDefault.axisLine),
    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
    indicator: []
  };
  return RadarModel2;
}(Component_default);
var RadarModel_default = RadarModel;

// node_modules/echarts/lib/component/radar/RadarView.js
var axisBuilderAttrs2 = ["axisLine", "axisTickLabel", "axisName"];
var RadarView2 = function(_super) {
  __extends(RadarView3, _super);
  function RadarView3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView3.type;
    return _this;
  }
  RadarView3.prototype.render = function(radarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    this._buildAxes(radarModel);
    this._buildSplitLineAndArea(radarModel);
  };
  RadarView3.prototype._buildAxes = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    var axisBuilders = map(indicatorAxes, function(indicatorAxis) {
      var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      var axisBuilder = new AxisBuilder_default(indicatorAxis.model, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each(axisBuilders, function(axisBuilder) {
      each(axisBuilderAttrs2, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  };
  RadarView3.prototype._buildSplitLineAndArea = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    var shape = radarModel.get("shape");
    var splitLineModel = radarModel.getModel("splitLine");
    var splitAreaModel = radarModel.getModel("splitArea");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var showSplitLine = splitLineModel.get("show");
    var showSplitArea = splitAreaModel.get("show");
    var splitLineColors = lineStyleModel.get("color");
    var splitAreaColors = areaStyleModel.get("color");
    var splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];
    var splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    var splitLines = [];
    var splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      var colorIndex2 = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
      return colorIndex2;
    }
    if (shape === "circle") {
      var ticksRadius = indicatorAxes[0].getTicksCoords();
      var cx = radar.cx;
      var cy = radar.cy;
      for (var i3 = 0;i3 < ticksRadius.length; i3++) {
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i3);
          splitLines[colorIndex].push(new Circle_default({
            shape: {
              cx,
              cy,
              r: ticksRadius[i3].coord
            }
          }));
        }
        if (showSplitArea && i3 < ticksRadius.length - 1) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i3);
          splitAreas[colorIndex].push(new Ring_default({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i3].coord,
              r: ticksRadius[i3 + 1].coord
            }
          }));
        }
      }
    } else {
      var realSplitNumber_1;
      var axesTicksPoints = map(indicatorAxes, function(indicatorAxis, idx) {
        var ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
        return map(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      var prevPoints = [];
      for (var i3 = 0;i3 <= realSplitNumber_1; i3++) {
        var points2 = [];
        for (var j3 = 0;j3 < indicatorAxes.length; j3++) {
          points2.push(axesTicksPoints[j3][i3]);
        }
        if (points2[0]) {
          points2.push(points2[0].slice());
        } else {
          if (true) {
            console.error("Can't draw value axis " + i3);
          }
        }
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i3);
          splitLines[colorIndex].push(new Polyline_default({
            shape: {
              points: points2
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i3 - 1);
          splitAreas[colorIndex].push(new Polygon_default({
            shape: {
              points: points2.concat(prevPoints)
            }
          }));
        }
        prevPoints = points2.slice().reverse();
      }
    }
    var lineStyle = lineStyleModel.getLineStyle();
    var areaStyle = areaStyleModel.getAreaStyle();
    each(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath2(splitAreas2, {
        style: defaults({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath2(splitLines2, {
        style: defaults({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  };
  RadarView3.type = "radar";
  return RadarView3;
}(Component_default2);
var RadarView_default2 = RadarView2;

// node_modules/echarts/lib/coord/radar/IndicatorAxis.js
var IndicatorAxis = function(_super) {
  __extends(IndicatorAxis2, _super);
  function IndicatorAxis2(dim, scale4, radiusExtent) {
    var _this = _super.call(this, dim, scale4, radiusExtent) || this;
    _this.type = "value";
    _this.angle = 0;
    _this.name = "";
    return _this;
  }
  return IndicatorAxis2;
}(Axis_default);
var IndicatorAxis_default = IndicatorAxis;

// node_modules/echarts/lib/coord/radar/Radar.js
var Radar = function() {
  function Radar2(radarModel, ecModel, api) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = "indicator_" + idx;
      var indicatorAxis = new IndicatorAxis_default(dim, new Interval_default);
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
  }
  Radar2.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar2.prototype.dataToPoint = function(value2, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value2), indicatorIndex);
  };
  Radar2.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x3 = this.cx + coord * Math.cos(angle);
    var y3 = this.cy - coord * Math.sin(angle);
    return [x3, y3];
  };
  Radar2.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i3 = 0;i3 < this._indicatorAxes.length; i3++) {
      var indicatorAxis = this._indicatorAxes[i3];
      var diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i3;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };
  Radar2.prototype.resize = function(radarModel, api) {
    var center2 = radarModel.get("center");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = parsePercent2(center2[0], viewWidth);
    this.cy = parsePercent2(center2[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    var radius = radarModel.get("radius");
    if (isString(radius) || isNumber(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent2(radius[0], viewSize);
    this.r = parsePercent2(radius[1], viewSize);
    each(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };
  Radar2.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    each(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get("splitNumber");
    var dummyScale = new Interval_default;
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  };
  Radar2.prototype.convertToPixel = function(ecModel, finder, value2) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.containPoint = function(point) {
    console.warn("Not implemented.");
    return false;
  };
  Radar2.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      var radar = new Radar2(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  };
  Radar2.dimensions = [];
  return Radar2;
}();
var Radar_default = Radar;

// node_modules/echarts/lib/component/radar/install.js
function install5(registers) {
  registers.registerCoordinateSystem("radar", Radar_default);
  registers.registerComponentModel(RadarModel_default);
  registers.registerComponentView(RadarView_default2);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}

// node_modules/echarts/lib/chart/radar/install.js
function install6(registers) {
  use(install5);
  registers.registerChartView(RadarView_default);
  registers.registerSeriesModel(RadarSeries_default);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}
// node_modules/echarts/lib/chart/gauge/PointerPath.js
var PointerShape = function() {
  function PointerShape2() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }
  return PointerShape2;
}();
var PointerPath = function(_super) {
  __extends(PointerPath2, _super);
  function PointerPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "pointer";
    return _this;
  }
  PointerPath2.prototype.getDefaultShape = function() {
    return new PointerShape;
  };
  PointerPath2.prototype.buildPath = function(ctx, shape) {
    var mathCos5 = Math.cos;
    var mathSin5 = Math.sin;
    var r3 = shape.r;
    var width = shape.width;
    var angle = shape.angle;
    var x3 = shape.x - mathCos5(angle) * width * (width >= r3 / 3 ? 1 : 2);
    var y3 = shape.y - mathSin5(angle) * width * (width >= r3 / 3 ? 1 : 2);
    angle = shape.angle - Math.PI / 2;
    ctx.moveTo(x3, y3);
    ctx.lineTo(shape.x + mathCos5(angle) * width, shape.y + mathSin5(angle) * width);
    ctx.lineTo(shape.x + mathCos5(shape.angle) * r3, shape.y + mathSin5(shape.angle) * r3);
    ctx.lineTo(shape.x - mathCos5(angle) * width, shape.y - mathSin5(angle) * width);
    ctx.lineTo(x3, y3);
  };
  return PointerPath2;
}(Path_default);
var PointerPath_default = PointerPath;

// node_modules/echarts/lib/chart/gauge/GaugeView.js
function parsePosition(seriesModel, api) {
  var center2 = seriesModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  var size = Math.min(width, height);
  var cx = parsePercent2(center2[0], api.getWidth());
  var cy = parsePercent2(center2[1], api.getHeight());
  var r3 = parsePercent2(seriesModel.get("radius"), size / 2);
  return {
    cx,
    cy,
    r: r3
  };
}
function formatLabel(value2, labelFormatter) {
  var label = value2 == null ? "" : value2 + "";
  if (labelFormatter) {
    if (isString(labelFormatter)) {
      label = labelFormatter.replace("{value}", label);
    } else if (isFunction(labelFormatter)) {
      label = labelFormatter(value2);
    }
  }
  return label;
}
var GaugeView = function(_super) {
  __extends(GaugeView2, _super);
  function GaugeView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeView2.type;
    return _this;
  }
  GaugeView2.prototype.render = function(seriesModel, ecModel, api) {
    this.group.removeAll();
    var colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
    var posInfo = parsePosition(seriesModel, api);
    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
    this._data = seriesModel.getData();
  };
  GaugeView2.prototype.dispose = function() {};
  GaugeView2.prototype._renderMain = function(seriesModel, ecModel, api, colorList, posInfo) {
    var group = this.group;
    var clockwise = seriesModel.get("clockwise");
    var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
    var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
    var axisLineModel = seriesModel.getModel("axisLine");
    var roundCap = axisLineModel.get("roundCap");
    var MainPath = roundCap ? sausage_default : Sector_default;
    var showAxis = axisLineModel.get("show");
    var lineStyleModel = axisLineModel.getModel("lineStyle");
    var axisLineWidth = lineStyleModel.get("width");
    var angles = [startAngle, endAngle];
    normalizeArcAngles(angles, !clockwise);
    startAngle = angles[0];
    endAngle = angles[1];
    var angleRangeSpan = endAngle - startAngle;
    var prevEndAngle = startAngle;
    var sectors = [];
    for (var i3 = 0;showAxis && i3 < colorList.length; i3++) {
      var percent = Math.min(Math.max(colorList[i3][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      var sector = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector.setStyle({
        fill: colorList[i3][1]
      });
      sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
      sectors.push(sector);
      prevEndAngle = endAngle;
    }
    sectors.reverse();
    each(sectors, function(sector2) {
      return group.add(sector2);
    });
    var getColor = function(percent2) {
      if (percent2 <= 0) {
        return colorList[0][1];
      }
      var i4;
      for (i4 = 0;i4 < colorList.length; i4++) {
        if (colorList[i4][0] >= percent2 && (i4 === 0 ? 0 : colorList[i4 - 1][0]) < percent2) {
          return colorList[i4][1];
        }
      }
      return colorList[i4 - 1][1];
    };
    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);
    this._renderAnchor(seriesModel, posInfo);
    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  };
  GaugeView2.prototype._renderTicks = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var cx = posInfo.cx;
    var cy = posInfo.cy;
    var r3 = posInfo.r;
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var splitLineModel = seriesModel.getModel("splitLine");
    var tickModel = seriesModel.getModel("axisTick");
    var labelModel = seriesModel.getModel("axisLabel");
    var splitNumber = seriesModel.get("splitNumber");
    var subSplitNumber = tickModel.get("splitNumber");
    var splitLineLen = parsePercent2(splitLineModel.get("length"), r3);
    var tickLen = parsePercent2(tickModel.get("length"), r3);
    var angle = startAngle;
    var step = (endAngle - startAngle) / splitNumber;
    var subStep = step / subSplitNumber;
    var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
    var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
    var splitLineDistance = splitLineModel.get("distance");
    var unitX;
    var unitY;
    for (var i3 = 0;i3 <= splitNumber; i3++) {
      unitX = Math.cos(angle);
      unitY = Math.sin(angle);
      if (splitLineModel.get("show")) {
        var distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        var splitLine = new Line_default({
          shape: {
            x1: unitX * (r3 - distance2) + cx,
            y1: unitY * (r3 - distance2) + cy,
            x2: unitX * (r3 - splitLineLen - distance2) + cx,
            y2: unitY * (r3 - splitLineLen - distance2) + cy
          },
          style: splitLineStyle,
          silent: true
        });
        if (splitLineStyle.stroke === "auto") {
          splitLine.setStyle({
            stroke: getColor(i3 / splitNumber)
          });
        }
        group.add(splitLine);
      }
      if (labelModel.get("show")) {
        var distance2 = labelModel.get("distance") + splitLineDistance;
        var label = formatLabel(round2(i3 / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
        var autoColor = getColor(i3 / splitNumber);
        var textStyleX = unitX * (r3 - splitLineLen - distance2) + cx;
        var textStyleY = unitY * (r3 - splitLineLen - distance2) + cy;
        var rotateType = labelModel.get("rotate");
        var rotate2 = 0;
        if (rotateType === "radial") {
          rotate2 = -angle + 2 * Math.PI;
          if (rotate2 > Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (rotateType === "tangential") {
          rotate2 = -angle - Math.PI / 2;
        } else if (isNumber(rotateType)) {
          rotate2 = rotateType * Math.PI / 180;
        }
        if (rotate2 === 0) {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
              align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true
          }));
        } else {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true,
            originX: textStyleX,
            originY: textStyleY,
            rotation: rotate2
          }));
        }
      }
      if (tickModel.get("show") && i3 !== splitNumber) {
        var distance2 = tickModel.get("distance");
        distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
        for (var j3 = 0;j3 <= subSplitNumber; j3++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          var tickLine = new Line_default({
            shape: {
              x1: unitX * (r3 - distance2) + cx,
              y1: unitY * (r3 - distance2) + cy,
              x2: unitX * (r3 - tickLen - distance2) + cx,
              y2: unitY * (r3 - tickLen - distance2) + cy
            },
            silent: true,
            style: tickLineStyle
          });
          if (tickLineStyle.stroke === "auto") {
            tickLine.setStyle({
              stroke: getColor((i3 + j3 / subSplitNumber) / splitNumber)
            });
          }
          group.add(tickLine);
          angle += subStep;
        }
        angle -= subStep;
      } else {
        angle += step;
      }
    }
  };
  GaugeView2.prototype._renderPointer = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var oldData = this._data;
    var oldProgressData = this._progressEls;
    var progressList = [];
    var showPointer = seriesModel.get(["pointer", "show"]);
    var progressModel = seriesModel.getModel("progress");
    var showProgress = progressModel.get("show");
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var valueExtent = [minVal, maxVal];
    var angleExtent = [startAngle, endAngle];
    function createPointer(idx, angle) {
      var itemModel = data.getItemModel(idx);
      var pointerModel = itemModel.getModel("pointer");
      var pointerWidth = parsePercent2(pointerModel.get("width"), posInfo.r);
      var pointerLength = parsePercent2(pointerModel.get("length"), posInfo.r);
      var pointerStr = seriesModel.get(["pointer", "icon"]);
      var pointerOffset = pointerModel.get("offsetCenter");
      var pointerOffsetX = parsePercent2(pointerOffset[0], posInfo.r);
      var pointerOffsetY = parsePercent2(pointerOffset[1], posInfo.r);
      var pointerKeepAspect = pointerModel.get("keepAspect");
      var pointer;
      if (pointerStr) {
        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new PointerPath_default({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }
      pointer.rotation = -(angle + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }
    function createProgress(idx, endAngle2) {
      var roundCap = progressModel.get("roundCap");
      var ProgressPath = roundCap ? sausage_default : Sector_default;
      var isOverlap = progressModel.get("overlap");
      var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      var r3 = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      var progress = new ProgressPath({
        shape: {
          startAngle,
          endAngle: endAngle2,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0,
          r: r3
        }
      });
      isOverlap && (progress.z2 = linearMap(data.get(valueDim, idx), [minVal, maxVal], [100, 0], true));
      return progress;
    }
    if (showProgress || showPointer) {
      data.diff(oldData).add(function(idx) {
        var val = data.get(valueDim, idx);
        if (showPointer) {
          var pointer = createPointer(idx, startAngle);
          initProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }
        if (showProgress) {
          var progress = createProgress(idx, startAngle);
          var isClip = progressModel.get("clip");
          initProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
          progressList[idx] = progress;
        }
      }).update(function(newIdx, oldIdx) {
        var val = data.get(valueDim, newIdx);
        if (showPointer) {
          var previousPointer = oldData.getItemGraphicEl(oldIdx);
          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          var pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          updateProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }
        if (showProgress) {
          var previousProgress = oldProgressData[oldIdx];
          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          var progress = createProgress(newIdx, previousEndAngle);
          var isClip = progressModel.get("clip");
          updateProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        var focus = emphasisModel.get("focus");
        var blurScope = emphasisModel.get("blurScope");
        var emphasisDisabled = emphasisModel.get("disabled");
        if (showPointer) {
          var pointer = data.getItemGraphicEl(idx);
          var symbolStyle = data.getItemVisual(idx, "style");
          var visualColor = symbolStyle.fill;
          if (pointer instanceof Image_default) {
            var pathStyle = pointer.style;
            pointer.useStyle(extend({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, symbolStyle));
          } else {
            pointer.useStyle(symbolStyle);
            pointer.type !== "pointer" && pointer.setColor(visualColor);
          }
          pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          pointer.z2EmphasisLift = 0;
          setStatesStylesFromModel(pointer, itemModel);
          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
        }
        if (showProgress) {
          var progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, "style"));
          progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
          progress.z2EmphasisLift = 0;
          setStatesStylesFromModel(progress, itemModel);
          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
        }
      });
      this._progressEls = progressList;
    }
  };
  GaugeView2.prototype._renderAnchor = function(seriesModel, posInfo) {
    var anchorModel = seriesModel.getModel("anchor");
    var showAnchor = anchorModel.get("show");
    if (showAnchor) {
      var anchorSize = anchorModel.get("size");
      var anchorType = anchorModel.get("icon");
      var offsetCenter = anchorModel.get("offsetCenter");
      var anchorKeepAspect = anchorModel.get("keepAspect");
      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent2(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent2(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
      anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
      this.group.add(anchor);
    }
  };
  GaugeView2.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api, getColor, posInfo) {
    var _this = this;
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var contentGroup = new Group_default;
    var newTitleEls = [];
    var newDetailEls = [];
    var hasAnimation = seriesModel.isAnimationEnabled();
    var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
    data.diff(this._data).add(function(idx) {
      newTitleEls[idx] = new Text_default({
        silent: true
      });
      newDetailEls[idx] = new Text_default({
        silent: true
      });
    }).update(function(idx, oldIdx) {
      newTitleEls[idx] = _this._titleEls[oldIdx];
      newDetailEls[idx] = _this._detailEls[oldIdx];
    }).execute();
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var value2 = data.get(valueDim, idx);
      var itemGroup = new Group_default;
      var autoColor = getColor(linearMap(value2, [minVal, maxVal], [0, 1], true));
      var itemTitleModel = itemModel.getModel("title");
      if (itemTitleModel.get("show")) {
        var titleOffsetCenter = itemTitleModel.get("offsetCenter");
        var titleX = posInfo.cx + parsePercent2(titleOffsetCenter[0], posInfo.r);
        var titleY = posInfo.cy + parsePercent2(titleOffsetCenter[1], posInfo.r);
        var labelEl = newTitleEls[idx];
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: autoColor
          })
        });
        itemGroup.add(labelEl);
      }
      var itemDetailModel = itemModel.getModel("detail");
      if (itemDetailModel.get("show")) {
        var detailOffsetCenter = itemDetailModel.get("offsetCenter");
        var detailX = posInfo.cx + parsePercent2(detailOffsetCenter[0], posInfo.r);
        var detailY = posInfo.cy + parsePercent2(detailOffsetCenter[1], posInfo.r);
        var width = parsePercent2(itemDetailModel.get("width"), posInfo.r);
        var height = parsePercent2(itemDetailModel.get("height"), posInfo.r);
        var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
        var labelEl = newDetailEls[idx];
        var formatter_1 = itemDetailModel.get("formatter");
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value2, formatter_1),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: detailColor
          })
        });
        setLabelValueAnimation(labelEl, {
          normal: itemDetailModel
        }, value2, function(value3) {
          return formatLabel(value3, formatter_1);
        });
        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
          getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value2, formatter_1);
          }
        });
        itemGroup.add(labelEl);
      }
      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  };
  GaugeView2.type = "gauge";
  return GaugeView2;
}(Chart_default);
var GaugeView_default = GaugeView;

// node_modules/echarts/lib/chart/gauge/GaugeSeries.js
var GaugeSeriesModel = function(_super) {
  __extends(GaugeSeriesModel2, _super);
  function GaugeSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeSeriesModel2.type;
    _this.visualStyleAccessPath = "itemStyle";
    return _this;
  }
  GaugeSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, ["value"]);
  };
  GaugeSeriesModel2.type = "series.gauge";
  GaugeSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    center: ["50%", "50%"],
    legendHoverLink: true,
    radius: "75%",
    startAngle: 225,
    endAngle: -45,
    clockwise: true,
    min: 0,
    max: 100,
    splitNumber: 10,
    axisLine: {
      show: true,
      roundCap: false,
      lineStyle: {
        color: [[1, "#E6EBF8"]],
        width: 10
      }
    },
    progress: {
      show: false,
      overlap: true,
      width: 10,
      roundCap: false,
      clip: true
    },
    splitLine: {
      show: true,
      length: 10,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 3,
        type: "solid"
      }
    },
    axisTick: {
      show: true,
      splitNumber: 5,
      length: 6,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 1,
        type: "solid"
      }
    },
    axisLabel: {
      show: true,
      distance: 15,
      color: "#464646",
      fontSize: 12,
      rotate: 0
    },
    pointer: {
      icon: null,
      offsetCenter: [0, 0],
      show: true,
      showAbove: true,
      length: "60%",
      width: 6,
      keepAspect: false
    },
    anchor: {
      show: false,
      showAbove: false,
      size: 6,
      icon: "circle",
      offsetCenter: [0, 0],
      keepAspect: false,
      itemStyle: {
        color: "#fff",
        borderWidth: 0,
        borderColor: "#5470c6"
      }
    },
    title: {
      show: true,
      offsetCenter: [0, "20%"],
      color: "#464646",
      fontSize: 16,
      valueAnimation: false
    },
    detail: {
      show: true,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      borderColor: "#ccc",
      width: 100,
      height: null,
      padding: [5, 10],
      offsetCenter: [0, "40%"],
      color: "#464646",
      fontSize: 30,
      fontWeight: "bold",
      lineHeight: 30,
      valueAnimation: false
    }
  };
  return GaugeSeriesModel2;
}(Series_default);
var GaugeSeries_default = GaugeSeriesModel;

// node_modules/echarts/lib/chart/gauge/install.js
function install7(registers) {
  registers.registerChartView(GaugeView_default);
  registers.registerSeriesModel(GaugeSeries_default);
}
// node_modules/zrender/lib/canvas/Layer.js
function createDom(id, painter, dpr2) {
  var newDom = platformApi.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer = function(_super) {
  __extends2(Layer2, _super);
  function Layer2(id, painter, dpr2) {
    var _this = _super.call(this) || this;
    _this.motionBlur = false;
    _this.lastFrameAlpha = 0.7;
    _this.dpr = 1;
    _this.virtual = false;
    _this.config = {};
    _this.incremental = false;
    _this.zlevel = 0;
    _this.maxRepaintRectCount = 5;
    _this.__dirty = true;
    _this.__firstTimePaint = true;
    _this.__used = false;
    _this.__drawIndex = 0;
    _this.__startIndex = 0;
    _this.__endIndex = 0;
    _this.__prevStartIndex = null;
    _this.__prevEndIndex = null;
    var dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr2);
    } else if (isObject2(id)) {
      dom = id;
      id = dom.id;
    }
    _this.id = id;
    _this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = function() {
        return false;
      };
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    _this.painter = painter;
    _this.dpr = dpr2;
    return _this;
  }
  Layer2.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  };
  Layer2.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  };
  Layer2.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  };
  Layer2.prototype.setUnpainted = function() {
    this.__firstTimePaint = true;
  };
  Layer2.prototype.createBackBuffer = function() {
    var dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  };
  Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    var mergedRepaintRects = [];
    var maxRepaintRectCount = this.maxRepaintRectCount;
    var full = false;
    var pendingRect = new BoundingRect_default(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        var boundingRect = new BoundingRect_default(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        var isMerged = false;
        var minDeltaArea = Infinity;
        var bestRectToMergeIdx = 0;
        for (var i4 = 0;i4 < mergedRepaintRects.length; ++i4) {
          var mergedRect = mergedRepaintRects[i4];
          if (mergedRect.intersect(rect)) {
            var pendingRect_1 = new BoundingRect_default(0, 0, 0, 0);
            pendingRect_1.copy(mergedRect);
            pendingRect_1.union(rect);
            mergedRepaintRects[i4] = pendingRect_1;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            var aArea = rect.width * rect.height;
            var bArea = mergedRect.width * mergedRect.height;
            var pendingArea = pendingRect.width * pendingRect.height;
            var deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i4;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          var boundingRect = new BoundingRect_default(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (var i3 = this.__startIndex;i3 < this.__endIndex; ++i3) {
      var el = displayList[i3];
      if (el) {
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (var i3 = this.__prevStartIndex;i3 < this.__prevEndIndex; ++i3) {
      var el = prevList[i3];
      var shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        var prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    var hasIntersections;
    do {
      hasIntersections = false;
      for (var i3 = 0;i3 < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i3].isZero()) {
          mergedRepaintRects.splice(i3, 1);
          continue;
        }
        for (var j3 = i3 + 1;j3 < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i3].intersect(mergedRepaintRects[j3])) {
            hasIntersections = true;
            mergedRepaintRects[i3].union(mergedRepaintRects[j3]);
            mergedRepaintRects.splice(j3, 1);
          } else {
            j3++;
          }
        }
        i3++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  };
  Layer2.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  };
  Layer2.prototype.resize = function(width, height) {
    var dpr2 = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr2;
    dom.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  };
  Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr2 = this.dpr;
    var self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
    }
    var domBack = this.domBack;
    function doClear(x3, y3, width2, height2) {
      ctx.clearRect(x3, y3, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        var clearColorGradientOrPattern = undefined;
        if (isGradientObject(clearColor)) {
          var shouldCache = clearColor.global || clearColor.__width === width2 && clearColor.__height === height2;
          clearColorGradientOrPattern = shouldCache && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
          clearColor.__width = width2;
          clearColor.__height = height2;
        } else if (isImagePatternObject(clearColor)) {
          clearColor.scaleX = clearColor.scaleX || dpr2;
          clearColor.scaleY = clearColor.scaleY || dpr2;
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty: function() {
              self2.setUnpainted();
              self2.painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x3, y3, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x3, y3, width2, height2);
        ctx.restore();
      }
    }
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each(repaintRects, function(rect) {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  };
  return Layer2;
}(Eventful_default);
var Layer_default = Layer;

// node_modules/zrender/lib/canvas/Painter.js
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 0.001;
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = function() {
  function CanvasPainter2(root, storage, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    var rootStyle = root.style;
    if (rootStyle) {
      disableUserSelect(root);
      root.innerHTML = "";
    }
    this.storage = storage;
    var zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    var layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize(root, 0, opts);
      this._height = getSize(root, 1, opts);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      var rootCanvas = root;
      var width = rootCanvas.width;
      var height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      var mainLayer = new Layer_default(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
  }
  CanvasPainter2.prototype.getType = function() {
    return "canvas";
  };
  CanvasPainter2.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  };
  CanvasPainter2.prototype.getViewportRoot = function() {
    return this._domRoot;
  };
  CanvasPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  CanvasPainter2.prototype.refresh = function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var prevList = this._prevDisplayList;
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (var i3 = 0;i3 < zlevelList.length; i3++) {
      var z3 = zlevelList[i3];
      var layer = this._layers[z3];
      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i3 === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  };
  CanvasPainter2.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(false));
  };
  CanvasPainter2.prototype._paintHoverList = function(list) {
    var len2 = list.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    var scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    var ctx;
    for (var i3 = 0;i3 < len2; i3++) {
      var el = list[i3];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush(ctx, el, scope, i3 === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  };
  CanvasPainter2.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  };
  CanvasPainter2.prototype.paintOne = function(ctx, el) {
    brushSingle(ctx, el);
  };
  CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      var self_1 = this;
      requestAnimationFrame_default(function() {
        self_1._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer(function(layer) {
        layer.afterBrush && layer.afterBrush();
      });
    }
  };
  CanvasPainter2.prototype._compositeManually = function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  };
  CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
    var _this = this;
    var layerList = [];
    var useDirtyRect = this._opts.useDirtyRect;
    for (var zi = 0;zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    var finished = true;
    var needsRefreshHover = false;
    var _loop_1 = function(k4) {
      var layer2 = layerList[k4];
      var ctx = layer2.ctx;
      var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
      var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
      var useTimer = !paintAll && layer2.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
      if (layer2.__startIndex === layer2.__endIndex) {
        layer2.clear(false, clearColor, repaintRects);
      } else if (start2 === layer2.__startIndex) {
        var firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer2.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer2.__startIndex;
      }
      var i3;
      var repaint = function(repaintRect) {
        var scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: _this._width,
          viewHeight: _this._height
        };
        for (i3 = start2;i3 < layer2.__endIndex; i3++) {
          var el = list[i3];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i3 === layer2.__endIndex - 1);
          if (useTimer) {
            var dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i3 = layer2.__endIndex;
        } else {
          var dpr2 = this_1.dpr;
          for (var r3 = 0;r3 < repaintRects.length; ++r3) {
            var rect = repaintRects[r3];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer2.__drawIndex = i3;
      if (layer2.__drawIndex < layer2.__endIndex) {
        finished = false;
      }
    };
    var this_1 = this;
    for (var k3 = 0;k3 < layerList.length; k3++) {
      _loop_1(k3);
    }
    if (env_default.wxa) {
      each(this._layers, function(layer2) {
        if (layer2 && layer2.ctx && layer2.ctx.draw) {
          layer2.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  };
  CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    var ctx = currentLayer.ctx;
    if (useDirtyRect) {
      var paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush(ctx, el, scope, isLast);
    }
  };
  CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer_default("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  };
  CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len2 = zlevelList.length;
    var domRoot = this._domRoot;
    var prevLayer = null;
    var i3 = -1;
    if (layersMap[zlevel]) {
      if (true) {
        logError("ZLevel " + zlevel + " has been used already");
      }
      return;
    }
    if (!isLayerValid(layer)) {
      if (true) {
        logError("Layer of zlevel " + zlevel + " is not valid");
      }
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i3 = 0;i3 < len2 - 1; i3++) {
        if (zlevelList[i3] < zlevel && zlevelList[i3 + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i3]];
    }
    zlevelList.splice(i3 + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.painter || (layer.painter = this);
  };
  CanvasPainter2.prototype.eachLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i3 = 0;i3 < zlevelList.length; i3++) {
      var z3 = zlevelList[i3];
      cb.call(context, this._layers[z3], z3);
    }
  };
  CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i3 = 0;i3 < zlevelList.length; i3++) {
      var z3 = zlevelList[i3];
      var layer = this._layers[z3];
      if (layer.__builtin__) {
        cb.call(context, layer, z3);
      }
    }
  };
  CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i3 = 0;i3 < zlevelList.length; i3++) {
      var z3 = zlevelList[i3];
      var layer = this._layers[z3];
      if (!layer.__builtin__) {
        cb.call(context, layer, z3);
      }
    }
  };
  CanvasPainter2.prototype.getLayers = function() {
    return this._layers;
  };
  CanvasPainter2.prototype._updateLayerStatus = function(list) {
    this.eachBuiltinLayer(function(layer2, z3) {
      layer2.__dirty = layer2.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i_1 = 1;i_1 < list.length; i_1++) {
        var el = list[i_1];
        if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    var i3;
    for (i3 = 0;i3 < list.length; i3++) {
      var el = list[i3];
      var zlevel = el.zlevel;
      var layer = undefined;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i3) {
          layer.__dirty = true;
        }
        layer.__startIndex = i3;
        if (!layer.incremental) {
          layer.__drawIndex = i3;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i3);
        prevLayer = layer;
      }
      if (el.__dirty & REDRAW_BIT && !el.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i3;
        }
      }
    }
    updatePrevLayer(i3);
    this.eachBuiltinLayer(function(layer2, z3) {
      if (!layer2.__used && layer2.getElementCount() > 0) {
        layer2.__dirty = true;
        layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
      }
      if (layer2.__dirty && layer2.__drawIndex < 0) {
        layer2.__drawIndex = layer2.__startIndex;
      }
    });
  };
  CanvasPainter2.prototype.clear = function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  };
  CanvasPainter2.prototype._clearLayer = function(layer) {
    layer.clear();
  };
  CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each(this._layers, function(layer) {
      layer.setUnpainted();
    });
  };
  CanvasPainter2.prototype.configLayer = function(zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge(layerConfig[zlevel], config, true);
      }
      for (var i3 = 0;i3 < this._zlevelList.length; i3++) {
        var _zlevel = this._zlevelList[i3];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  };
  CanvasPainter2.prototype.delLayer = function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf(zlevelList, zlevel), 1);
  };
  CanvasPainter2.prototype.resize = function(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      var root = this.root;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = getSize(root, 0, opts);
      height = getSize(root, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  };
  CanvasPainter2.prototype.clearLayer = function(zlevel) {
    var layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  };
  CanvasPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  };
  CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    var ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width_1 = imageLayer.dom.width;
      var height_1 = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      var scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var displayList = this.storage.getDisplayList(true);
      for (var i3 = 0, len2 = displayList.length;i3 < len2; i3++) {
        var el = displayList[i3];
        brush(ctx, el, scope, i3 === len2 - 1);
      }
    }
    return imageLayer.dom;
  };
  CanvasPainter2.prototype.getWidth = function() {
    return this._width;
  };
  CanvasPainter2.prototype.getHeight = function() {
    return this._height;
  };
  return CanvasPainter2;
}();
var Painter_default = CanvasPainter;

// node_modules/echarts/lib/renderer/installCanvasRenderer.js
function install8(registers) {
  registers.registerPainter("canvas", Painter_default);
}
// src/preact/lib/echarts.ts
var registered = { renderer: false };
function ensureRenderer() {
  if (!registered.renderer) {
    use([install8]);
    registered.renderer = true;
  }
}
function registerEChartsModules(modules) {
  ensureRenderer();
  use(modules);
}
function useECharts(ref, deps, buildOption, onInit) {
  const instanceRef = A2(null);
  y2(() => {
    ensureRenderer();
    if (!ref.current)
      return;
    const chart = init2(ref.current, undefined, { renderer: "canvas" });
    instanceRef.current = chart;
    if (onInit)
      onInit(chart);
    const handleResize = () => chart.resize();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
      chart.dispose();
      instanceRef.current = null;
    };
  }, [ref]);
  y2(() => {
    const chart = instanceRef.current;
    if (!chart)
      return;
    const option = buildOption();
    chart.setOption(option, true);
  }, deps);
  return { instance: instanceRef.current };
}

// src/preact/components/widgets/gauge.ts
registerEChartsModules([install7]);
function computeGaugeHeight(ctrl) {
  const gtype = (ctrl.gtype || "gage").toString().toLowerCase();
  if (gtype === "wave")
    return 240;
  if (gtype === "compass")
    return 220;
  if (gtype === "donut")
    return 200;
  return 200;
}
function toNumber3(value2, fallback) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : fallback;
}
function clamp2(value2, min3, max3) {
  return Math.min(max3, Math.max(min3, value2));
}
function formatGaugeValue(value2, format2, units, formatter) {
  const tpl = format2 && format2.includes("{{") ? format2 : "{{value}}";
  const formattedValue = formatter.format(value2);
  return tpl.replace(/{{\s*value\s*}}/g, formattedValue).replace(/{{\s*units\s*}}/g, units ?? "");
}
function formatGaugeDetail(value2, delta, format2, units, formatter) {
  const base2 = formatGaugeValue(value2, format2, units, formatter);
  if (delta === undefined)
    return base2;
  const deltaFormatted = formatter.format(delta);
  const sign = delta > 0 ? "+" : "";
  return `${base2} ${delta === 0 ? "(0)" : `(${sign}${deltaFormatted})`}`;
}
function buildSegments(ctrl, min3, max3) {
  const colors = ctrl.colors && ctrl.colors.length >= 3 ? ctrl.colors : [
    "var(--nr-dashboard-widgetColor, #00B500)",
    "var(--nr-dashboard-warnColor, #E6E600)",
    "var(--nr-dashboard-errorColor, #CA3838)"
  ];
  const seg1 = toNumber3(ctrl.seg1, (min3 + max3) / 3);
  const seg2 = toNumber3(ctrl.seg2, (min3 + max3) / 3 * 2);
  const span = max3 - min3 || 1;
  const p1 = clamp2((seg1 - min3) / span, 0, 1);
  const p22 = clamp2((seg2 - min3) / span, 0, 1);
  return [
    [Math.min(p1, p22), colors[0]],
    [Math.max(p1, p22), colors[1]],
    [1, colors[2]]
  ];
}
function GaugeWidget(props) {
  const { control, index } = props;
  const asGauge = control;
  const { t: t4, lang } = useI18n();
  const label = asGauge.label || asGauge.name || t4("gauge_label", "Gauge {index}", { index: index + 1 });
  const min3 = toNumber3(asGauge.min, 0);
  const max3 = toNumber3(asGauge.max, 10);
  const [value2, setValue] = d2(clamp2(toNumber3(asGauge.value ?? min3, min3), min3, max3));
  const formatter = T2(() => new Intl.NumberFormat(lang || undefined), [lang]);
  const chartRef = A2(null);
  const prevValue = A2(value2);
  y2(() => {
    setValue(clamp2(toNumber3(asGauge.value ?? min3, min3), min3, max3));
  }, [asGauge.value, min3, max3]);
  const segments = T2(() => buildSegments(asGauge, min3, max3), [asGauge, min3, max3]);
  const showMinMax = !asGauge.hideMinMax;
  const showTicks = asGauge.gtype === "gage" || asGauge.gtype === "compass" || !asGauge.gtype;
  const gtype = (asGauge.gtype || "gage").toString().toLowerCase();
  const isDonut = gtype === "donut";
  const isWave = gtype === "wave";
  const isCompass = gtype === "compass";
  const diffEnabled = Boolean(asGauge.diff);
  const delta = diffEnabled ? value2 - prevValue.current : undefined;
  const formatted = formatGaugeDetail(value2, delta, asGauge.format, asGauge.units, formatter);
  const ariaLabel = t4("gauge_value_label", "{label}: {value} {units}", {
    label,
    value: formatNumber(value2, lang),
    units: asGauge.units ?? ""
  });
  const reverse = Boolean(asGauge.reverse);
  const chartHeight = computeGaugeHeight(asGauge);
  y2(() => {
    prevValue.current = value2;
  }, [value2]);
  useECharts(chartRef, [value2, min3, max3, segments, showTicks, showMinMax, isDonut, isWave, isCompass, formatted, label, reverse, formatter, chartHeight], () => ({
    backgroundColor: "transparent",
    series: [
      {
        type: "gauge",
        min: min3,
        max: max3,
        startAngle: isCompass ? 90 : reverse ? 45 : 225,
        endAngle: isCompass ? -270 : reverse ? -225 : -45,
        splitNumber: isCompass ? 8 : showTicks ? 6 : 0,
        progress: {
          show: true,
          width: isDonut || isWave ? 14 : 10,
          roundCap: true,
          itemStyle: {
            color: segments[segments.length - 1][1]
          }
        },
        axisLine: {
          lineStyle: {
            width: isDonut ? 14 : 10,
            color: segments
          }
        },
        axisTick: { show: showTicks, distance: isCompass ? -6 : -8, length: isCompass ? 8 : 6 },
        splitLine: { show: showTicks, length: isCompass ? 10 : 8, distance: isCompass ? -10 : -12 },
        axisLabel: {
          show: showMinMax || isCompass,
          distance: isCompass ? 18 : 12,
          color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)",
          formatter: (val) => {
            if (!isCompass)
              return formatter.format(val);
            const dirs = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
            const idx = Math.round(val % 360 / 45) % 8;
            return dirs[idx];
          }
        },
        pointer: { show: !isDonut && !isWave, width: 4, itemStyle: { color: "var(--nr-dashboard-widgetTextColor, #fff)" } },
        anchor: { show: !isDonut && !isWave, showAbove: true, size: 10, itemStyle: { color: "var(--nr-dashboard-widgetTextColor, #fff)" } },
        detail: {
          valueAnimation: true,
          formatter: () => formatted,
          color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)",
          fontSize: 16,
          offsetCenter: isWave ? [0, "34%"] : [0, "54%"]
        },
        data: [
          {
            value: value2,
            name: label
          }
        ]
      }
    ]
  }));
  return m2`<div
    class=${asGauge.className || ""}
    style=${{
    width: "100%",
    minHeight: `${chartHeight}px`,
    display: "flex",
    flexDirection: "column",
    gap: "8px",
    alignItems: "center",
    justifyContent: "center"
  }}
    aria-label=${ariaLabel}
  >
    <div style=${{ fontWeight: 600 }}>${label}</div>
    <div ref=${chartRef} style=${{ width: "100%", height: `${chartHeight}px` }}></div>
  </div>`;
}

// src/preact/components/widgets/date-picker.ts
function resolveDateInputType(mode) {
  if (mode === "time")
    return "time";
  if (mode === "datetime")
    return "datetime-local";
  return "date";
}
function DatePickerWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const c3 = control;
  const { t: t4, lang } = useI18n();
  const label = c3.label || c3.name || t4("date_label", "Date {index}", { index: index + 1 });
  const [value2, setValue] = d2(c3.value || "");
  const [error2, setError] = d2("");
  const [focused, setFocused] = d2(false);
  const inputId = T2(() => `nr-dashboard-date-${index}`, [index]);
  const isDisabled = Boolean(disabled);
  const inputType2 = resolveDateInputType(c3.mode);
  const validate = (next) => {
    if (c3.required && next.trim().length === 0) {
      setError(c3.error || t4("error_required", "A value is required."));
      return false;
    }
    if (c3.min && next && next < c3.min) {
      setError(c3.error || t4("error_min", "Value is before the allowed range."));
      return false;
    }
    if (c3.max && next && next > c3.max) {
      setError(c3.error || t4("error_max", "Value is after the allowed range."));
      return false;
    }
    setError("");
    return true;
  };
  const fieldStyles = buildFieldStyles({ error: Boolean(error2), focused, disabled: isDisabled });
  return m2`<label style=${fieldWrapperStyles}>
    <span style=${fieldLabelStyles}>${label}</span>
    <div style=${{ position: "relative", width: "100%" }}>
      <input
        id=${inputId}
        class=${c3.className || ""}
        type=${inputType2}
        value=${value2}
        disabled=${isDisabled}
        lang=${lang}
        aria-invalid=${error2 ? "true" : "false"}
        aria-errormessage=${error2 ? `err-date-${index}` : undefined}
        aria-valuetext=${formatDateInput(value2, c3.mode, lang) || undefined}
        onInput=${(e4) => {
    if (isDisabled)
      return;
    const v3 = e4.target.value;
    setValue(v3);
    if (!validate(v3))
      return;
    onEmit?.("ui-change", { payload: v3 });
  }}
        onFocus=${() => setFocused(true)}
        onBlur=${() => setFocused(false)}
        style=${{ ...fieldStyles, paddingRight: "44px" }}
        min=${c3.min || undefined}
        max=${c3.max || undefined}
      />
      <span
        aria-hidden="true"
        style=${{
    position: "absolute",
    right: "12px",
    top: "50%",
    transform: "translateY(-50%)",
    color: "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.6))",
    fontSize: "14px",
    pointerEvents: "none"
  }}
      >
        <i class="fa fa-calendar" aria-hidden="true"></i>
      </span>
    </div>
    ${error2 ? m2`<span
          id=${`err-date-${index}`}
          role="alert"
          style=${{ color: "var(--nr-dashboard-errorColor, #f87171)", fontSize: "12px" }}
        >${error2}</span>` : null}
  </label>`;
}

// src/preact/components/widgets/colour-picker.ts
function resolveColourValue(value2, fallback = "#ff0000") {
  if (typeof value2 === "string" && value2.trim().length > 0)
    return value2;
  return fallback;
}
function ColourPickerWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const c3 = control;
  const { t: t4 } = useI18n();
  const label = c3.label || c3.name || t4("colour_label", "Colour {index}", { index: index + 1 });
  const [value2, setValue] = d2(resolveColourValue(c3.value));
  const isDisabled = Boolean(disabled);
  const [focused, setFocused] = d2(false);
  const inputId = T2(() => `nr-dashboard-colour-${index}`, [index]);
  const fieldStyles = buildFieldStyles({ focused, disabled: isDisabled, hasAdornment: true });
  return m2`<label style=${fieldWrapperStyles} htmlFor=${inputId}>
    <span style=${fieldLabelStyles}>${label}</span>
    <div
      style=${{
    ...fieldStyles,
    display: "flex",
    alignItems: "center",
    gap: "10px",
    paddingRight: "16px"
  }}
    >
      <input
        class=${c3.className || ""}
        type="color"
        value=${value2}
        disabled=${isDisabled}
        id=${inputId}
        aria-label=${label}
        onInput=${(e4) => {
    if (isDisabled)
      return;
    const v3 = e4.target.value;
    setValue(v3);
    onEmit?.("ui-change", { payload: v3 });
  }}
        onFocus=${() => setFocused(true)}
        onBlur=${() => setFocused(false)}
        style=${{
    width: "46px",
    height: "32px",
    padding: 0,
    border: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.35))",
    borderRadius: "6px",
    background: "transparent",
    cursor: isDisabled ? "not-allowed" : "pointer"
  }}
      />
      <span style=${{ fontSize: "13px", opacity: 0.9, wordBreak: "break-all" }}>${value2}</span>
    </div>
  </label>`;
}

// src/preact/components/widgets/audio.ts
function shouldAutoPlay(isDisabled, autoplay) {
  return Boolean(autoplay) && !isDisabled;
}
function AudioWidget(props) {
  const { control, index, disabled } = props;
  const c3 = control;
  const { t: t4 } = useI18n();
  const label = c3.label || c3.name || t4("audio_label", "Audio {index}", { index: index + 1 });
  const ref = A2(null);
  const isDisabled = Boolean(disabled);
  const [playIntent, setPlayIntent] = d2(false);
  y2(() => {
    if (!ref.current)
      return;
    if (isDisabled) {
      ref.current.pause();
      setPlayIntent(false);
      return;
    }
    if (c3.reset) {
      ref.current.pause();
      ref.current.currentTime = 0;
      setPlayIntent(false);
      return;
    }
    if (c3.stop) {
      ref.current.pause();
      setPlayIntent(false);
      return;
    }
    if (shouldAutoPlay(isDisabled, c3.autoplay) || c3.play) {
      setPlayIntent(true);
      if (typeof ref.current.play === "function") {
        ref.current.play().catch(() => {
          return;
        });
      }
    } else {
      setPlayIntent(false);
    }
  }, [c3.autoplay, c3.play, c3.stop, c3.reset, c3.url, isDisabled]);
  return m2`<div class=${c3.className || ""} style=${{ width: "100%" }}>
    <div
      style=${{
    display: "flex",
    alignItems: "center",
    gap: "8px",
    padding: "8px 10px",
    borderRadius: "8px",
    background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
    border: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.12))",
    marginBottom: "6px"
  }}
    >
      <i class="fa fa-volume-up" aria-hidden="true" style=${{ fontSize: "16px" }}></i>
      <div style=${{ fontSize: "13px", opacity: 0.78 }}>${label}</div>
    </div>
    <audio
      ref=${ref}
      src=${c3.url || ""}
      controls
      loop=${Boolean(c3.loop)}
      data-play-intent=${playIntent ? "true" : "false"}
      aria-disabled=${isDisabled}
      aria-label=${t4("audio_controls", "Audio controls for {label}", { label })}
      tabIndex=${isDisabled ? -1 : undefined}
      style=${{ width: "100%", pointerEvents: isDisabled ? "none" : "auto", borderRadius: "6px" }}
    ></audio>
  </div>`;
}

// src/preact/components/widgets/toast.ts
function resolveToastToneColor(level) {
  if (level === "error")
    return "var(--nr-dashboard-errorColor, #f87171)";
  if (level === "warn")
    return "var(--nr-dashboard-warnColor, #facc15)";
  return "var(--nr-dashboard-infoColor, #60a5fa)";
}
function ToastWidget(props) {
  const { control, index } = props;
  const c3 = control;
  const { t: t4 } = useI18n();
  const label = c3.label || c3.name || t4("toast_label", "Toast {index}", { index: index + 1 });
  const msg = c3.message || t4("toast_message", "Toast message");
  const tone = c3.level || "info";
  const toneColor = resolveToastToneColor(tone);
  const [visible, setVisible] = d2(true);
  const dismissible = c3.dismissible !== false;
  const displayMs = Number.isFinite(c3.displayTime) ? Math.max(0, Number(c3.displayTime)) : 3000;
  const [stackOffset, setStackOffset] = d2(index * 4);
  y2(() => {
    setVisible(true);
    setStackOffset(index * 4);
    if (displayMs > 0) {
      const timer = window.setTimeout(() => setVisible(false), displayMs);
      return () => window.clearTimeout(timer);
    }
    return;
  }, [c3.message, c3.label, c3.level, displayMs]);
  if (!visible)
    return null;
  return m2`<div
    class=${c3.className || ""}
    style=${{
    border: "1px solid color-mix(in srgb, var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.2)) 60%, transparent)",
    borderLeft: `4px solid ${toneColor}`,
    boxShadow: "0 3px 10px rgba(0,0,0,0.18)",
    padding: "12px 14px 12px 16px",
    background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
    position: "relative",
    borderRadius: "8px",
    margin: `${6 + stackOffset}px 0 6px 0`
  }}
    role="status"
    aria-live="polite"
    aria-atomic="true"
  >
    <div style=${{ fontWeight: 700, marginBottom: "6px", color: toneColor }}>${label}</div>
    <div style=${{ fontSize: "13px", lineHeight: 1.45 }}>${msg}</div>
    ${dismissible ? m2`<button
          type="button"
          aria-label=${t4("toast_close", "Close notification")}
          onClick=${() => setVisible(false)}
          style=${{
    position: "absolute",
    top: "6px",
    right: "6px",
    background: "transparent",
    border: "none",
    color: toneColor,
    cursor: "pointer",
    fontWeight: 800,
    fontSize: "18px",
    padding: "4px"
  }}
        ></button>` : null}
  </div>`;
}

// src/preact/components/widgets/link.ts
function resolveLinkHref(ctrl, fallback = "#") {
  return ctrl.url || ctrl.link || fallback;
}
function LinkWidget(props) {
  const { control, index, disabled } = props;
  const c3 = control;
  const href = resolveLinkHref(c3);
  const { t: t4 } = useI18n();
  const label = c3.label || c3.name || href || t4("link_label", "Link {index}", { index: index + 1 });
  const target = c3.target || "_blank";
  const icon = c3.icon;
  const isDisabled = Boolean(disabled);
  const [focused, setFocused] = d2(false);
  const [hovered, setHovered] = d2(false);
  const [pressed, setPressed] = d2(false);
  const focusRing = focused ? "0 0 0 2px color-mix(in srgb, var(--nr-dashboard-widgetColor, #61dafb) 40%, transparent)" : "none";
  return m2`<div style=${{ display: "flex", alignItems: "center", width: "100%" }}>
    <a
      href=${isDisabled ? undefined : href}
      target=${target}
      rel="noreferrer noopener"
      aria-disabled=${isDisabled}
      aria-label=${t4("link_open", "Open {label}", { label })}
      tabIndex=${isDisabled ? -1 : undefined}
      title=${c3.tooltip || t4("link_open", "Open {label}", { label })}
      onClick=${isDisabled ? (e4) => {
    e4.preventDefault();
    e4.stopPropagation();
  } : undefined}
      onMouseEnter=${() => setHovered(true)}
      onMouseLeave=${() => setHovered(false)}
      onMouseDown=${() => setPressed(true)}
      onMouseUp=${() => setPressed(false)}
      onBlur=${() => setPressed(false)}
      onFocus=${() => setFocused(true)}
      onBlur=${() => setFocused(false)}
      style=${{
    display: "inline-flex",
    alignItems: "center",
    gap: "10px",
    padding: "10px 12px",
    borderRadius: "8px",
    background: "transparent",
    color: isDisabled ? "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.45))" : "var(--nr-dashboard-widgetColor, #61dafb)",
    pointerEvents: isDisabled ? "none" : "auto",
    textDecoration: "none",
    boxShadow: focusRing,
    transition: "box-shadow 140ms ease, color 140ms ease",
    width: "100%",
    transform: pressed ? "translateY(1px)" : "none"
  }}
    >
      ${icon ? m2`<i class=${icon} aria-hidden="true" style=${{ fontSize: "18px" }}></i>` : m2`<i class="fa fa-external-link" aria-hidden="true" style=${{ fontSize: "18px" }}></i>`}
      <span style=${{ fontWeight: 600, letterSpacing: "0.01em" }}>${label}</span>
    </a>
  </div>`;
}

// src/preact/components/widgets/template.ts
function resolveTemplateHtml(ctrl) {
  return ctrl.template || ctrl.format || "";
}
function TemplateWidget(props) {
  const { control, index } = props;
  const c3 = control;
  const { t: t4 } = useI18n();
  const title = c3.name || t4("template_label", "Template {index}", { index: index + 1 });
  const htmlContent = resolveTemplateHtml(c3);
  return m2`<div class=${c3.className || ""} style=${{ width: "100%" }}>
    <div
      style=${{
    padding: "4px 0",
    borderRadius: "0",
    background: "transparent",
    border: "none",
    display: "grid",
    gap: "4px"
  }}
    >
      <div style=${{ fontSize: "12px", opacity: 0.7 }}>${title}</div>
      <div dangerouslySetInnerHTML=${{ __html: htmlContent }}></div>
    </div>
  </div>`;
}

// src/preact/components/widgets/form.ts
function buildFormEmit(ctrl, fallbackLabel, values) {
  return {
    payload: values,
    topic: ctrl.topic ?? fallbackLabel,
    type: "form"
  };
}
function FormWidget(props) {
  const { control, index, disabled, onEmit } = props;
  const c3 = control;
  const { t: t4 } = useI18n();
  const title = c3.label || c3.name || t4("form_label", "Form {index}", { index: index + 1 });
  const fields = T2(() => c3.fields || [], [c3.fields]);
  const isDisabled = Boolean(disabled);
  const [values, setValues] = d2(() => {
    const initial = {};
    fields.forEach((f3) => {
      if (f3.type === "checkbox" || f3.type === "switch") {
        initial[f3.name] = Boolean(f3.value);
      } else {
        initial[f3.name] = f3.value == null ? "" : String(f3.value);
      }
    });
    return initial;
  });
  const [errors, setErrors] = d2({});
  const setField = (name, v3) => {
    setValues((prev) => ({ ...prev, [name]: v3 }));
  };
  return m2`<form
    class=${c3.className || ""}
    style=${{ display: "grid", gap: "10px" }}
    onSubmit=${(e4) => {
    e4.preventDefault();
    if (isDisabled)
      return;
    const nextErrors = {};
    fields.forEach((f3) => {
      const rawVal = values[f3.name];
      const val = typeof rawVal === "string" ? rawVal.trim() : rawVal;
      if (f3.required && (val === "" || val === undefined || val === null)) {
        nextErrors[f3.name] = f3.error || t4("error_required", "This field is required.");
      } else if (typeof val === "string" && f3.pattern) {
        const re2 = new RegExp(f3.pattern);
        if (!re2.test(val))
          nextErrors[f3.name] = f3.error || t4("error_pattern", "Value does not match the required format.");
      }
    });
    setErrors(nextErrors);
    if (Object.keys(nextErrors).length > 0)
      return;
    onEmit?.("ui-control", buildFormEmit(c3, title, values));
  }}
  >
    <div style=${{ fontWeight: 600 }}>${title}</div>
    ${fields.length === 0 ? m2`<div style=${{ fontSize: "12px", opacity: 0.7 }}>${t4("form_no_fields", "No fields configured.")}</div>` : fields.map((f3) => {
    const type = f3.type === "number" ? "number" : f3.type === "password" ? "password" : f3.type === "email" ? "email" : f3.type === "date" ? "date" : f3.type === "time" ? "time" : f3.type === "checkbox" || f3.type === "switch" ? "checkbox" : f3.type === "multiline" ? "multiline" : "text";
    return m2`<label style=${{ display: "grid", gap: "4px" }} key=${f3.name}>
            <span style=${{ fontSize: "12px", opacity: 0.8 }}>${f3.label || f3.name}</span>
            ${type === "multiline" ? m2`<textarea
                  name=${f3.name}
                  required=${Boolean(f3.required)}
                  rows=${f3.rows || 3}
                  placeholder=${f3.placeholder || ""}
                  aria-invalid=${errors[f3.name] ? "true" : "false"}
                  aria-errormessage=${errors[f3.name] ? `err-${f3.name}` : undefined}
                  disabled=${isDisabled}
                  onInput=${(ev) => setField(f3.name, ev.target.value)}
                  style=${{
      padding: "8px 10px",
      borderRadius: "6px",
      border: errors[f3.name] ? "1px solid var(--nr-dashboard-errorColor, #f87171)" : "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.16))",
      background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
      color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)"
    }}
                >${values[f3.name] ?? ""}</textarea>` : type === "checkbox" ? m2`<input
                  name=${f3.name}
                  type="checkbox"
                  checked=${Boolean(values[f3.name])}
                  disabled=${isDisabled}
                  aria-invalid=${errors[f3.name] ? "true" : "false"}
                  aria-errormessage=${errors[f3.name] ? `err-${f3.name}` : undefined}
                  onChange=${(ev) => setField(f3.name, ev.target.checked)}
                  style=${{
      width: "16px",
      height: "16px"
    }}
                />` : f3.type === "select" ? m2`<select
                  name=${f3.name}
                  required=${Boolean(f3.required)}
                  value=${typeof values[f3.name] === "string" ? values[f3.name] : ""}
                  disabled=${isDisabled}
                  aria-invalid=${errors[f3.name] ? "true" : "false"}
                  aria-errormessage=${errors[f3.name] ? `err-${f3.name}` : undefined}
                  onChange=${(ev) => setField(f3.name, ev.target.value)}
                  style=${{
      padding: "8px 10px",
      borderRadius: "6px",
      border: errors[f3.name] ? "1px solid var(--nr-dashboard-errorColor, #f87171)" : "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.16))",
      background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
      color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)"
    }}
                >
                  ${(f3.options || []).map((opt) => m2`<option value=${opt.value}>${opt.label ?? opt.value}</option>`)}
                </select>` : f3.type === "radio" ? m2`<div style=${{ display: "flex", gap: "10px", flexWrap: "wrap" }}>
                  ${(f3.options || []).map((opt) => m2`<label style=${{ display: "flex", alignItems: "center", gap: "6px", fontSize: "12px" }}>
                      <input
                        type="radio"
                        name=${f3.name}
                        value=${opt.value}
                        required=${Boolean(f3.required)}
                        aria-invalid=${errors[f3.name] ? "true" : "false"}
                        aria-errormessage=${errors[f3.name] ? `err-${f3.name}` : undefined}
                        checked=${values[f3.name] === opt.value}
                        disabled=${isDisabled}
                        onChange=${(ev) => setField(f3.name, ev.target.value)}
                      />
                      <span>${opt.label ?? opt.value}</span>
                    </label>`)}
                </div>` : m2`<input
                  name=${f3.name}
                  type=${type}
                  value=${values[f3.name] ?? ""}
                  required=${Boolean(f3.required)}
                  placeholder=${f3.placeholder || ""}
                  aria-invalid=${errors[f3.name] ? "true" : "false"}
                  aria-errormessage=${errors[f3.name] ? `err-${f3.name}` : undefined}
                  inputMode=${type === "number" ? "decimal" : type === "email" ? "email" : undefined}
                  maxLength=${f3.maxlength || undefined}
                  onInput=${(ev) => setField(f3.name, ev.target.value)}
                  disabled=${isDisabled}
                  style=${{
      padding: "8px 10px",
      borderRadius: "6px",
      border: errors[f3.name] ? "1px solid var(--nr-dashboard-errorColor, #f87171)" : "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.16))",
      background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
      color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)"
    }}
                />`}
            ${typeof f3.maxlength === "number" && type !== "checkbox" && type !== "multiline" && f3.type !== "select" && f3.type !== "radio" ? m2`<span style=${{ fontSize: "11px", opacity: 0.65, alignSelf: "flex-end" }}>
                  ${t4("char_counter", "{used}/{max}", {
      used: typeof values[f3.name] === "string" ? values[f3.name].length : 0,
      max: f3.maxlength ?? 0
    })}
                </span>` : null}
            ${errors[f3.name] ? m2`<span
                  id=${`err-${f3.name}`}
                  role="alert"
                  style=${{ color: "var(--nr-dashboard-errorColor, #f87171)", fontSize: "12px" }}
                >${errors[f3.name]}</span>` : null}
          </label>`;
  })}
    <button
      type="submit"
      disabled=${isDisabled}
      style=${{
    padding: "10px 12px",
    borderRadius: "6px",
    border: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.16))",
    background: "var(--nr-dashboard-widgetColor, #2563eb)",
    color: "var(--nr-dashboard-widgetTextColor, #fff)",
    fontWeight: 600,
    cursor: "pointer"
  }}
    >
      ${c3.submit || t4("submit_label", "Submit")}
    </button>
  </form>`;
}

// node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js
var inner8 = makeInner();
var clone3 = clone;
var bind2 = bind;
var BaseAxisPointer = function() {
  function BaseAxisPointer2() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
    var value2 = axisPointerModel.get("value");
    var status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api;
    if (!forceRender && this._lastValue === value2 && this._lastStatus === status) {
      return;
    }
    this._lastValue = value2;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    var elOption = {};
    this.makeElOption(elOption, value2, axisModel, axisPointerModel, api);
    var graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }
    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group_default;
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry(updateProps2, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value2);
  };
  BaseAxisPointer2.prototype.remove = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.dispose = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
    var animation = axisPointerModel.get("animation");
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === "category";
    var useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      var animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  };
  BaseAxisPointer2.prototype.makeElOption = function(elOption, value2, axisModel, axisPointerModel, api) {};
  BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;
    if (pointerOption) {
      var pointerEl = inner8(group).pointerEl = new exports_graphic[pointerOption.type](clone3(elOption.pointer));
      group.add(pointerEl);
    }
  };
  BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner8(group).labelEl = new Text_default(clone3(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
    var pointerEl = inner8(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps2(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
    var labelEl = inner8(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps2(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype._renderHandle = function(value2) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    var axisPointerModel = this._axisPointerModel;
    var zr = this._api.getZr();
    var handle = this._handle;
    var handleModel = axisPointerModel.getModel("handle");
    var status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    var isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove: function(e4) {
          stop(e4.event);
        },
        onmousedown: bind2(this._onHandleDragMove, this, 0, 0),
        drift: bind2(this._onHandleDragMove, this),
        ondragend: bind2(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
    var handleSize = handleModel.get("size");
    if (!isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value2, isInit);
  };
  BaseAxisPointer2.prototype._moveHandleToValue = function(value2, isInit) {
    updateProps2(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value2, this._axisModel, this._axisPointerModel)));
  };
  BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner8(handle).lastProp = null;
    this._doDispatchAxisPointer();
  };
  BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };
  BaseAxisPointer2.prototype._onHandleDragEnd = function() {
    this._dragging = false;
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var value2 = this._axisPointerModel.get("value");
    this._moveHandleToValue(value2);
    this._api.dispatchAction({
      type: "hideTip"
    });
  };
  BaseAxisPointer2.prototype.clear = function(api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear(this, "_doDispatchAxisPointer");
  };
  BaseAxisPointer2.prototype.doClear = function() {};
  BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };
  return BaseAxisPointer2;
}();
function updateProps2(animationModel, moveAnimation, el, props) {
  if (!propsEqual(inner8(el).lastProp, props)) {
    inner8(el).lastProp = props;
    moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject2(lastProps) && isObject2(newProps)) {
    var equals_1 = true;
    each(newProps, function(item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  var z3 = axisPointerModel.get("z");
  var zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z3 != null && (el.z = z3);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer_default = BaseAxisPointer;

// node_modules/echarts/lib/component/axisPointer/viewHelper.js
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get("type");
  var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  var style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value2 = axisPointerModel.get("value");
  var text = getValueLabel(value2, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  var labelModel = axisPointerModel.getModel("label");
  var paddings = normalizeCssArray2(labelModel.get("padding") || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2];
  var align = labelPos.align;
  align === "right" && (position[0] -= width);
  align === "center" && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position[1] -= height);
  verticalAlign === "middle" && (position[1] -= height / 2);
  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position[0],
    y: position[1],
    style: createTextStyle(labelModel, {
      text,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}
function getValueLabel(value2, axis, ecModel, seriesDataIndices, opt) {
  value2 = axis.scale.parse(value2);
  var text = axis.scale.getLabel({
    value: value2
  }, {
    precision: opt.precision
  });
  var formatter = opt.formatter;
  if (formatter) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value: value2
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each(seriesDataIndices, function(idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });
    if (isString(formatter)) {
      text = formatter.replace("{value}", text);
    } else if (isFunction(formatter)) {
      text = formatter(params_1);
    }
  }
  return text;
}
function getTransformedPosition(axis, value2, layoutInfo) {
  var transform = create();
  rotate(transform, transform, layoutInfo.rotation);
  translate(transform, transform, layoutInfo.position);
  return applyTransform2([axis.dataToCoord(value2), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}
function buildCartesianSingleLabelElOption(value2, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder_default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value2, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p22, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p22[xDimIndex],
    y2: p22[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}

// node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js
var CartesianAxisPointer = function(_super) {
  __extends(CartesianAxisPointer2, _super);
  function CartesianAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisPointer2.prototype.makeElOption = function(elOption, value2, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get("type");
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value2, true));
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout2(grid.model, axisModel);
    buildCartesianSingleLabelElOption(value2, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  CartesianAxisPointer2.prototype.getHandleTransform = function(value2, axisModel, axisPointerModel) {
    var layoutInfo = layout2(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var pos = getTransformedPosition(axisModel.axis, value2, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  CartesianAxisPointer2.prototype.updateHandleTransform = function(transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === "x" ? 0 : 1;
    var currPosition = [transform.x, transform.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    var tooltipOptions = [{
      verticalAlign: "middle"
    }, {
      align: "center"
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };
  return CartesianAxisPointer2;
}(BaseAxisPointer_default);
function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer_default = CartesianAxisPointer;

// node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js
var AxisPointerModel = function(_super) {
  __extends(AxisPointerModel2, _super);
  function AxisPointerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerModel2.type;
    return _this;
  }
  AxisPointerModel2.type = "axisPointer";
  AxisPointerModel2.defaultOption = {
    show: "auto",
    z: 50,
    type: "line",
    snap: false,
    triggerTooltip: true,
    triggerEmphasis: true,
    value: null,
    status: null,
    link: [],
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: "#B9BEC9",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(210,219,238,0.2)"
    },
    label: {
      show: true,
      formatter: null,
      precision: "auto",
      margin: 3,
      color: "#fff",
      padding: [5, 7, 5, 7],
      backgroundColor: "auto",
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
      size: 45,
      margin: 50,
      color: "#333",
      shadowBlur: 3,
      shadowColor: "#aaa",
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      throttle: 40
    }
  };
  return AxisPointerModel2;
}(Component_default);
var AxisPointerModel_default = AxisPointerModel;

// node_modules/echarts/lib/component/axisPointer/globalListener.js
var inner9 = makeInner();
var each4 = each;
function register(key, api, handler) {
  if (env_default.node) {
    return;
  }
  var zr = api.getZr();
  inner9(zr).records || (inner9(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner9(zr).records[key] || (inner9(zr).records[key] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api) {
  if (inner9(zr).initialized) {
    return;
  }
  inner9(zr).initialized = true;
  useHandler("click", curry(doEnter, "click"));
  useHandler("mousemove", curry(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e4) {
      var dis = makeDispatchAction(api);
      each4(inner9(zr).records, function(record) {
        record && cb(record, e4, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}
function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e4, dispatchAction) {
  record.handler("leave", null, dispatchAction);
}
function doEnter(currTrigger, record, e4, dispatchAction) {
  record.handler(currTrigger, e4, dispatchAction);
}
function makeDispatchAction(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  };
  var dispatchAction = function(payload) {
    var pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };
  return {
    dispatchAction,
    pendings
  };
}
function unregister(key, api) {
  if (env_default.node) {
    return;
  }
  var zr = api.getZr();
  var record = (inner9(zr).records || {})[key];
  if (record) {
    inner9(zr).records[key] = null;
  }
}

// node_modules/echarts/lib/component/axisPointer/AxisPointerView.js
var AxisPointerView = function(_super) {
  __extends(AxisPointerView2, _super);
  function AxisPointerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerView2.type;
    return _this;
  }
  AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
    register("axisPointer", api, function(currTrigger, e4, dispatchAction) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: "updateAxisPointer",
          currTrigger,
          x: e4 && e4.offsetX,
          y: e4 && e4.offsetY
        });
      }
    });
  };
  AxisPointerView2.prototype.remove = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.prototype.dispose = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.type = "axisPointer";
  return AxisPointerView2;
}(Component_default2);
var AxisPointerView_default = AxisPointerView;

// node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js
function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  var data = seriesModel.getData();
  var dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
    return {
      point: []
    };
  }
  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis2 = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis2.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
  return {
    point,
    el
  };
}

// node_modules/echarts/lib/component/axisPointer/axisTrigger.js
var inner10 = makeInner();
function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || bind(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  var isIllegalPoint = illegalPoint(point);
  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === "leave" || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  };
  each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  var linkTriggers = {};
  each(axesInfo, function(tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value2, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value2;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each(axisInfo.seriesModels, function(series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;
    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value2, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value2, axis.type === "category" ? 0.5 : null);
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    var diff = value2 - seriesNestestValue;
    var dist3 = Math.abs(diff);
    if (dist3 <= minDist) {
      if (dist3 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist3;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value2, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value2,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value2) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value2,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = [];
  each(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: "hideTip"
    });
    return;
  }
  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  var zr = api.getZr();
  var highDownKey = "axisPointerLastHighlights";
  var lastHighlights = inner10(zr)[highDownKey] || {};
  var newHighlights = inner10(zr)[highDownKey] = {};
  each(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === "show" && axisInfo.triggerEmphasis && each(option.seriesDataIndices, function(batchItem) {
      var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  var toHighlight = [];
  var toDownplay = [];
  each(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i3 = 0;i3 < (inputAxesInfo || []).length; i3++) {
    var inputAxisInfo = inputAxesInfo[i3];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

// node_modules/echarts/lib/component/axisPointer/install.js
function install9(registers) {
  AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default);
  registers.registerComponentModel(AxisPointerModel_default);
  registers.registerComponentView(AxisPointerView_default);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link;
      if (link && !isArray(link)) {
        option.axisPointer.link = [link];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}

// node_modules/echarts/lib/component/grid/install.js
function install10(registers) {
  use(install4);
  use(install9);
}
// node_modules/echarts/lib/component/helper/listComponent.js
function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray2(componentModel.get("padding"));
  var style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect_default({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}

// node_modules/echarts/lib/component/tooltip/TooltipModel.js
var TooltipModel = function(_super) {
  __extends(TooltipModel2, _super);
  function TooltipModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipModel2.type;
    return _this;
  }
  TooltipModel2.type = "tooltip";
  TooltipModel2.dependencies = ["axisPointer"];
  TooltipModel2.defaultOption = {
    z: 60,
    show: true,
    showContent: true,
    trigger: "item",
    triggerOn: "mousemove|click",
    alwaysShowContent: false,
    displayMode: "single",
    renderMode: "auto",
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: "#fff",
    shadowBlur: 10,
    shadowColor: "rgba(0, 0, 0, .2)",
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    borderRadius: 4,
    borderWidth: 1,
    padding: null,
    extraCssText: "",
    axisPointer: {
      type: "line",
      axis: "auto",
      animation: "auto",
      animationDurationUpdate: 200,
      animationEasingUpdate: "exponentialOut",
      crossStyle: {
        color: "#999",
        width: 1,
        type: "dashed",
        textStyle: {}
      }
    },
    textStyle: {
      color: "#666",
      fontSize: 14
    }
  };
  return TooltipModel2;
}(Component_default);
var TooltipModel_default = TooltipModel;

// node_modules/echarts/lib/component/tooltip/helper.js
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env_default.domSupported) {
    return;
  }
  var style = document.documentElement.style;
  for (var i3 = 0, len2 = styleProps.length;i3 < len2; i3++) {
    if (styleProps[i3] in style) {
      return styleProps[i3];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}

// node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env_default.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = "";
  var transformStyle = CSS_TRANSFORM_VENDOR + ":";
  var rotateDeg;
  if (indexOf(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
  } else {
    positionStyle += "left:50%";
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
  }
  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;z-index:-1;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
  return '<div style="' + styleCss.join("") + '"></div>';
}
function assembleTransition(duration, onlyFade) {
  var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env_default.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x3, y3, toString2) {
  var x0 = x3.toFixed(0) + "px";
  var y0 = y3.toFixed(0) + "px";
  if (!env_default.transformSupported) {
    return toString2 ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
  }
  var is3d = env_default.transform3dSupported;
  var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
  return toString2 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get("fontSize");
  var color = textStyleModel.getTextColor();
  color && cssText.push("color:" + color);
  cssText.push("font:" + textStyleModel.getFont());
  var lineHeight = retrieve2(textStyleModel.get("lineHeight"), Math.round(fontSize * 3 / 2));
  fontSize && cssText.push("line-height:" + lineHeight + "px");
  var shadowColor = textStyleModel.get("textShadowColor");
  var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each(["decoration", "align"], function(name) {
    var val = textStyleModel.get(name);
    val && cssText.push("text-" + name + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get("transitionDuration");
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var shadowBlur = tooltipModel.get("shadowBlur");
  var shadowColor = tooltipModel.get("shadowColor");
  var shadowOffsetX = tooltipModel.get("shadowOffsetX");
  var shadowOffsetY = tooltipModel.get("shadowOffsetY");
  var textStyleModel = tooltipModel.getModel("textStyle");
  var padding = getPaddingFromTooltipModel(tooltipModel, "html");
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each(["width", "color", "radius"], function(name) {
    var borderName = "border-" + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray2(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord(out2, zr, container, zrX, zrY) {
  var zrPainter = zr && zr.painter;
  if (container) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, container, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = function() {
  function TooltipHTMLContent2(api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._alwaysShowContent = false;
    this._firstShow = true;
    this._longHide = true;
    if (env_default.wxa) {
      return null;
    }
    var el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendTo = opt.appendTo;
    var container = appendTo && (isString(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction(appendTo) && appendTo(api.getDom()));
    makeStyleCoord(this._styleCoord, zr, container, api.getWidth() / 2, api.getHeight() / 2);
    (container || api.getDom()).appendChild(el);
    this._api = api;
    this._container = container;
    var self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e4) {
      e4 = e4 || window.event;
      if (!self2._enterable) {
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e4, true);
        handler.dispatch("mousemove", e4);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  TooltipHTMLContent2.prototype.update = function(tooltipModel) {
    if (!this._container) {
      var container = this._api.getDom();
      var position = getComputedStyle(container, "position");
      var domStyle = container.style;
      if (domStyle.position !== "absolute" && position !== "absolute") {
        domStyle.position = "relative";
      }
    }
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
    this.el.className = tooltipModel.get("className") || "";
  };
  TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var style = el.style;
    var styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };
  TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
    var el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    var arrow = "";
    if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray(content)) {
        content = [content];
      }
      for (var i3 = 0;i3 < content.length; i3++) {
        if (isDom(content[i3]) && content[i3].parentNode !== el) {
          el.appendChild(content[i3]);
        }
      }
      if (arrow && el.childNodes.length) {
        var arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  };
  TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipHTMLContent2.prototype.getSize = function() {
    var el = this.el;
    return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];
  };
  TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
    if (!this.el) {
      return;
    }
    var styleCoord = this._styleCoord;
    makeStyleCoord(styleCoord, this._zr, this._container, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each(transforms, function(transform) {
        style_1[transform[0]] = transform[1];
      });
    }
  };
  TooltipHTMLContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipHTMLContent2.prototype.hide = function() {
    var _this = this;
    var style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env_default.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(function() {
      return _this._longHide = true;
    }, 500);
  };
  TooltipHTMLContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipHTMLContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipHTMLContent2.prototype.dispose = function() {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var parentNode = this.el.parentNode;
    parentNode && parentNode.removeChild(this.el);
    this.el = this._container = null;
  };
  return TooltipHTMLContent2;
}();
var TooltipHTMLContent_default = TooltipHTMLContent;

// node_modules/echarts/lib/component/tooltip/TooltipRichContent.js
var TooltipRichContent = function() {
  function TooltipRichContent2(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._alwaysShowContent = false;
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord2(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  TooltipRichContent2.prototype.update = function(tooltipModel) {
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
  };
  TooltipRichContent2.prototype.show = function() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  };
  TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;
    if (isObject2(content)) {
      throwError("Passing DOM nodes as content is not supported in richText tooltip!");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    var textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new Text_default({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    var self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  };
  TooltipRichContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipRichContent2.prototype.getSize = function() {
    var el = this.el;
    var bounding = this.el.getBoundingRect();
    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };
  TooltipRichContent2.prototype.moveTo = function(x3, y3) {
    var el = this.el;
    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord2(styleCoord, this._zr, x3, y3);
      x3 = styleCoord[0];
      y3 = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style);
      el.x = x3 + borderWidth + shadowOuterSize.left;
      el.y = y3 + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  TooltipRichContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipRichContent2.prototype.hide = function() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  };
  TooltipRichContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipRichContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipRichContent2.prototype.dispose = function() {
    this._zr.remove(this.el);
  };
  return TooltipRichContent2;
}();
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord2(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent_default = TooltipRichContent;

// node_modules/echarts/lib/component/tooltip/TooltipView.js
var proxyRect = new Rect_default({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});
var TooltipView = function(_super) {
  __extends(TooltipView2, _super);
  function TooltipView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipView2.type;
    return _this;
  }
  TooltipView2.prototype.init = function(ecModel, api) {
    if (env_default.node || !api.getDom()) {
      return;
    }
    var tooltipModel = ecModel.getComponent("tooltip");
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent_default(api) : new TooltipHTMLContent_default(api, {
      appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true)
    });
  };
  TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
    if (env_default.node || !api.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear(this, "_updatePosition");
    }
  };
  TooltipView2.prototype._initGlobalListener = function() {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind(function(currTrigger, e4, dispatchAction) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e4, dispatchAction);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction);
        }
      }
    }, this));
  };
  TooltipView2.prototype._keepShow = function() {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    var triggerOn = tooltipModel.get("triggerOn");
    if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env_default.node || !api.getDom()) {
      return;
    }
    var dispatchAction = makeDispatchAction2(payload, api);
    this._ticket = "";
    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);
    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }
      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      api.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction);
    }
  };
  TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;
    if (this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction2(payload, api));
    }
  };
  TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  };
  TooltipView2.prototype._tryShow = function(e4, dispatchAction) {
    var el = e4.target;
    var tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e4.offsetX;
    this._lastY = e4.offsetY;
    var dataByCoordSys = e4.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e4);
    } else if (el) {
      var ecData = getECData(el);
      if (ecData.ssrType === "legend") {
        return;
      }
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el, function(target) {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);
      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e4, seriesDispatcher_1, dispatchAction);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e4, cmptDispatcher_1, dispatchAction);
      } else {
        this._hide(dispatchAction);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction);
    }
  };
  TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
    var delay = tooltipModel.get("showDelay");
    cb = bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };
  TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e4) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e4.offsetX, e4.offsetY];
    var singleTooltipModel = buildTooltipModel([e4.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator;
    each(dataByCoordSys, function(itemCoordSys) {
      each(itemCoordSys.dataByAxis, function(axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        var axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each(axisItem.seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;
          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend({
              valueFormatter
            }, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e4.position;
    var orderMode = singleTooltipModel.get("order");
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === "richText" ? `

` : "<br/>";
    var allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  };
  TooltipView2.prototype._showSeriesItemTooltip = function(e4, dispatcher, dispatchAction) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher);
    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e4.positionDefault;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator;
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get("order");
    var valueFormatter = tooltipModel.get("valueFormatter");
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({
      valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e4.offsetX, e4.offsetY, e4.position, e4.target, markupStyleCreator);
    });
    dispatchAction({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  };
  TooltipView2.prototype._showComponentItemTooltip = function(e4, el, dispatchAction) {
    var isHTMLRenderMode = this._renderMode === "html";
    var ecData = getECData(el);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};
    var encodeHTMLContent = tooltipOpt.encodeHTMLContent;
    if (isString(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
      encodeHTMLContent = true;
    }
    if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {
      tooltipOpt = clone(tooltipOpt);
      tooltipOpt.content = encodeHTML(tooltipOpt.content);
    }
    var tooltipModelCascade = [tooltipOpt];
    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e4.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get("content");
    var asyncTicket = Math.random() + "";
    var markupStyleCreator = new TooltipMarkupStyleCreator;
    this._showOrMove(subTooltipModel, function() {
      var formatterParams = clone(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e4.offsetX, e4.offsetY, e4.position, el, markupStyleCreator);
    });
    dispatchAction({
      type: "showTip",
      from: this.uid
    });
  };
  TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x3, y3, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    var tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    var formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    var html = defaultHtml;
    var nearPoint = this._getNearestPoint([x3, y3], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    var nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString(formatter)) {
        var useUTC = tooltipModel.ecModel.get("useUTC");
        var params0 = isArray(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html = formatter;
        if (isTimeAxis) {
          html = format(params0.axisValue, html, useUTC);
        }
        html = formatTpl(html, params, true);
      } else if (isFunction(formatter)) {
        var callback = bind(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x3, y3, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }
    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x3, y3, tooltipContent, params, el);
  };
  TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger, borderColor) {
    if (trigger === "axis" || isArray(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };
  TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x3, y3, content, params, el) {
    var viewWidth = this._api.getWidth();
    var viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    var contentSize = content.getSize();
    var align = tooltipModel.get("align");
    var vAlign = tooltipModel.get("verticalAlign");
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction(positionExpr)) {
      positionExpr = positionExpr([x3, y3], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray(positionExpr)) {
      x3 = parsePercent2(positionExpr[0], viewWidth);
      y3 = parsePercent2(positionExpr[1], viewHeight);
    } else if (isObject2(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x3 = layoutRect.x;
      y3 = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString(positionExpr) && el) {
      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x3 = pos[0];
      y3 = pos[1];
    } else {
      var pos = refixTooltipPosition(x3, y3, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x3 = pos[0];
      y3 = pos[1];
    }
    align && (x3 -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y3 -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x3, y3, content, viewWidth, viewHeight);
      x3 = pos[0];
      y3 = pos[1];
    }
    content.moveTo(x3, y3);
  };
  TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, function(lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, function(lastIdxItem, j3) {
          var newIdxItem = newIndices[j3];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each(lastItem.seriesDataIndices, function(idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };
  TooltipView2.prototype._hide = function(dispatchAction) {
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: "hideTip",
      from: this.uid
    });
  };
  TooltipView2.prototype.dispose = function(ecModel, api) {
    if (env_default.node || !api.getDom()) {
      return;
    }
    clear(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api);
  };
  TooltipView2.type = "tooltip";
  return TooltipView2;
}(Component_default2);
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model_default(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model_default(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (var i3 = modelCascade.length - 1;i3 >= 0; i3--) {
    var tooltipOpt = modelCascade[i3];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model_default) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model_default(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction2(payload, api) {
  return payload.dispatchAction || bind(api.dispatchAction, api);
}
function refixTooltipPosition(x3, y3, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  if (gapH != null) {
    if (x3 + width + gapH + 2 > viewWidth) {
      x3 -= width + gapH;
    } else {
      x3 += gapH;
    }
  }
  if (gapV != null) {
    if (y3 + height + gapV > viewHeight) {
      y3 -= height + gapV;
    } else {
      y3 += gapV;
    }
  }
  return [x3, y3];
}
function confineTooltipPosition(x3, y3, content, viewWidth, viewHeight) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  x3 = Math.min(x3 + width, viewWidth) - width;
  y3 = Math.min(y3 + height, viewHeight) - height;
  x3 = Math.max(x3, 0);
  y3 = Math.max(y3, 0);
  return [x3, y3];
}
function calcTooltipPosition(position, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x3 = 0;
  var y3 = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  switch (position) {
    case "inside":
      x3 = rect.x + rectWidth / 2 - domWidth / 2;
      y3 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x3 = rect.x + rectWidth / 2 - domWidth / 2;
      y3 = rect.y - domHeight - offset;
      break;
    case "bottom":
      x3 = rect.x + rectWidth / 2 - domWidth / 2;
      y3 = rect.y + rectHeight + offset;
      break;
    case "left":
      x3 = rect.x - domWidth - offset;
      y3 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x3 = rect.x + rectWidth + offset;
      y3 = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x3, y3];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];
  if (!model) {
    return;
  }
  var view = api.getViewOfComponentModel(model);
  var el;
  view.group.traverse(function(subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView_default = TooltipView;

// node_modules/echarts/lib/component/tooltip/install.js
function install11(registers) {
  use(install9);
  registers.registerComponentModel(TooltipModel_default);
  registers.registerComponentView(TooltipView_default);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop);
}
// node_modules/echarts/lib/component/title/install.js
var TitleModel = function(_super) {
  __extends(TitleModel2, _super);
  function TitleModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  TitleModel2.type = "title";
  TitleModel2.defaultOption = {
    z: 6,
    show: true,
    text: "",
    target: "blank",
    subtext: "",
    subtarget: "blank",
    left: 0,
    top: 0,
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: "bold",
      color: "#464646"
    },
    subtextStyle: {
      fontSize: 12,
      color: "#6E7079"
    }
  };
  return TitleModel2;
}(Component_default);
var TitleView = function(_super) {
  __extends(TitleView2, _super);
  function TitleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleView2.type;
    return _this;
  }
  TitleView2.prototype.render = function(titleModel, ecModel, api) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    var group = this.group;
    var textStyleModel = titleModel.getModel("textStyle");
    var subtextStyleModel = titleModel.getModel("subtextStyle");
    var textAlign = titleModel.get("textAlign");
    var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    var textEl = new Text_default({
      style: createTextStyle(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get("subtext");
    var subTextEl = new Text_default({
      style: createTextStyle(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get("link");
    var sublink = titleModel.get("sublink");
    var triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link) {
      textEl.on("click", function() {
        windowOpen(link, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    var rect = new Rect_default({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };
  TitleView2.type = "title";
  return TitleView2;
}(Component_default2);
function install12(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}
// node_modules/echarts/lib/component/legend/LegendModel.js
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel = function(_super) {
  __extends(LegendModel2, _super);
  function LegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  LegendModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  };
  LegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    this._updateSelector(option);
  };
  LegendModel2.prototype._updateSelector = function(option) {
    var selector = option.selector;
    var ecModel = this.ecModel;
    if (selector === true) {
      selector = option.selector = ["all", "inverse"];
    }
    if (isArray(selector)) {
      each(selector, function(item, index) {
        isString(item) && (item = {
          type: item
        });
        selector[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };
  LegendModel2.prototype.optionUpdated = function() {
    this._updateData(this.ecModel);
    var legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      var hasSelected = false;
      for (var i3 = 0;i3 < legendData.length; i3++) {
        var name_1 = legendData[i3].get("name");
        if (this.isSelected(name_1)) {
          this.select(name_1);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  };
  LegendModel2.prototype._updateData = function(ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;
      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    var rawData = this.get("data") || potentialData;
    var legendNameMap = createHashMap();
    var legendData = map(rawData, function(dataItem) {
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      if (legendNameMap.get(dataItem.name)) {
        return null;
      }
      legendNameMap.set(dataItem.name, true);
      return new Model_default(dataItem, this, this.ecModel);
    }, this);
    this._data = filter(legendData, function(item) {
      return !!item;
    });
  };
  LegendModel2.prototype.getData = function() {
    return this._data;
  };
  LegendModel2.prototype.select = function(name) {
    var selected = this.option.selected;
    var selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      var data = this._data;
      each(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name] = true;
  };
  LegendModel2.prototype.unSelect = function(name) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name] = false;
    }
  };
  LegendModel2.prototype.toggleSelected = function(name) {
    var selected = this.option.selected;
    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }
    this[selected[name] ? "unSelect" : "select"](name);
  };
  LegendModel2.prototype.allSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  };
  LegendModel2.prototype.inverseSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each(data, function(dataItem) {
      var name = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      selected[name] = !selected[name];
    });
  };
  LegendModel2.prototype.isSelected = function(name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  };
  LegendModel2.prototype.getOrient = function() {
    return this.get("orient") === "vertical" ? {
      index: 1,
      name: "vertical"
    } : {
      index: 0,
      name: "horizontal"
    };
  };
  LegendModel2.type = "legend.plain";
  LegendModel2.dependencies = ["series"];
  LegendModel2.defaultOption = {
    z: 4,
    show: true,
    orient: "horizontal",
    left: "center",
    top: 0,
    align: "auto",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: "inherit",
    symbolKeepAspect: true,
    inactiveColor: "#ccc",
    inactiveBorderColor: "#ccc",
    inactiveBorderWidth: "auto",
    itemStyle: {
      color: "inherit",
      opacity: "inherit",
      borderColor: "inherit",
      borderWidth: "auto",
      borderCap: "inherit",
      borderJoin: "inherit",
      borderDashOffset: "inherit",
      borderMiterLimit: "inherit"
    },
    lineStyle: {
      width: "auto",
      color: "inherit",
      inactiveColor: "#ccc",
      inactiveWidth: 2,
      opacity: "inherit",
      type: "inherit",
      cap: "inherit",
      join: "inherit",
      dashOffset: "inherit",
      miterLimit: "inherit"
    },
    textStyle: {
      color: "#333"
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: "sans-serif",
      color: "#666",
      borderWidth: 1,
      borderColor: "#666"
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: "#eee",
        backgroundColor: "#666"
      }
    },
    selectorPosition: "auto",
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel2;
}(Component_default);
var LegendModel_default = LegendModel;

// node_modules/echarts/lib/component/legend/LegendView.js
var curry2 = curry;
var each5 = each;
var Group2 = Group_default;
var LegendView = function(_super) {
  __extends(LegendView2, _super);
  function LegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendView2.type;
    _this.newlineDisabled = false;
    return _this;
  }
  LegendView2.prototype.init = function() {
    this.group.add(this._contentGroup = new Group2);
    this.group.add(this._selectorGroup = new Group2);
    this._isFirstRender = true;
  };
  LegendView2.prototype.getContentGroup = function() {
    return this._contentGroup;
  };
  LegendView2.prototype.getSelectorGroup = function() {
    return this._selectorGroup;
  };
  LegendView2.prototype.render = function(legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    var itemAlign = legendModel.get("align");
    var orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    var selector = legendModel.get("selector", true);
    var selectorPosition = legendModel.get("selectorPosition", true);
    if (selector && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get("padding");
    var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
    var layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };
  LegendView2.prototype.resetInner = function() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };
  LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get("selectedMode");
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each5(legendModel.getData(), function(legendItemModel, dataIndex) {
      var name = legendItemModel.get("name");
      if (!this.newlineDisabled && (name === "" || name === `
`)) {
        var g2 = new Group2;
        g2.newline = true;
        contentGroup.add(g2);
        return;
      }
      var seriesModel = ecModel.getSeriesByName(name)[0];
      if (legendDrawnMap.get(name)) {
        return;
      }
      if (seriesModel) {
        var data = seriesModel.getData();
        var lineVisualStyle = data.getVisual("legendLineStyle") || {};
        var legendIcon = data.getVisual("legendIcon");
        var style = data.getVisual("style");
        var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
        itemGroup.on("click", curry2(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        if (ecModel.ssr) {
          itemGroup.eachChild(function(child) {
            var ecData = getECData(child);
            ecData.seriesIndex = seriesModel.seriesIndex;
            ecData.dataIndex = dataIndex;
            ecData.ssrType = "legend";
          });
        }
        legendDrawnMap.set(name, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            var provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name)) {
              return;
            }
            var idx = provider.indexOfName(name);
            var style2 = provider.getItemVisual(idx, "style");
            var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
            var colorArr = parse2(style2.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style2 = extend(extend({}, style2), {
                fill: stringify(colorArr, "rgba")
              });
            }
            var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api);
            itemGroup2.on("click", curry2(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, null, name, api, excludeSeriesId));
            if (ecModel.ssr) {
              itemGroup2.eachChild(function(child) {
                var ecData = getECData(child);
                ecData.seriesIndex = seriesModel2.seriesIndex;
                ecData.dataIndex = dataIndex;
                ecData.ssrType = "legend";
              });
            }
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
      if (true) {
        if (!legendDrawnMap.get(name)) {
          console.warn(name + " series not exists. Legend data should be same with series name or data name.");
        }
      }
    }, this);
    if (selector) {
      this._createSelector(selector, legendModel, api, orient, selectorPosition);
    }
  };
  LegendView2.prototype._createSelector = function(selector, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each5(selector, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new Text_default({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick: function() {
          api.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect",
            legendId: legendModel.id
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel("selectorLabel");
      var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };
  LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get("itemWidth");
    var itemHeight = legendModel.get("itemHeight");
    var isSelected = legendModel.isSelected(name);
    var iconRotate = legendItemModel.get("symbolRotate");
    var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    var legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
    var itemGroup = new Group2;
    var textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    var textX = itemAlign === "left" ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get("formatter");
    var content = name;
    if (isString(formatter) && formatter) {
      content = formatter.replace("{name}", name != null ? name : "");
    } else if (isFunction(formatter)) {
      content = formatter(name);
    }
    var textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
    itemGroup.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: textColor,
        align: textAlign,
        verticalAlign: "middle"
      }, {
        inheritColor: textColor
      })
    }));
    var hitRect = new Rect_default({
      shape: itemGroup.getBoundingRect(),
      style: {
        fill: "transparent"
      }
    });
    var tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };
  LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector) {
      box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? "width" : "height";
      var hw = orientIdx === 0 ? "height" : "width";
      var yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  LegendView2.prototype.remove = function() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };
  LegendView2.type = "legend.plain";
  return LegendView2;
}(Component_default2);
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each5(style, function(propVal, propName) {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  var itemStyleModel = legendItemModel.getModel("itemStyle");
  var itemStyle = itemStyleModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  var decalStyle = itemStyleModel.getShallow("decal");
  itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  var legendLineModel = legendItemModel.getModel("lineStyle");
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    var borderWidth = legendItemModel.get("inactiveBorderWidth");
    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get("inactiveColor");
    itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {
    itemStyle,
    lineStyle
  };
}
function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || "roundRect";
  var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i3 = 0;
  var len2 = list.length;
  while (i3 < len2 && !(emphasisState = list[i3].states.emphasis)) {
    i3++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView_default = LegendView;

// node_modules/echarts/lib/component/legend/legendFilter.js
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (var i3 = 0;i3 < legendModels.length; i3++) {
        if (!legendModels[i3].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}

// node_modules/echarts/lib/component/legend/legendAction.js
function legendSelectActionHandler(methodName, payload, ecModel) {
  var isAllSelect = methodName === "allSelect" || methodName === "inverseSelect";
  var selectedMap = {};
  var actionLegendIndices = [];
  ecModel.eachComponent({
    mainType: "legend",
    query: payload
  }, function(legendModel) {
    if (isAllSelect) {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
    }
    makeSelectedMap(legendModel, selectedMap);
    actionLegendIndices.push(legendModel.componentIndex);
  });
  var allSelectedMap = {};
  ecModel.eachComponent("legend", function(legendModel) {
    each(selectedMap, function(isSelected, name) {
      legendModel[isSelected ? "select" : "unSelect"](name);
    });
    makeSelectedMap(legendModel, allSelectedMap);
  });
  return isAllSelect ? {
    selected: allSelectedMap,
    legendIndex: actionLegendIndices
  } : {
    name: payload.name,
    selected: allSelectedMap
  };
}
function makeSelectedMap(legendModel, out2) {
  var selectedMap = out2 || {};
  each(legendModel.getData(), function(model) {
    var name = model.get("name");
    if (name === `
` || name === "") {
      return;
    }
    var isItemSelected = legendModel.isSelected(name);
    if (hasOwn(selectedMap, name)) {
      selectedMap[name] = selectedMap[name] && isItemSelected;
    } else {
      selectedMap[name] = isItemSelected;
    }
  });
  return selectedMap;
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
}

// node_modules/echarts/lib/component/legend/installLegendPlain.js
function install13(registers) {
  registers.registerComponentModel(LegendModel_default);
  registers.registerComponentView(LegendView_default);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}

// node_modules/echarts/lib/component/legend/ScrollableLegendModel.js
var ScrollableLegendModel = function(_super) {
  __extends(ScrollableLegendModel2, _super);
  function ScrollableLegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendModel2.type;
    return _this;
  }
  ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };
  ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.call(this, option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  };
  ScrollableLegendModel2.type = "legend.scroll";
  ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: "end",
    pageFormatter: "{current}/{total}",
    pageIcons: {
      horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
      vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
    },
    pageIconColor: "#2f4554",
    pageIconInactiveColor: "#aaa",
    pageIconSize: 15,
    pageTextStyle: {
      color: "#333"
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel2;
}(LegendModel_default);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel_default = ScrollableLegendModel;

// node_modules/echarts/lib/component/legend/ScrollableLegendView.js
var Group3 = Group_default;
var WH = ["width", "height"];
var XY = ["x", "y"];
var ScrollableLegendView = function(_super) {
  __extends(ScrollableLegendView2, _super);
  function ScrollableLegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendView2.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }
  ScrollableLegendView2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.group.add(this._containerGroup = new Group3);
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group3);
  };
  ScrollableLegendView2.prototype.resetInner = function() {
    _super.prototype.resetInner.call(this);
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  };
  ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var self2 = this;
    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get("pageIconSize", true);
    var pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    var pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new Text_default({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + "DataIndex";
      var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind(self2._pageGo, self2, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  };
  ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
    var selectorButtonGap = legendModel.get("selectorButtonGap", true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone(maxSize);
    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  };
  ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      var pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    var mainRect = {
      x: 0,
      y: 0
    };
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect_default({
        shape: clipShape
      }));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    var pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps(contentGroup, {
      x: pageInfo.contentPosition[0],
      y: pageInfo.contentPosition[1]
    }, showController ? legendModel : null);
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  };
  ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  };
  ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each(["pagePrev", "pageNext"], function(name) {
      var key = name + "DataIndex";
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    var pageText = controllerGroup.childOfName("pageText");
    var pageFormatter = legendModel.get("pageFormatter");
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
      current,
      total
    }));
  };
  ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
    var scrollDataIndex = legendModel.get("scrollDataIndex", true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    var children = contentGroup.children();
    var targetItem = children[targetItemIndex];
    var itemCount = children.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (var i3 = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null;i3 <= itemCount; ++i3) {
      currItemInfo = getItemInfo(children[i3]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (var i3 = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null;i3 >= -1; --i3) {
      currItemInfo = getItemInfo(children[i3]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };
  ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    var index;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      var legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  };
  ScrollableLegendView2.type = "legend.scroll";
  return ScrollableLegendView2;
}(LegendView_default);
var ScrollableLegendView_default = ScrollableLegendView;

// node_modules/echarts/lib/component/legend/scrollableLegendAction.js
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}

// node_modules/echarts/lib/component/legend/installLegendScroll.js
function install14(registers) {
  use(install13);
  registers.registerComponentModel(ScrollableLegendModel_default);
  registers.registerComponentView(ScrollableLegendView_default);
  installScrollableLegendAction(registers);
}

// node_modules/echarts/lib/component/legend/install.js
function install15(registers) {
  use(install13);
  use(install14);
}
// src/preact/components/widgets/chart.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_utc = __toESM(require_utc(), 1);
registerEChartsModules([
  install,
  install2,
  install3,
  install6,
  install10,
  install15,
  install11,
  install12
]);
import_dayjs.default.extend(import_utc.default);
var DEFAULT_COLORS = [
  "var(--nr-dashboard-widgetColor, #1F77B4)",
  "var(--nr-dashboard-chartColor1, #AEC7E8)",
  "var(--nr-dashboard-chartColor2, #FF7F0E)",
  "var(--nr-dashboard-chartColor3, #2CA02C)",
  "var(--nr-dashboard-chartColor4, #98DF8A)",
  "var(--nr-dashboard-chartColor5, #D62728)",
  "var(--nr-dashboard-chartColor6, #FF9896)",
  "var(--nr-dashboard-chartColor7, #9467BD)",
  "var(--nr-dashboard-chartColor8, #C5B0D5)",
  "var(--nr-dashboard-chartColor9, #7EB3C6)",
  "var(--nr-dashboard-chartColor10, #BC5879)",
  "var(--nr-dashboard-chartColor11, #6DC2DF)",
  "var(--nr-dashboard-chartColor12, #D7D185)",
  "var(--nr-dashboard-chartColor13, #91CA96)",
  "var(--nr-dashboard-chartColor14, #DEB64D)"
];
function normalizeLook(look) {
  const l3 = (look || "line").toLowerCase();
  if (l3 === "horizontalbar" || l3 === "horizontal-bar")
    return "horizontalBar";
  if (l3 === "bar")
    return "bar";
  if (l3 === "pie")
    return "pie";
  if (l3 === "polar-area" || l3 === "polar")
    return "polar-area";
  if (l3 === "radar")
    return "radar";
  return "line";
}
function toNumber4(value2) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : null;
}
function toPositiveNumber(value2) {
  const n3 = toNumber4(value2);
  return n3 != null && Number.isFinite(n3) ? n3 : undefined;
}
function toOptionalNumber(value2) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : undefined;
}
function cloneData(data) {
  return {
    labels: [...data.labels],
    isTimeSeries: data.isTimeSeries,
    series: data.series.map((s3) => ({ name: s3.name, data: [...s3.data] }))
  };
}
function findSeries(data, name) {
  const found = data.series.find((s3) => s3.name === name);
  if (found)
    return found;
  const created = { name, data: [] };
  data.series.push(created);
  return created;
}
function applyChartPayload(look, payload, prev, windowing) {
  if (!Array.isArray(payload) || payload.length === 0) {
    return { labels: [], series: [], isTimeSeries: false };
  }
  const entry = payload[0];
  const next = cloneData(prev);
  const values = entry.values || entry;
  const seriesArr = Array.isArray(values.series) ? values.series : [];
  const labelsArr = Array.isArray(values.labels) ? values.labels : [];
  const dataArr = Array.isArray(values.data) ? values.data : [];
  if (look === "line" && entry.update) {
    const seriesName = values.series || "";
    const point = values.data;
    if (point && typeof point === "object" && point.x != null && point.y != null) {
      const s3 = findSeries(next, seriesName);
      s3.data.push([Number(point.x), Number(point.y)]);
      next.isTimeSeries = true;
      const remove = Number(entry.remove ?? 0);
      if (Number.isFinite(remove) && remove > 0) {
        s3.data.splice(0, remove);
      }
      const cutoff = windowing?.removeOlderMs;
      if (cutoff && cutoff > 0) {
        const latestTs = Number(point.x);
        const threshold = latestTs - cutoff;
        s3.data = s3.data.filter((p3) => Array.isArray(p3) && p3[0] >= threshold);
      }
      const maxPoints = windowing?.removeOlderPoints;
      if (maxPoints && maxPoints > 0 && s3.data.length > maxPoints) {
        s3.data.splice(0, s3.data.length - maxPoints);
      }
    }
    return next;
  }
  next.labels = labelsArr;
  next.series = [];
  next.isTimeSeries = false;
  seriesArr.forEach((name, idx) => {
    const seriesData = Array.isArray(dataArr[idx]) ? dataArr[idx] : [];
    const mapped = seriesData.map((d3) => {
      if (d3 && typeof d3 === "object" && "x" in d3 && "y" in d3) {
        next.isTimeSeries = true;
        const asPoint = d3;
        return [Number(asPoint.x), Number(asPoint.y)];
      }
      const n3 = toNumber4(d3);
      return n3 ?? 0;
    });
    next.series.push({ name, data: mapped });
  });
  if (windowing && next.isTimeSeries) {
    let maxTs = 0;
    next.series.forEach((s3) => {
      s3.data.forEach((pt) => {
        if (Array.isArray(pt) && typeof pt[0] === "number") {
          if (pt[0] > maxTs)
            maxTs = pt[0];
        }
      });
    });
    const threshold = windowing.removeOlderMs && maxTs > 0 ? maxTs - windowing.removeOlderMs : undefined;
    next.series = next.series.map((s3) => {
      let filtered = s3.data;
      if (threshold) {
        filtered = filtered.filter((pt) => Array.isArray(pt) && pt[0] >= threshold);
      }
      const maxPoints = windowing.removeOlderPoints;
      if (maxPoints && maxPoints > 0 && filtered.length > maxPoints) {
        filtered = filtered.slice(filtered.length - maxPoints);
      }
      return { ...s3, data: filtered };
    });
  }
  return next;
}
function buildLineSeries(control, data) {
  const interpolate2 = (control.interpolate || "").toString();
  const dot = Boolean(control.dot);
  const spanGaps = Boolean(control.spanGaps);
  const stacked = Boolean(control.stacked);
  const stackName = control.stackKey || (stacked ? "stack" : undefined);
  return data.series.map((s3) => {
    const series = {
      type: "line",
      name: s3.name,
      data: s3.data,
      showSymbol: dot,
      smooth: interpolate2 === "cubic" || interpolate2 === "bezier" || interpolate2 === "monotone",
      connectNulls: spanGaps
    };
    if (stackName)
      series.stack = stackName;
    if (interpolate2 === "monotone") {
      series.smoothMonotone = "x";
    }
    if (interpolate2 === "step") {
      series.step = "middle";
      series.smooth = false;
    }
    return series;
  });
}
function buildBarSeries(look, data, stacked, stackKey, stackMap, showStackLabel, valueFormatter) {
  const stackName = stackKey || (stacked ? "stack" : undefined);
  return data.series.map((s3) => {
    const series = {
      type: "bar",
      name: s3.name,
      data: s3.data,
      label: showStackLabel ? {
        show: true,
        position: "inside",
        formatter: ({ value: value2 }) => valueFormatter(Number(value2))
      } : { show: false }
    };
    if (look === "horizontalBar") {
      series.type = "bar";
    }
    const stackForSeries = stackMap?.[s3.name] || stackName;
    if (stackForSeries)
      series.stack = stackForSeries;
    return series;
  });
}
function buildPieSeries(look, control, data, colors) {
  const radiusInner = Math.max(0, Number(control.cutout ?? 0));
  const hasMultiple = data.series.length > 1;
  const radiusBase = radiusInner > 0 ? [radiusInner, "70%"] : [0, "70%"];
  const startAngle = toPositiveNumber(control.startAngle);
  return data.series.map((s3, idx) => {
    const radius = hasMultiple ? [radiusInner, `${50 + idx * 15}%`] : radiusBase;
    const dataWithColor = s3.data.map((val, i3) => {
      const base2 = colors[i3 % colors.length];
      if (look === "polar-area" && control.useDifferentColor) {
        const alpha = Math.max(0.25, 0.7 - i3 * 0.06);
        const hex = Math.round(alpha * 255).toString(16).padStart(2, "0");
        return { name: data.labels[i3], value: s3.data[i3] ?? 0, itemStyle: { color: `${base2}${hex}` } };
      }
      return { name: data.labels[i3], value: s3.data[i3] ?? 0 };
    });
    return {
      type: "pie",
      name: s3.name,
      radius,
      startAngle,
      roseType: look === "polar-area" ? "area" : undefined,
      data: dataWithColor,
      label: { show: true }
    };
  });
}
function buildRadarSeries(data) {
  return data.series.map((s3) => ({
    type: "radar",
    name: s3.name,
    data: [{ value: s3.data }]
  }));
}
function buildChartOption(control, data, lang, t4, hiddenSeries) {
  const look = normalizeLook(control.look);
  const colors = control.colors && control.colors.length > 0 ? control.colors : DEFAULT_COLORS;
  const useUTC = Boolean(control.useUTC);
  const animation = control.animation !== false;
  const stacked = Boolean(control.stacked);
  const stackKey = control.stackKey;
  const stackMap = control.stackMap;
  const stackLabel = Boolean(control.stackLabel && stacked);
  const animationDuration = toOptionalNumber(control.animationDuration);
  const option = {
    color: colors,
    animation,
    animationDuration,
    useUTC,
    textStyle: { color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)" },
    tooltip: {
      trigger: look === "pie" || look === "polar-area" ? "item" : "axis",
      axisPointer: stacked && (look === "bar" || look === "horizontalBar") ? { type: "shadow" } : undefined,
      formatter: (params) => {
        const items = Array.isArray(params) ? params : [params];
        if (!items.length)
          return "";
        const first = items[0];
        const axisValue = first.axisValueLabel ?? first.name;
        const header = data.isTimeSeries ? timeFormatter(Number(first.axisValue ?? first.value?.[0] ?? Date.now())) : axisValue;
        const lines = items.map((it) => {
          const val = Array.isArray(it.value) ? it.value[1] : it.value;
          return `${it.marker || ""}${it.seriesName}: ${valueFormatter(Number(val))}`;
        });
        return [header, ...lines].join(`
`);
      }
    },
    legend: control.legend ? {
      selected: hiddenSeries ? Array.from(hiddenSeries).reduce((acc, name) => {
        acc[name] = false;
        return acc;
      }, {}) : undefined
    } : { show: false }
  };
  const valueFormatter = (v3) => formatNumber(v3, lang ?? undefined);
  const timeFormatter = (ts) => {
    const d3 = useUTC ? import_dayjs.default.utc(ts) : import_dayjs.default(ts);
    const fmt = control.xformat;
    if (!fmt || fmt === "auto") {
      return d3.isValid() ? d3.calendar(undefined, {
        sameDay: "HH:mm:ss",
        lastDay: "MMM D HH:mm",
        lastWeek: "MMM D HH:mm",
        sameElse: "lll",
        nextDay: "HH:mm",
        nextWeek: "MMM D HH:mm"
      }) : String(ts);
    }
    return d3.isValid() ? d3.format(fmt) : String(ts);
  };
  if (look === "line" || look === "bar" || look === "horizontalBar") {
    const categoryAxis2 = {
      type: data.isTimeSeries ? "time" : "category",
      data: data.isTimeSeries ? undefined : data.labels,
      axisLabel: {
        formatter: data.isTimeSeries ? (val) => timeFormatter(val) : (val) => String(val ?? ""),
        color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)"
      },
      axisLine: { lineStyle: { color: "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.18))" } }
    };
    const valueAxis2 = {
      type: "value",
      min: toNumber4(control.ymin) ?? undefined,
      max: toNumber4(control.ymax) ?? undefined,
      axisLabel: {
        formatter: (val) => valueFormatter(val),
        color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)"
      },
      splitLine: {
        lineStyle: { color: "var(--nr-dashboard-chartSplitLineColor, rgba(255,255,255,0.1))" }
      },
      axisLine: { lineStyle: { color: "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.18))" } }
    };
    if (look === "horizontalBar") {
      option.yAxis = categoryAxis2;
      option.xAxis = valueAxis2;
    } else {
      option.xAxis = categoryAxis2;
      option.yAxis = valueAxis2;
    }
    option.grid = { left: 10, right: 10, top: 24, bottom: 20, containLabel: true };
    option.series = look === "line" ? buildLineSeries(control, data) : buildBarSeries(look, data, stacked, stackKey, stackMap, stackLabel, valueFormatter);
  } else if (look === "pie" || look === "polar-area") {
    option.series = buildPieSeries(look, control, data, colors);
  } else if (look === "radar") {
    const radarStartAngle = toOptionalNumber(control.radarStartAngle);
    const radarSplitNumber = toOptionalNumber(control.radarSplitNumber);
    const radarShape = control.radarShape === "circle" ? "circle" : control.radarShape === "polygon" ? "polygon" : undefined;
    option.radar = {
      indicator: data.labels.map((l3) => ({ name: l3 })),
      startAngle: radarStartAngle,
      splitNumber: radarSplitNumber,
      shape: radarShape,
      axisName: { color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)" },
      splitLine: { lineStyle: { color: "var(--nr-dashboard-chartSplitLineColor, rgba(255,255,255,0.15))" } },
      splitArea: {
        areaStyle: {
          color: [
            "var(--nr-dashboard-chartSplitAreaLow, rgba(255,255,255,0.02))",
            "var(--nr-dashboard-chartSplitAreaHigh, rgba(255,255,255,0.05))"
          ]
        }
      },
      axisLine: { lineStyle: { color: "var(--nr-dashboard-widgetBorderColor, rgba(255,255,255,0.18))" } }
    };
    option.series = buildRadarSeries(data);
  }
  option.title = {
    show: true,
    text: control.label || control.name || t4("chart_label", "Chart"),
    textStyle: { color: "var(--nr-dashboard-widgetTextColor, #e9ecf1)", fontSize: 14, fontWeight: 600 }
  };
  return option;
}
function ChartWidget(props) {
  const { control, index, disabled } = props;
  const c3 = control;
  const { t: t4, lang } = useI18n();
  const look = normalizeLook(c3.look);
  const [data, setData] = d2({ labels: [], series: [], isTimeSeries: false });
  const [hidden, setHidden] = d2(new Set);
  const chartRef = A2(null);
  const label = c3.label || c3.name || t4("chart_label_index", "Chart {index}", { index: index + 1 });
  const removeOlderMs = T2(() => {
    const base2 = Number(c3.removeOlder);
    const unit = Number(c3.removeOlderUnit ?? 1);
    if (!Number.isFinite(base2) || base2 <= 0)
      return;
    return base2 * unit * 1000;
  }, [c3.removeOlder, c3.removeOlderUnit]);
  const removeOlderPoints = T2(() => {
    const n3 = Number(c3.removeOlderPoints);
    return Number.isFinite(n3) && n3 > 0 ? n3 : undefined;
  }, [c3.removeOlderPoints]);
  y2(() => {
    setData((prev) => applyChartPayload(look, c3.value, prev, { removeOlderMs, removeOlderPoints }));
  }, [c3.value, look, removeOlderMs, removeOlderPoints]);
  y2(() => {
    setHidden((prev) => {
      const next = new Set;
      prev.forEach((name) => {
        if (data.series.some((s3) => s3.name === name))
          next.add(name);
      });
      return next;
    });
  }, [data.series]);
  const option = T2(() => buildChartOption({ ...c3, label }, data, lang, t4, hidden), [c3, data, label, lang, t4, hidden]);
  const { instance } = useECharts(chartRef, [option], () => option, (chart) => {
    chart.off("legendselectchanged");
    chart.on("legendselectchanged", (ev) => {
      const selected = ev.selected;
      if (!selected)
        return;
      setHidden(new Set(Object.entries(selected).filter(([, v3]) => v3 === false).map(([name]) => name)));
    });
  });
  y2(() => {
    if (!instance)
      return;
    instance.setOption(option, { replaceMerge: ["series", "legend"] });
  }, [instance, option]);
  return m2`<div
    class=${c3.className || ""}
    style=${{
    width: "100%",
    minHeight: "260px",
    opacity: disabled ? 0.55 : 1,
    pointerEvents: disabled ? "none" : "auto"
  }}
    aria-label=${t4("chart_value_label", "{label} chart", { label })}
  >
    <div ref=${chartRef} style=${{ width: "100%", height: "260px" }}></div>
  </div>`;
}

// src/preact/components/widget-preview.ts
function widgetLabel(control, idx) {
  const asAny = control;
  if (asAny.label)
    return String(asAny.label);
  if (asAny.name)
    return String(asAny.name);
  if (asAny.type)
    return String(asAny.type);
  if (asAny.id)
    return `Widget ${asAny.id}`;
  return `Widget ${idx + 1}`;
}
function WidgetPreview(props) {
  const { control, index } = props;
  const asAny = control;
  const type = (asAny.type || "widget").toString();
  const label = widgetLabel(control, index);
  const value2 = (asAny.value ?? asAny.text ?? "").toString();
  const [ref, size] = useElementSize();
  const { t: t4 } = useI18n();
  if (type === "text" || type === "ui_text") {
    return m2`<div
      ref=${ref}
      style=${{ display: "flex", flexDirection: "column", gap: "4px" }}
    >
      <strong>${label}</strong>
      <span style=${{ opacity: 0.9 }}>${value2 || t4("widget_preview_empty", "(no value yet)")}</span>
      <span style=${{ opacity: 0.55, fontSize: "10px" }}>
        ${Math.round(size.width)}${Math.round(size.height)} px
      </span>
    </div>`;
  }
  return m2`<div
    ref=${ref}
    style=${{ display: "flex", justifyContent: "space-between", gap: "6px" }}
  >
    <span>${label}</span>
    <span style=${{ opacity: 0.65, fontSize: "11px" }}>${type}</span>
  </div>`;
}

// src/preact/lib/sizes.ts
function coerceNumber2(value2, fallback) {
  const n3 = Number(value2);
  return Number.isFinite(n3) ? n3 : fallback;
}
function resolveSizes(site) {
  const base2 = {
    sx: 48,
    sy: 48,
    gx: 6,
    gy: 6,
    cx: 6,
    cy: 6,
    px: 0,
    py: 0,
    columns: 24,
    dense: false,
    layoutMode: "masonry"
  };
  if (typeof window !== "undefined" && window.innerWidth < 350) {
    base2.sx = 42;
    base2.sy = 42;
  }
  const sizes = site?.sizes;
  if (!sizes)
    return base2;
  return {
    sx: coerceNumber2(sizes.sx, base2.sx),
    sy: coerceNumber2(sizes.sy, base2.sy),
    gx: coerceNumber2(sizes.gx, base2.gx),
    gy: coerceNumber2(sizes.gy, base2.gy),
    cx: coerceNumber2(sizes.cx, base2.cx),
    cy: coerceNumber2(sizes.cy, base2.cy),
    px: coerceNumber2(sizes.px, base2.px),
    py: coerceNumber2(sizes.py, base2.py),
    columns: coerceNumber2(sizes.columns, base2.columns),
    dense: Boolean(sizes.dense ?? base2.dense),
    layoutMode: sizes.layoutMode || base2.layoutMode
  };
}
function getDashboardRoot() {
  if (typeof document === "undefined")
    return null;
  return document.getElementById("nr-dashboard-root") ?? document.getElementById("app") ?? document.documentElement;
}
function applySizesToRoot(sizes, root) {
  if (!root && typeof document === "undefined")
    return;
  const target = root ?? getDashboardRoot();
  if (!target)
    return;
  const entries = [
    ["--nr-dashboard-sx", `${sizes.sx}`],
    ["--nr-dashboard-sy", `${sizes.sy}`],
    ["--nr-dashboard-gx", `${sizes.gx}`],
    ["--nr-dashboard-gy", `${sizes.gy}`],
    ["--nr-dashboard-cx", `${sizes.cx}`],
    ["--nr-dashboard-cy", `${sizes.cy}`],
    ["--nr-dashboard-px", `${sizes.px}`],
    ["--nr-dashboard-py", `${sizes.py}`],
    ["--nr-dashboard-columns", `${sizes.columns}`]
  ];
  entries.forEach(([k3, v3]) => target.style.setProperty(k3, v3));
}

// src/preact/hooks/useSizes.ts
var SizesContext = Q(null);
function SizesProvider({ site, tabId, children }) {
  const [sizes, setSizes] = d2(() => resolveSizes(site));
  const root = typeof document !== "undefined" ? document.getElementById("nr-dashboard-root") ?? document.getElementById("app") : null;
  y2(() => {
    setSizes(resolveSizes(site));
  }, [site]);
  y2(() => {
    if (typeof window === "undefined")
      return;
    const handleResize = () => setSizes(resolveSizes(site));
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [site]);
  y2(() => {
    applySizesToRoot(sizes, root ?? undefined);
    if (typeof window !== "undefined") {
      window.dispatchEvent(new CustomEvent("dashboard:size", { detail: sizes }));
    }
  }, [sizes, root]);
  y2(() => {
    if (typeof window !== "undefined") {
      window.dispatchEvent(new Event("resize"));
    }
  }, [tabId]);
  return m2`<${SizesContext.Provider} value=${sizes}>${children}<//>`;
}
function useSizes() {
  const ctx = x2(SizesContext);
  return ctx ?? resolveSizes(null);
}

// src/preact/components/WidgetFrame.ts
function WidgetFrame({ control, disabled, children }) {
  const sizes = useSizes();
  const padding = Math.max(8, (sizes.py ?? 0) + 4);
  const gap = Math.max(4, sizes.cx ?? 6);
  const controlDisabled = control.disabled === true;
  const controlEnabled = control.enabled;
  const isDisabled = Boolean((disabled ?? controlDisabled) || controlEnabled === false);
  return m2`<div
    class=${`nr-dashboard-widget-frame ${(control.className ?? "").trim()}`.trim()}
    style=${{
    background: "var(--nr-dashboard-widgetBackgroundColor, transparent)",
    border: "1px solid var(--nr-dashboard-widgetBorderColor, transparent)",
    borderRadius: "8px",
    padding: `${padding}px`,
    display: "flex",
    flexDirection: "column",
    gap: `${gap}px`,
    color: "var(--nr-dashboard-widgetTextColor, inherit)",
    opacity: isDisabled ? 0.55 : 1,
    pointerEvents: isDisabled ? "none" : "auto"
  }}
    aria-disabled=${isDisabled}
  >
    ${children}
  </div>`;
}

// src/preact/components/widget-renderer.ts
function getControlType(control) {
  const asAny = control;
  return (asAny.type || asAny.widget || asAny.mode || "").toString().toLowerCase();
}
function WidgetRenderer(props) {
  const { control, index, onEmit } = props;
  const type = getControlType(control);
  const disabled = Boolean(control.disabled === true || control.enabled === false);
  if (type === "text" || type === "ui_text") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${TextWidget} control=${control} index=${index} /></${WidgetFrame}>`;
  }
  if (type === "text-input" || type === "text-input-cr" || type === "ui_text_input") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${TextInputWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "numeric" || type === "ui_numeric") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${NumericWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "dropdown" || type === "ui_dropdown") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${DropdownWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "slider" || type === "ui_slider") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${SliderWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "button" || type === "ui_button") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${ButtonWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "switch" || type === "ui_switch") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${SwitchWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "gauge" || type === "ui_gauge") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${GaugeWidget} control=${control} index=${index} /></${WidgetFrame}>`;
  }
  if (type === "chart" || type === "ui_chart") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${ChartWidget} control=${control} index=${index} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "date" || type === "date-picker" || type === "ui_date_picker") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${DatePickerWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "colour" || type === "color" || type === "ui_colour_picker") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${ColourPickerWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "audio" || type === "ui_audio") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${AudioWidget} control=${control} index=${index} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "toast" || type === "notification" || type === "ui_toast") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${ToastWidget} control=${control} index=${index} /></${WidgetFrame}>`;
  }
  if (type === "link" || type === "ui_link") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${LinkWidget} control=${control} index=${index} disabled=${disabled} /></${WidgetFrame}>`;
  }
  if (type === "template" || type === "ui_template") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${TemplateWidget} control=${control} index=${index} /></${WidgetFrame}>`;
  }
  if (type === "form" || type === "ui_form") {
    return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${FormWidget} control=${control} index=${index} onEmit=${onEmit} disabled=${disabled} /></${WidgetFrame}>`;
  }
  return m2`<${WidgetFrame} control=${control} disabled=${disabled}><${WidgetPreview} control=${control} index=${index} /></${WidgetFrame}>`;
}

// src/preact/components/layout/GroupCard.ts
function GroupCard(props) {
  const { group, index, columnSpan, padding, sizes, onEmit, tabName, layoutMode = "grid", layoutPos } = props;
  ensureLayoutStyles();
  const { t: t4 } = useI18n();
  const header = group.header;
  const title = header?.name || t4("group_label", "Group {index}", { index: index + 1 });
  const items = group.items ?? [];
  const collapseEnabled = Boolean(header?.config?.collapse);
  const groupKey = T2(() => {
    const base2 = `${tabName ?? ""} ${header?.name ?? ""}`.trim();
    return (base2 || header?.id || `group-${index}`).toString().replace(/ /g, "_");
  }, [tabName, header?.name, header?.id, index]);
  const initialCollapsed = T2(() => {
    const flag = header?.config?.collapsed ?? header?.config?.collapse ?? false;
    return flag;
  }, [header?.config]);
  const [collapsed, setCollapsed] = d2(initialCollapsed);
  const toggleCollapse = () => {
    const next = !collapsed;
    setCollapsed(next);
  };
  return m2`<section
    class=${`nr-dashboard-group-card ${header?.config?.className ?? ""}`.trim()}
    data-grid-key=${header?.id ?? index}
    style=${{
    gridColumn: layoutMode === "grid" ? `span ${columnSpan}` : undefined,
    padding: `${padding.y}px ${padding.x}px`,
    position: layoutMode === "masonry" ? "absolute" : undefined,
    left: layoutMode === "masonry" ? `${layoutPos?.left ?? 0}px` : undefined,
    top: layoutMode === "masonry" ? `${layoutPos?.top ?? 0}px` : undefined,
    width: layoutMode === "masonry" ? `${layoutPos?.width ?? "auto"}` : undefined
  }}
  >
    <header
      class="nr-dashboard-group-card__header"
      style=${{
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: "10px",
    minHeight: "28px",
    padding: "6px 8px 4px 8px"
  }}
    >
      <span style=${{ fontWeight: 500, lineHeight: "20px", paddingRight: "8px" }}>${title}</span>
      ${collapseEnabled ? m2`<button
            type="button"
            aria-expanded=${!collapsed}
            aria-label=${collapsed ? t4("expand_group", "Expand group") : t4("collapse_group", "Collapse group")}
            onClick=${toggleCollapse}
            class="nr-dashboard-group-card__collapse"
          >
            <i class=${collapsed ? "fa fa-caret-down" : "fa fa-caret-up"}></i>
          </button>` : null}
    </header>
    ${collapsed ? m2`<div style=${{ opacity: 0.6, fontSize: "12px", padding: "0 12px 12px 12px" }}>${t4("collapsed", "Collapsed")}</div>` : items.length === 0 ? m2`<div style=${{ opacity: 0.6, fontSize: "12px", padding: "0 8px 8px 8px" }}>${t4("no_widgets", "No widgets in this group yet.")}</div>` : m2`<ul
          class="nr-dashboard-group-card__list"
          style=${{
    rowGap: `${sizes.cy}px`,
    columnGap: `${sizes.cx}px`,
    padding: "0 8px 8px 8px"
  }}
        >
          ${items.map((control, ctrlIdx) => m2`<li
                class="nr-dashboard-group-card__item"
                key=${control?.id ?? ctrlIdx}
                style=${{
    padding: `${Math.max(0, padding.y - 6)}px ${Math.max(0, padding.x - 4)}px`
  }}
              >
                <${WidgetRenderer}
                  control=${control}
                  index=${ctrlIdx}
                  onEmit=${onEmit}
                />
              </li>`)}
        </ul>`}
  </section>`;
}

// src/preact/components/layout/GroupGrid.ts
function GroupGrid(props) {
  const { groups, sizes, onEmit, tabName } = props;
  ensureLayoutStyles();
  const { t: t4 } = useI18n();
  const containerRef = A2(null);
  const [positions, setPositions] = d2({});
  const [containerHeight, setContainerHeight] = d2(undefined);
  const layoutMode = sizes.layoutMode === "masonry" ? "masonry" : "grid";
  const visible = groups.filter((group) => {
    const hidden = Boolean(group.header?.config?.hidden);
    return !hidden;
  });
  if (visible.length === 0) {
    return m2`<div style=${{ opacity: 0.7 }}>${t4("no_groups", "No groups in this tab yet.")}</div>`;
  }
  const gridStyles = layoutMode === "masonry" ? {
    position: "relative",
    minHeight: containerHeight ? `${containerHeight}px` : undefined
  } : {
    display: "grid",
    gridTemplateColumns: `repeat(${sizes.columns}, minmax(0, 1fr))`,
    columnGap: `${sizes.gx}px`,
    rowGap: `${sizes.gy}px`,
    alignContent: "start",
    gridAutoFlow: sizes.dense ? "dense" : "row"
  };
  const calcWidth = (span) => {
    const cols = Math.max(1, span);
    return cols * sizes.sx + sizes.px * 2 + (cols - 1) * sizes.gx;
  };
  _2(() => {
    if (layoutMode !== "masonry") {
      setPositions({});
      setContainerHeight(undefined);
      return;
    }
    let cancelled = false;
    const computeLayout = () => {
      if (cancelled)
        return;
      const root = containerRef.current;
      if (!root)
        return;
      const children = Array.from(root.children);
      if (children.length === 0)
        return;
      const availableWidth = Math.max(0, root.clientWidth - sizes.gx * 2);
      const blocks = [{ x: 0, y: sizes.gy, w: availableWidth, h: Infinity, used: false }];
      const assigned = [];
      const blockCache = { [`0:${sizes.gy}`]: blocks[0] };
      const blockSort = (b1, b2) => {
        if (b1.y < b2.y)
          return -1;
        if (b1.y > b2.y)
          return 1;
        return b1.x - b2.x;
      };
      const intersect2 = (r1, r22) => {
        return !(r22.x > r1.x || r22.x + r22.w < r1.x || r22.y > r1.y + r1.h || r22.y + r22.h < r1.y);
      };
      children.forEach((child) => {
        const cw = child.offsetWidth;
        const ch = child.offsetHeight;
        let added = false;
        let blockCacheKey = "";
        for (let i3 = 0;i3 < blocks.length; i3++) {
          const b = blocks[i3];
          if (!b.used && cw <= b.w && ch <= b.h) {
            let clear2 = true;
            for (let j3 = 0;j3 < assigned.length; j3++) {
              const b2 = assigned[j3];
              if (intersect2(b, b2)) {
                blockCacheKey = `${b.x}:${b2.y + b2.h + sizes.gy}`;
                if (!blockCache[blockCacheKey]) {
                  blocks.push({ x: b.x, y: b2.y + b2.h + sizes.gy, w: b.w, h: b.h, used: false });
                  blockCache[blockCacheKey] = blocks[blocks.length - 1];
                  blocks.sort(blockSort);
                }
                clear2 = false;
                break;
              }
            }
            if (!clear2)
              continue;
            b.used = true;
            b.group = child;
            b.assigned = true;
            assigned.push(b);
            added = true;
            clear2 = true;
            const rightBlock = { x: b.x + cw + sizes.gx, y: b.y, w: b.w - sizes.gx - cw, h: b.h, used: false };
            blockCacheKey = `${b.x + cw + sizes.gx}:${b.y}`;
            if (!blockCache[blockCacheKey]) {
              for (let j3 = 0;j3 < assigned.length; j3++) {
                const b3 = assigned[j3];
                if (b3 !== b && b3.x <= rightBlock.x && b3.x + b3.w >= rightBlock.x && b3.y <= rightBlock.y && b3.y + b3.h >= rightBlock.y) {
                  clear2 = false;
                  break;
                }
              }
              if (clear2) {
                blockCache[blockCacheKey] = rightBlock;
                blocks.push(rightBlock);
              }
            }
            blockCacheKey = `${b.x}:${b.y + ch + sizes.gy}`;
            if (!blockCache[blockCacheKey]) {
              blocks.push({ x: b.x, y: b.y + ch + sizes.gy, w: b.w, h: b.h, used: false });
              blockCache[blockCacheKey] = blocks[blocks.length - 1];
            }
            b.w = cw;
            b.h = ch;
            break;
          }
        }
        if (!added) {
          let maxy2 = 0;
          assigned.forEach((b) => {
            maxy2 = Math.max(maxy2, b.y + b.h);
          });
          let bottomBlock = blockCache[`0:${maxy2 + sizes.gy}`];
          if (!bottomBlock) {
            bottomBlock = { x: 0, y: maxy2 + sizes.gy, w: cw, h: ch };
            blockCache[`0:${maxy2 + sizes.gy}`] = bottomBlock;
            blocks.push(bottomBlock);
          }
          bottomBlock.used = true;
          bottomBlock.group = child;
          bottomBlock.assigned = true;
          bottomBlock.w = cw;
          bottomBlock.h = ch;
          assigned.push(bottomBlock);
          blockCacheKey = `0:${bottomBlock.y + ch + sizes.gy}`;
          if (!blockCache[blockCacheKey]) {
            blocks.push({ x: 0, y: bottomBlock.y + ch + sizes.gy, w: availableWidth, h: Infinity, used: false });
            blockCache[blockCacheKey] = blocks[blocks.length - 1];
          }
        }
        blocks.sort(blockSort);
      });
      let maxx = 0;
      let maxy = 0;
      assigned.forEach((b) => {
        maxx = Math.max(maxx, b.x + b.w);
        maxy = Math.max(maxy, b.y + b.h);
      });
      const leftPadding = Math.max(0, sizes.gx + (availableWidth - maxx) / 2);
      const nextPositions = {};
      assigned.forEach((b, idx) => {
        const key = children[idx]?.dataset?.gridKey ?? idx;
        nextPositions[key] = { left: leftPadding + b.x, top: b.y, width: b.w };
        b.group?.classList.add("visible");
      });
      setPositions(nextPositions);
      setContainerHeight(maxy + sizes.gy + 3);
    };
    const scheduled = window.setTimeout(computeLayout, 16);
    const handleResize = () => computeLayout();
    window.addEventListener("resize", handleResize);
    return () => {
      cancelled = true;
      window.clearTimeout(scheduled);
      window.removeEventListener("resize", handleResize);
    };
  }, [groups, sizes.columns, sizes.gx, sizes.gy, sizes.px, sizes.sx, layoutMode]);
  return m2`<div style=${gridStyles} ref=${containerRef}>
    ${visible.map((group, idx) => {
    const span = groupColumnSpan(group, sizes.columns);
    const paddingX = Math.max(0, sizes.px);
    const paddingY = Math.max(0, sizes.py);
    const itemGapY = Math.max(0, sizes.cy);
    const itemGapX = Math.max(0, sizes.cx);
    const layoutKey = group.header?.id ?? idx;
    const pos = positions[layoutKey];
    const width = layoutMode === "masonry" ? calcWidth(span) : undefined;
    return m2`<${GroupCard}
        key=${group.header?.id ?? idx}
        group=${group}
        index=${idx}
        columnSpan=${span}
        padding=${{ x: paddingX, y: paddingY }}
        sizes=${{ cy: itemGapY, cx: itemGapX }}
        onEmit=${onEmit}
        tabName=${tabName}
        layoutMode=${layoutMode}
        layoutPos=${layoutMode === "masonry" ? { left: pos?.left ?? 0, top: pos?.top ?? sizes.gy, width: width ?? 0 } : undefined}
      />`;
  })}
  </div>`;
}

// src/preact/components/styles/toastStyles.ts
var overlayStyles = {
  position: "fixed",
  top: "16px",
  right: "16px",
  display: "flex",
  flexDirection: "column",
  gap: "12px",
  zIndex: 9999,
  pointerEvents: "none"
};
var cardBaseStyles = {
  padding: "10px 12px",
  borderRadius: "8px",
  background: "var(--nr-dashboard-toastBackgroundColor, var(--nr-dashboard-groupBackgroundColor, transparent))",
  color: "var(--nr-dashboard-toastTextColor, var(--nr-dashboard-pageTextColor, inherit))",
  minWidth: "260px",
  boxShadow: "var(--nr-dashboard-toastShadow, 0 4px 12px rgba(0,0,0,0.2))",
  pointerEvents: "auto",
  position: "relative"
};
var titleStyles = { fontWeight: 700, marginBottom: "4px" };
var messageStyles = { fontSize: "13px" };
var closeButtonStyles = {
  position: "absolute",
  top: "6px",
  right: "6px",
  background: "transparent",
  border: "none",
  fontWeight: 800,
  cursor: "pointer"
};

// src/preact/components/ToastOverlay.ts
function ToastOverlay(props) {
  const { toasts, onDismiss } = props;
  if (!toasts.length)
    return null;
  const { t: t4 } = useI18n();
  return m2`<div
    style=${overlayStyles}
  >
    ${toasts.map((toast) => {
    const toneColor = resolveToastToneColor(toast.level ?? "info");
    return m2`<div
        key=${toast.id}
        style=${{ ...cardBaseStyles, border: `1px solid ${toneColor}` }}
      >
        <div style=${titleStyles}>${toast.title || t4("toast_overlay_title", "Notification")}</div>
        <div style=${messageStyles}>${String(toast.message ?? "")}</div>
        <button
          type="button"
          aria-label=${t4("toast_overlay_close", "Dismiss notification")}
          onClick=${() => onDismiss(toast.id)}
          style=${{
      ...closeButtonStyles,
      color: toneColor
    }}
        >x</button>
      </div>`;
  })}
  </div>`;
}

// src/preact/index.ts
function resolveLanguage(stateLang, site, navigatorLang) {
  const fromState = stateLang;
  const fromSite = site?.lang ?? site?.locale;
  const candidate = fromState ?? fromSite ?? navigatorLang ?? "en";
  if (typeof candidate !== "string" || candidate.length === 0)
    return "en";
  return candidate;
}
function shouldShowLoading(connection) {
  return connection !== "ready";
}
function findFirstFocusable(root) {
  if (!root)
    return null;
  const selector = "button, [href], input, select, textarea, [tabindex]:not([tabindex='-1'])";
  const candidate = typeof root.querySelector === "function" ? root.querySelector(selector) : null;
  return candidate ?? root;
}
var themeVarMap = {
  "page-backgroundColor": "--nr-dashboard-pageBackgroundColor",
  "page-textColor": "--nr-dashboard-pageTextColor",
  "page-titlebar-backgroundColor": "--nr-dashboard-pageTitlebarBackgroundColor",
  "page-sidebarBackgroundColor": "--nr-dashboard-pageSidebarBackgroundColor",
  "page-sidebarTextColor": "--nr-dashboard-pageSidebarTextColor",
  "group-backgroundColor": "--nr-dashboard-groupBackgroundColor",
  "group-textColor": "--nr-dashboard-groupTextColor",
  "group-borderColor": "--nr-dashboard-groupBorderColor",
  "widget-color": "--nr-dashboard-widgetColor",
  "widget-textColor": "--nr-dashboard-widgetTextColor",
  "widget-backgroundColor": "--nr-dashboard-widgetBackgroundColor",
  "widget-borderColor": "--nr-dashboard-widgetBorderColor",
  "base-color": "--nr-dashboard-baseColor"
};
var appStyles = {
  fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
  background: "var(--nr-dashboard-pageBackgroundColor, #eee)",
  color: "var(--nr-dashboard-pageTextColor, var(--nr-dashboard-widgetTextColor, #000))",
  minHeight: "100vh",
  display: "grid"
};
var toolbarStyles = {
  display: "flex",
  alignItems: "center",
  gap: "12px",
  padding: "0 16px",
  borderBottom: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(0,0,0,0.08))",
  background: "var(--nr-dashboard-pageTitlebarBackgroundColor, #0094CE)",
  color: "#fff"
};
var iconButtonStyles = {
  border: "none",
  background: "transparent",
  color: "inherit",
  width: "40px",
  height: "40px",
  borderRadius: "50%",
  display: "inline-grid",
  placeItems: "center",
  cursor: "pointer",
  transition: "background 120ms ease, color 120ms ease, transform 140ms ease"
};
var floatingToggleStyles = {
  position: "fixed",
  top: "12px",
  left: "12px",
  zIndex: "20",
  border: "none",
  background: "var(--nr-dashboard-widgetBackgroundColor, rgba(0,0,0,0.06))",
  color: "inherit",
  borderRadius: "50%",
  padding: "10px 12px",
  cursor: "pointer",
  boxShadow: "0 6px 16px rgba(0,0,0,0.20)",
  transition: "background 140ms ease, box-shadow 140ms ease"
};
var layoutStyles2 = {
  display: "grid",
  gridTemplateColumns: "260px 1fr",
  minHeight: "100vh",
  position: "relative"
};
var navStyles = {
  borderRight: "1px solid var(--nr-dashboard-sidebarBorderColor, var(--nr-dashboard-widgetBorderColor, rgba(0,0,0,0.08)))",
  padding: "12px 12px 16px",
  color: "var(--nr-dashboard-pageSidebarTextColor, inherit)",
  background: "var(--nr-dashboard-pageSidebarBackgroundColor, transparent)",
  overflowY: "auto"
};
var contentStyles = {
  padding: "16px"
};
function getEffectiveTheme(tab, globalTheme) {
  if (tab?.theme)
    return tab.theme;
  return globalTheme ?? null;
}
function parseColor(value2) {
  if (!value2)
    return null;
  const trimmed = value2.trim();
  if (trimmed.startsWith("#")) {
    const hex = trimmed.slice(1);
    if (hex.length === 3) {
      const [r3, g2, b] = hex.split("");
      return {
        r: parseInt(r3 + r3, 16),
        g: parseInt(g2 + g2, 16),
        b: parseInt(b + b, 16)
      };
    }
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16)
      };
    }
  }
  const rgbMatch = trimmed.match(/rgba?\(([^)]+)\)/i);
  if (rgbMatch) {
    const parts2 = rgbMatch[1].split(",").map((p3) => Number(p3.trim()));
    if (parts2.length >= 3 && parts2.every((n3) => Number.isFinite(n3))) {
      return { r: parts2[0], g: parts2[1], b: parts2[2] };
    }
  }
  return null;
}
function relativeLuminance({ r: r3, g: g2, b }) {
  const channel = (v3) => {
    const n3 = v3 / 255;
    return n3 <= 0.03928 ? n3 / 12.92 : ((n3 + 0.055) / 1.055) ** 2.4;
  };
  const rl = channel(r3);
  const gl = channel(g2);
  const bl = channel(b);
  return 0.2126 * rl + 0.7152 * gl + 0.0722 * bl;
}
function getDashboardRoot2() {
  if (typeof document === "undefined")
    return null;
  return document.getElementById("nr-dashboard-root") ?? document.getElementById("app") ?? document.documentElement;
}
function applyThemeToRoot(theme2, root) {
  if (!root && typeof document === "undefined")
    return;
  const target = root ?? getDashboardRoot2();
  if (!target)
    return;
  if (!theme2?.themeState) {
    Object.values(themeVarMap).forEach((cssVar) => {
      target.style.removeProperty(cssVar);
    });
    return;
  }
  const backgroundValue = theme2.themeState?.["page-backgroundColor"]?.value;
  const textValue = theme2.themeState?.["page-textColor"]?.value;
  Object.entries(themeVarMap).forEach(([key, cssVar]) => {
    const value2 = theme2.themeState?.[key]?.value;
    if (typeof value2 === "string" && value2.length > 0) {
      target.style.setProperty(cssVar, value2);
    } else {
      target.style.removeProperty(cssVar);
    }
  });
  if (!textValue && typeof backgroundValue === "string" && backgroundValue.length > 0) {
    const rgb = parseColor(backgroundValue);
    if (rgb) {
      const lum2 = relativeLuminance(rgb);
      const derivedText = lum2 > 0.6 ? "#0b0d11" : "#f4f6fb";
      target.style.setProperty("--nr-dashboard-pageTextColor", derivedText);
    }
  }
}
function App() {
  ensureLayoutStyles();
  const { state, selectedTab, actions: actions2 } = useDashboardState();
  const tabId = selectedTab?.id ?? selectedTab?.header;
  const locales = T2(() => state.locales ?? hydrateLocales(), [state.locales]);
  const lang = resolveLanguage(state.lang, state.site, typeof navigator !== "undefined" ? navigator.language : undefined);
  y2(() => {
    if (typeof window === "undefined")
      return;
    const applyHash = () => {
      const match = window.location.hash.match(/#\/(\d+)/);
      if (!match)
        return;
      const idx = Number(match[1]);
      if (!Number.isNaN(idx) && idx >= 0 && idx < state.menu.length) {
        actions2.selectTab(idx);
      }
    };
    window.addEventListener("hashchange", applyHash);
    applyHash();
    return () => window.removeEventListener("hashchange", applyHash);
  }, [state.menu.length]);
  y2(() => {
    const theme2 = getEffectiveTheme(selectedTab, state.theme);
    applyThemeToRoot(theme2, getDashboardRoot2() ?? undefined);
  }, [selectedTab, state.theme]);
  return m2`<${I18nProvider} lang=${lang} locales=${locales}>
    <${SizesProvider} site=${state.site} tabId=${tabId}>
      <${DashboardShell}
        state=${state}
        selectedTab=${selectedTab}
        tabId=${tabId}
        actions=${actions2}
      />
      <${ToastOverlay} toasts=${state.toasts} onDismiss=${actions2.dismissToast} />
    </${SizesProvider}>
  </${I18nProvider}>`;
}
function DashboardShell({ state, selectedTab, tabId, actions: actions2 }) {
  const sizes = useSizes();
  const { t: t4 } = useI18n();
  const mainRef = A2(null);
  const shellRef = A2(null);
  const site = state.site ?? null;
  const lockModeRaw = site?.lockMenu;
  const lockMode = typeof lockModeRaw === "boolean" ? lockModeRaw ? "true" : "false" : typeof lockModeRaw === "string" ? lockModeRaw : "false";
  const allowSwipeRaw = site?.allowSwipe;
  const allowSwipe = typeof allowSwipeRaw === "boolean" ? allowSwipeRaw ? "true" : "false" : typeof allowSwipeRaw === "string" ? allowSwipeRaw : "false";
  const isLocked = lockMode === "true";
  const isIconOnly = lockMode === "icon";
  const isSlide = lockMode === "false";
  const hideToolbar = site?.hideToolbar === "true" || site?.hideToolbar === true;
  const hasMultipleTabs = state.menu.length > 1;
  const hasTabs = state.menu.length > 0;
  const [viewportWidth, setViewportWidth] = d2(typeof window !== "undefined" ? window.innerWidth : 1280);
  const [navOpen, setNavOpen] = d2(hasMultipleTabs && (isLocked || isIconOnly));
  y2(() => {
    if (typeof window === "undefined")
      return;
    const handleResize = () => setViewportWidth(window.innerWidth);
    window.addEventListener("resize", handleResize, { passive: true });
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  const toolbarHeight = viewportWidth < 960 ? "48px" : "64px";
  const navMaxWidth = viewportWidth <= 660 ? 200 : 320;
  const navBaseWidth = isIconOnly ? 72 : Math.min(260, navMaxWidth);
  const navWidth = `${Math.max(64, navBaseWidth)}px`;
  const navTop = "0";
  const shellStyles = {
    ...appStyles,
    gridTemplateRows: hideToolbar ? "1fr" : `${toolbarHeight} 1fr`
  };
  useLayoutAnnouncements(selectedTab?.items ?? [], sizes, tabId);
  y2(() => {
    if (state.connection !== "ready")
      return;
    const target = findFirstFocusable(mainRef.current);
    if (target && typeof target.focus === "function") {
      const focusOptions = { preventScroll: true };
      target.focus(focusOptions);
    }
  }, [selectedTab, state.connection]);
  y2(() => {
    if (!hasTabs) {
      setNavOpen(false);
      return;
    }
    if (!hasMultipleTabs && (isLocked || isIconOnly)) {
      setNavOpen(true);
      return;
    }
    if (hasMultipleTabs && (isLocked || isIconOnly || lockMode === "true")) {
      setNavOpen(true);
    }
  }, [hasMultipleTabs, hasTabs, isIconOnly, isLocked, lockMode]);
  y2(() => {
    const node = shellRef.current;
    const allowMenuSwipe = allowSwipe === "menu";
    const allowTabSwipe = allowSwipe === "true" || allowSwipe === "mouse";
    const allowMouseSwipe = allowSwipe === "mouse";
    if (!node || !allowMenuSwipe && !allowTabSwipe)
      return;
    let startX = 0;
    let startY = 0;
    let activePointerId = null;
    const handlePointerDown = (event) => {
      if (!event.isPrimary)
        return;
      if (event.pointerType === "mouse" && !allowMouseSwipe)
        return;
      activePointerId = event.pointerId;
      startX = event.clientX;
      startY = event.clientY;
    };
    const handlePointerUp = (event) => {
      if (activePointerId == null || event.pointerId !== activePointerId)
        return;
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      activePointerId = null;
      if (Math.abs(dx) < 40 || Math.abs(dy) > Math.abs(dx))
        return;
      if (event.pointerType === "mouse" && !allowMouseSwipe)
        return;
      const direction = dx < 0 ? "left" : "right";
      if (allowMenuSwipe && !isLocked && !isIconOnly) {
        setNavOpen(direction === "right");
        return;
      }
      if (allowTabSwipe) {
        const delta = direction === "left" ? -1 : 1;
        const next = findNextTabIndex(state.menu, state.selectedTabIndex ?? 0, delta);
        if (next != null) {
          if (typeof window !== "undefined") {
            window.location.hash = `#/${next}`;
          }
          actions2.selectTab(next);
        }
      }
    };
    node.addEventListener("pointerdown", handlePointerDown, { passive: true });
    node.addEventListener("pointerup", handlePointerUp, { passive: true });
    return () => {
      node.removeEventListener("pointerdown", handlePointerDown);
      node.removeEventListener("pointerup", handlePointerUp);
    };
  }, [actions2, allowSwipe, isIconOnly, isLocked, state.menu, state.selectedTabIndex]);
  const statusLabel = (() => {
    switch (state.connection) {
      case "ready":
        return t4("status_connected", "Connected");
      case "connecting":
        return t4("status_connecting", "Connecting");
      default:
        return t4("status_disconnected", "Disconnected");
    }
  })();
  const toolbarTitle = (() => {
    const tabTitle = selectedTab?.header ?? selectedTab?.name;
    const siteTitle = site?.name;
    if (isLocked || isIconOnly) {
      return siteTitle ?? "";
    }
    return tabTitle ?? siteTitle ?? "";
  })();
  const shouldRenderNav = hasTabs && (navOpen || isLocked || isIconOnly);
  const gridTemplateColumns = isLocked || isIconOnly ? `${isIconOnly ? "72px" : "260px"} 1fr` : "1fr";
  const sectionMinHeight = hideToolbar ? "100vh" : `calc(100vh - ${toolbarHeight})`;
  const showToggle = isSlide && hasTabs;
  const showFloatingToggle = isSlide && hasTabs && hideToolbar;
  return m2`
    <div style=${shellStyles} ref=${shellRef}>
      ${hideToolbar ? null : m2`<header style=${toolbarStyles}>
            ${showToggle ? m2`<button
                  type="button"
                  aria-label=${t4("toggle_menu", "Toggle menu")}
                  onClick=${() => setNavOpen((v3) => !v3)}
                  class="nr-dashboard-icon-press"
                  style=${{
    ...iconButtonStyles,
    background: navOpen ? "rgba(0,0,0,0.10)" : "var(--nr-dashboard-widgetBackgroundColor, rgba(0,0,0,0.04))",
    transform: navOpen ? "scale(0.98)" : "scale(1)"
  }}
                >${navOpen ? "" : ""}</button>` : null}
            <strong>${toolbarTitle}</strong>
            <span style=${{ marginLeft: "auto" }}></span>
          </header>`}
      <section
        style=${{
    ...layoutStyles2,
    gridTemplateColumns,
    minHeight: sectionMinHeight
  }}
      >
        ${showFloatingToggle ? m2`<button
              type="button"
              aria-label=${t4("toggle_menu", "Toggle menu")}
              onClick=${() => setNavOpen((v3) => !v3)}
              class="nr-dashboard-icon-press"
              style=${{
    ...floatingToggleStyles,
    ...iconButtonStyles,
    background: navOpen ? "rgba(0,0,0,0.10)" : "var(--nr-dashboard-widgetBackgroundColor, rgba(0,0,0,0.06))",
    width: "44px",
    height: "44px",
    boxShadow: navOpen ? "0 6px 18px rgba(0,0,0,0.30)" : floatingToggleStyles.boxShadow
  }}
            >${navOpen ? "" : ""}</button>` : null}

        ${shouldRenderNav ? m2`${isSlide && !isLocked && !isIconOnly && navOpen ? m2`<div
                  role="button"
                  aria-label=${t4("close_menu", "Close menu")}
                  onClick=${() => setNavOpen(false)}
                  style=${{
    position: "absolute",
    inset: 0,
    background: "rgba(0,0,0,0.28)",
    zIndex: 9,
    animation: "nr-dashboard-nav-backdrop 180ms ease-out"
  }}
                ></div>` : null}
            <nav
              style=${{
    ...navStyles,
    padding: isIconOnly ? "12px 10px" : navStyles.padding,
    width: navWidth,
    minWidth: isIconOnly ? "72px" : "64px",
    maxWidth: isIconOnly ? "72px" : `${navMaxWidth}px`,
    background: "var(--nr-dashboard-pageSidebarBackgroundColor, transparent)",
    position: isSlide && !isLocked && !isIconOnly ? "absolute" : "relative",
    left: isSlide && !isLocked && !isIconOnly ? navOpen ? "0" : `-${navMaxWidth + 20}px` : undefined,
    top: navTop,
    bottom: 0,
    transition: "left 0.18s ease-out",
    zIndex: 10,
    boxShadow: isSlide && !isLocked && !isIconOnly ? navOpen ? "2px 0 10px rgba(0,0,0,0.28)" : "0 0 0 rgba(0,0,0,0)" : "1px 0 5px rgba(0,0,0,0.16)",
    backdropFilter: undefined
  }}
            >
              ${isSlide && !isLocked && !isIconOnly ? m2`<div style=${{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "10px" }}>
                  <h3 style=${{ margin: 0, fontSize: "14px", fontWeight: 600 }}>${t4("tabs_label", "Tabs")}</h3>
                    <button
                      class="nr-dashboard-icon-press"
                      type="button"
                      aria-label=${t4("close_menu", "Close menu")}
                      onClick=${() => setNavOpen(false)}
                      style=${{
    ...iconButtonStyles,
    width: "36px",
    height: "36px",
    border: "1px solid var(--nr-dashboard-widgetBorderColor, rgba(0,0,0,0.20))",
    background: "var(--nr-dashboard-widgetBackgroundColor, rgba(0,0,0,0.06))"
  }}
                    ></button>
                  </div>` : isIconOnly ? null : m2`<h3 style=${{ marginTop: "4px", marginBottom: "12px", fontSize: "14px", fontWeight: 600 }}>${t4("tabs_label", "Tabs")}</h3>`}
              <${TabNav}
                menu=${state.menu}
                selectedIndex=${state.selectedTabIndex}
                variant=${isIconOnly ? "icon" : "full"}
                onSelect=${(idx) => {
    if (typeof window !== "undefined") {
      window.location.hash = `#/${idx}`;
    }
    actions2.selectTab(idx);
    if (isSlide) {
      setNavOpen(false);
    }
  }}
              />
            </nav>` : null}

        <main ref=${mainRef} style=${contentStyles} tabIndex=${-1}>
          ${shouldShowLoading(state.connection) ? m2`<${LoadingScreen} message=${t4("loading", "Loading dashboard...")} />` : state.menu.length === 0 ? m2`<div
              class="nr-dashboard-fade-in"
                style=${{
    textAlign: "center",
    opacity: 0.85,
    padding: "48px 16px",
    display: "grid",
    placeItems: "center",
    gap: "10px"
  }}
              >
                <img src="./icon120x120.png" alt="Node-RED Dashboard" width="120" height="120" style=${{ opacity: 0.9 }} />
                <p style=${{ margin: "4px 0", fontSize: "18px", fontWeight: 600 }}>${t4("welcome_title", "Welcome to the Node-RED Dashboard")}</p>
                <p style=${{ margin: 0, maxWidth: "420px" }}>${t4("welcome_body", "Please add some UI nodes to your flow and redeploy.")}</p>
              </div>` : (() => {
    if (!selectedTab) {
      return m2`<div style=${{ opacity: 0.7 }}>${t4("select_tab_prompt", "Select a tab to view its content.")}</div>`;
    }
    if (selectedTab.link) {
      return m2`<div style=${{ width: "100%", minHeight: "80vh", position: "relative" }}>
                    <iframe
                      src=${selectedTab.link}
                      style=${{
        border: "none",
        borderRadius: "0",
        width: "100%",
        height: "100%",
        background: "transparent",
        display: "block",
        position: "absolute",
        inset: 0
      }}
                      allowfullscreen
                    ></iframe>
                  </div>`;
    }
    return m2`<${GroupGrid}
                  groups=${selectedTab.items ?? []}
                  sizes=${{
      columns: sizes.columns,
      gx: sizes.gx,
      gy: sizes.gy,
      px: sizes.px,
      py: sizes.py,
      cy: sizes.cy,
      cx: sizes.cx,
      sx: sizes.sx,
      dense: Boolean(state.site?.sizes?.dense ?? state.site?.layout?.dense ?? false),
      layoutMode: state.site?.sizes?.layoutMode ?? sizes.layoutMode ?? "grid"
    }}
                  onEmit=${actions2.emit ?? undefined}
                  tabName=${selectedTab.header ?? selectedTab.name ?? ""}
                />`;
  })()}
        </main>
      </section>
    </div>
  `;
}
function LoadingScreen({ message }) {
  return m2`<div
    style=${{
    display: "grid",
    placeItems: "center",
    padding: "48px 16px",
    color: "rgba(0,0,0,0.65)"
  }}
  >
    <div style=${{ display: "grid", placeItems: "center", gap: "12px" }}>
      <img src="./wheel.png" alt=${message} width="72" height="72" class="nr-dashboard-wheel-spin" style=${{ opacity: 0.9 }} />
      <p style=${{ margin: 0, fontSize: "14px", fontWeight: 500 }}>${message}</p>
    </div>
  </div>`;
}
function bootstrap() {
  if (typeof document === "undefined")
    return;
  const root = document.getElementById("nr-dashboard-root") ?? (() => {
    const el = document.createElement("div");
    el.id = "nr-dashboard-root";
    document.body.appendChild(el);
    return el;
  })();
  G(m2`<${App} />`, root);
}
bootstrap();
export {
  shouldShowLoading,
  resolveSizes,
  resolveLanguage,
  groupColumnSpan,
  findFirstFocusable,
  bootstrap,
  applyThemeToRoot,
  applySizesToRoot,
  App
};
